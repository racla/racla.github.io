{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":0},{"_id":"source/images/avatar1.jpg","path":"images/avatar1.jpg","modified":1,"renderable":0},{"_id":"source/images/reentrantlock1.png","path":"images/reentrantlock1.png","modified":1,"renderable":0},{"_id":"source/images/MySQL_ACID.png","path":"images/MySQL_ACID.png","modified":1,"renderable":0},{"_id":"source/files/building-data-driven-internet-of-things-iot-applications.pdf","path":"files/building-data-driven-internet-of-things-iot-applications.pdf","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"source/files/docker-mta/ROI_Infographic_9-13-17.pdf","path":"files/docker-mta/ROI_Infographic_9-13-17.pdf","modified":1,"renderable":0},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"source/files/docker-mta/Docker-for-Virtualization-Admin-eBook.pdf","path":"files/docker-mta/Docker-for-Virtualization-Admin-eBook.pdf","modified":1,"renderable":0},{"_id":"source/files/docker-mta/WP_Docker and the 3 ways devops.pdf","path":"files/docker-mta/WP_Docker and the 3 ways devops.pdf","modified":1,"renderable":0},{"_id":"source/files/docker-mta/SB_MTA_04.14.2017.pdf","path":"files/docker-mta/SB_MTA_04.14.2017.pdf","modified":1,"renderable":0},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"source/files/applying-chatbots-into-iot.pdf","path":"files/applying-chatbots-into-iot.pdf","modified":1,"renderable":0},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"source/files/IoT-Suite.pdf","path":"files/IoT-Suite.pdf","modified":1,"renderable":0},{"_id":"source/files/Java_1512024443940-Reviewed20180115.pdf","path":"files/Java_1512024443940-Reviewed20180115.pdf","modified":1,"renderable":0}],"Cache":[{"_id":"source/googlecc99871950e7b1b0.html","hash":"f4b0cd5ccd00a2ee4eef6e8e4f82ca2000116dc0","modified":1588486490711},{"_id":"source/robots.txt","hash":"51cce8b935a3a50de91f32f41bc95c3e7d177749","modified":1588486490714},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1588486490755},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1588486490757},{"_id":"themes/next/README.cn.md","hash":"87950c415dd162ff78e98b41f1148b85462103e2","modified":1588486490756},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1588486490757},{"_id":"themes/next/README.md","hash":"927f82cfeb5969a89b815b5ec3a3f2881e3b1bb4","modified":1588486490756},{"_id":"themes/next/_config.yml","hash":"47530dbedf9811e2d075c6e1597c668f2094294a","modified":1588486490757},{"_id":"themes/next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1588486490816},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1588486490669},{"_id":"source/404/index.html","hash":"4546907ffdf9a28c4e3ff9756dc5c7bd241d96f7","modified":1588486490668},{"_id":"source/_posts/100-Same-Tree.md","hash":"007716fdc0576141b4510290596c62f91379cbea","modified":1588486490669},{"_id":"source/_posts/121-Best-Time-to-Buy-and-Sell-Stock.md","hash":"3f2e7f6b434b0aa66d6fa045a78b3078bd8509c8","modified":1588486490670},{"_id":"source/_posts/147-Insertion-Sort-List.md","hash":"59eab7f2339a2448794cdd4482ce2fbd78ccdf67","modified":1588486490671},{"_id":"source/_posts/120-Triangle.md","hash":"7a90545689dd9aa7a93e067addf721e69d7ba6da","modified":1588486490670},{"_id":"source/_posts/143-Reorder-List.md","hash":"d17d186f62704a4202b86b3bc92ea8fe20a71605","modified":1588486490670},{"_id":"source/_posts/148-Sort-List.md","hash":"cfb51f34e8c7357c5bdd24758312872170ed00aa","modified":1588486490672},{"_id":"source/_posts/19-Remove-Nth-Node-From-End-of-List.md","hash":"281c3e96d6d4e9b0265c476dc30a8baa25ed1a6f","modified":1588486490672},{"_id":"source/_posts/216-Combination-Sum-III.md","hash":"b5d982dfba53e4fb5f36f9a398c65981d1872172","modified":1588486490672},{"_id":"source/_posts/25-Reverse-Nodes-in-k-Group.md","hash":"47e7b8101dc1ef4cd4035a975f372f23d390a526","modified":1588486490674},{"_id":"source/_posts/24-Swap-Nodes-in-Pairs.md","hash":"9700733d75371b126844265a0f1d40377056903c","modified":1588486490673},{"_id":"source/_posts/377-Combination-Sum-IV.md","hash":"efb9fe1ef5f935cde027d23df9c78d287d249cd2","modified":1588486490674},{"_id":"source/_posts/46-Permutations.md","hash":"09cba3b8ce1b6cc1cde8920c4a9759f5d81494ef","modified":1588486490675},{"_id":"source/_posts/23-Merge-k-Sorted-Lists.md","hash":"36ea5270755aab11c1304788ffb630340fc74c53","modified":1588486490673},{"_id":"source/_posts/39-Combination-Sum.md","hash":"304b6e78b45a7a1daf01af3de0c644c337c7ebb6","modified":1588486490674},{"_id":"source/_posts/40-Combination-Sum-II.md","hash":"26300aa6595ceb0693793ba52d060e8eb74ab815","modified":1588486490675},{"_id":"source/_posts/47-Permutations-II.md","hash":"a22f4b001d1a75982ee63d1ebcda574ac8646dca","modified":1588486490675},{"_id":"source/_posts/49-Group-Anagrams.md","hash":"b3950b251240a16c32093b8d3f3bcae8de9bdfed","modified":1588486490676},{"_id":"source/_posts/55-Jump-Game.md","hash":"f89bdc751106d683d413c98b19e86b1f2b90429f","modified":1588486490676},{"_id":"source/_posts/61-Rotate-List.md","hash":"487d4d685545e46a6f7ace1cc23133d88792a6eb","modified":1588486490676},{"_id":"source/_posts/86-Partition-List.md","hash":"27fb9246702b5be05fe32daff25d69d0bbba466e","modified":1588486490677},{"_id":"source/_posts/92-Reverse-Linked-List-II.md","hash":"4b6cc9849c525c57979535a9526830f0ba1895d8","modified":1588486490678},{"_id":"source/_posts/82-Remove-Duplicates-from-Sorted-List-II.md","hash":"093d871d9cc43d5b0d2906071e3cf9a95bd4c4c6","modified":1588486490677},{"_id":"source/_posts/87-Scramble-String.md","hash":"46a2378ae0d0547c1d5d8f445dcd154f9c440b96","modified":1588486490677},{"_id":"source/_posts/99-Recover-Binary-Search-Tree.md","hash":"e3392fbccf96ff3e988b3181e4c428c346582504","modified":1588486490678},{"_id":"source/_posts/Java.md","hash":"fce4523d9b968522499762a00cf0b3796463d12b","modified":1588486490679},{"_id":"source/_posts/Https.md","hash":"ed823487b50b1e40963f08a237158e43ad0056a2","modified":1588486490678},{"_id":"source/_posts/《STL-源码剖析》阅读总结-设计模式-迭代器模式.md","hash":"6824c6d59aa09e5c0230529533f2cbb93d79a5d1","modified":1588942536956},{"_id":"source/_posts/《STL-源码剖析》阅读总结-设计模式-适配器模式.md","hash":"459d52003dfbc54e7618e988da0b11aa2323cb22","modified":1588946006136},{"_id":"source/_posts/MySQL-ACID.md","hash":"745588e464bad988e5730b0fd56f2b39692c0070","modified":1588486490679},{"_id":"source/_posts/《More-Effective-C-》阅读总结-缓式评估，超急评估.md","hash":"009652f4a55510dc418986fd39841051fba3f094","modified":1589183943740},{"_id":"source/about/index.md","hash":"b3ecb83df5d6000e734a25b5b3ee59cfebb55a3c","modified":1588486490680},{"_id":"source/categories/index.md","hash":"ce862d6591831d1533d1f46dc2c02a4b23f44a1c","modified":1588486490681},{"_id":"source/_posts/ReentrantLock.md","hash":"cf9383b881f23fdf06c18da4588cc7e1a1d770fe","modified":1588486490680},{"_id":"source/artifacts/hono-docker-compose.yml","hash":"0b6521751206d27b993d5b4feff07beed0e33556","modified":1588486490681},{"_id":"source/images/avatar.jpg","hash":"d9f6adea889194eca7f2f9a638860655f82ba0e7","modified":1588486490713},{"_id":"source/images/avatar1.jpg","hash":"964e4f70e2c7d276c7ac00efe61b183c48a8fe77","modified":1588486490713},{"_id":"source/samplecodes/.DS_Store","hash":"f289bd0c554f09dd7ea7e1d804f2997973f512ee","modified":1588486490715},{"_id":"source/tags/index.md","hash":"d64fd85061293f62df4c483dc27816b6817f756a","modified":1588486490715},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1588486490758},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1588486490759},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1588486490759},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1588486490759},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1588486490760},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1588486490760},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1588486490761},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1588486490761},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1588486490762},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1588486490762},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1588486490762},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1588486490763},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1588486490763},{"_id":"themes/next/languages/zh-Hans.yml","hash":"66b9b42f143c3cb2f782a94abd4c4cbd5fd7f55f","modified":1588486490763},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1588486490764},{"_id":"source/images/reentrantlock1.png","hash":"b105a8c573fa112fb530c8326b23486a78a031de","modified":1588486490714},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1588486490814},{"_id":"source/images/MySQL_ACID.png","hash":"94178d660552484982d5efa1d8aa7396ed58ceb5","modified":1588486490712},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1588486490764},{"_id":"themes/next/layout/_layout.swig","hash":"2164570bb05db11ee4bcfbbb5d183a759afe9d07","modified":1588486490765},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1588486490814},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1588486490814},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1588486490815},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1588486490816},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1588486490817},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1588486490816},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1588486490815},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1588486490815},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1588486490931},{"_id":"source/files/building-data-driven-internet-of-things-iot-applications.pdf","hash":"14adbe6c0509072022fae1bcc9781f11f963abe8","modified":1588486490702},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1588486490931},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1588486490931},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588486490862},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1588486490765},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1588486490766},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1588486490765},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1588486490766},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1588486490787},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9c7343fd470e0943ebd75f227a083a980816290b","modified":1588486490787},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1588486490788},{"_id":"themes/next/layout/_partials/comments.swig","hash":"b59ea3eb56b2a904ae541323e8fd53d0072e2c67","modified":1588486490788},{"_id":"themes/next/layout/_partials/footer.swig","hash":"faeaf3c8a572e8279451f5eb5169a4b29ba9a5ac","modified":1588486490789},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1588486490791},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1588486490791},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1588486490792},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1588486490792},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1588486490796},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1588486490796},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1588486490807},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1588486490809},{"_id":"themes/next/layout/_macro/post.swig","hash":"4ba938822d56c597490f0731893eaa2443942e0f","modified":1588486490786},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1588486490798},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1588486490810},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1588486490809},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1588486490810},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1588486490811},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1588486490818},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1588486490818},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1588486490818},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1588486490819},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1588486490819},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1588486490819},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1588486490820},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1588486490820},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1588486490821},{"_id":"themes/next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1588486490789},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1588486490810},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1588486490861},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1588486490862},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1588486490862},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1588486490863},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1588486490863},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1588486490864},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1588486490864},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1588486490865},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1588486490865},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1588486490866},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1588486490867},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1588486490865},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1588486490867},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1588486490866},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1588486490867},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1588486490868},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1588486490868},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1588486490868},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1588486490866},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588486490797},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588486490797},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588486490849},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588486490849},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588486490850},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588486490860},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588486490861},{"_id":"source/files/docker-mta/ROI_Infographic_9-13-17.pdf","hash":"ef51c7ffdb652b465e71aad40b06adcd602a8240","modified":1588486490706},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1588486490790},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1588486490793},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1588486490793},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1588486490793},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1588486490794},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1588486490790},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1588486490796},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1588486490797},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1588486490798},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1588486490799},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1588486490794},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1588486490795},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1588486490795},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1588486490799},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1588486490800},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1588486490801},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1588486490801},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1588486490802},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1588486490799},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1588486490802},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1588486490803},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1588486490800},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1588486490801},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1588486490802},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1588486490803},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1588486490804},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1588486490804},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1588486490804},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"1b146890f0fb2c9b5025cb7e8d633e39da05224f","modified":1588486490805},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"75d973fc442af673a15b253379a1839df29b1a32","modified":1588486490806},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1588486490806},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1588486490807},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"1359c906f812ba7fa78cad47a3684755426c341d","modified":1588486490805},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1588486490805},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1588486490806},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1588486490812},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1588486490813},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1588486490813},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1588486490849},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1588486490849},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1588486490850},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1588486490860},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1588486490812},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1588486490850},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1588486490859},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1588486490860},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1588486490861},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1588486490869},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1588486490869},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1588486490870},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1588486490871},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1588486490872},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1588486490871},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1588486490873},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1588486490872},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1588486490870},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1588486490873},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1588486490883},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1588486490884},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1588486490874},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1588486490884},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1588486490892},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1588486490885},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1588486490880},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1588486490893},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1588486490895},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1588486490892},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1588486490893},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1588486490895},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1588486490897},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1588486490897},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1588486490897},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1588486490908},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1588486490910},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1588486490910},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1588486490911},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1588486490911},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1588486490911},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1588486490912},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1588486490913},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1588486490914},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1588486490915},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1588486490915},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1588486490916},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1588486490916},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1588486490915},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1588486490917},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1588486490917},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1588486490918},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1588486490917},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1588486490918},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1588486490918},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1588486490919},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1588486490913},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1588486490914},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1588486490920},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1588486490920},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1588486490926},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1588486490921},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1588486490919},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1588486490927},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1588486490930},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1588486490929},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1588486490930},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1588486490909},{"_id":"source/files/docker-mta/Docker-for-Virtualization-Admin-eBook.pdf","hash":"94b26aad4e5d6bff6382d888efa0cee9ae543174","modified":1588486490705},{"_id":"source/files/docker-mta/WP_Docker and the 3 ways devops.pdf","hash":"c15b2da8f92cb6afec7b5aea406b4f98f88bb73f","modified":1588486490711},{"_id":"source/files/docker-mta/SB_MTA_04.14.2017.pdf","hash":"711f8e42781692cd080f48edd964a201b9f424cb","modified":1588486490708},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1588486490812},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1588486490811},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1588486490822},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1588486490822},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1588486490823},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1588486490822},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1588486490823},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1588486490829},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1588486490838},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1588486490846},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1588486490846},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1588486490847},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1588486490848},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1588486490847},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1588486490848},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1588486490848},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1588486490852},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1588486490851},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1588486490852},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1588486490852},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1588486490852},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1588486490853},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1588486490853},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1588486490854},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1588486490855},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1588486490856},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1588486490855},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1588486490856},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1588486490856},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1588486490857},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"c7e5c078182dbc42a9bb2a841febaefe17851c3f","modified":1588486490858},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1588486490858},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1588486490858},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1588486490859},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1588486490859},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1588486490873},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1588486490879},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1588486490879},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1588486490885},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1588486490886},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1588486490886},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1588486490886},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1588486490887},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1588486490887},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1588486490890},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1588486490891},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1588486490891},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1588486490894},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1588486490894},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1588486490898},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1588486490877},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1588486490899},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1588486490898},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1588486490925},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1588486490926},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1588486490878},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1588486490907},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1588486490908},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1588486490929},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1588486490824},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1588486490825},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1588486490824},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1588486490825},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1588486490826},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1588486490826},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1588486490827},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1588486490827},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1588486490828},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1588486490828},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1588486490825},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1588486490829},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1588486490826},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1588486490827},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1588486490830},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1588486490829},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1588486490830},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1588486490831},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1588486490830},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1588486490832},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1588486490831},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1588486490833},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1588486490832},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1588486490833},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1588486490832},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1588486490832},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1588486490833},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1588486490834},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1588486490835},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1588486490835},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1588486490835},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1588486490835},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1588486490836},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1588486490836},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1588486490834},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1588486490838},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1588486490837},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1588486490837},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1588486490837},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1588486490839},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1588486490840},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1588486490839},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1588486490840},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1588486490839},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1588486490842},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1588486490841},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1588486490841},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1588486490843},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1588486490841},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1588486490844},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1588486490843},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1588486490842},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1588486490844},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1588486490845},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1588486490844},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1588486490845},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1588486490843},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1588486490845},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1588486490854},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1588486490855},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1588486490857},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1588486490875},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1588486490875},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1588486490876},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1588486490876},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1588486490876},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1588486490888},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1588486490888},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1588486490888},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1588486490889},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1588486490906},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1588486490889},{"_id":"source/files/applying-chatbots-into-iot.pdf","hash":"ee9fd07a9e0a478b3f5f96ac2b76033234010a8e","modified":1588486490700},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1588486490890},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1588486490901},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1588486490903},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1588486490883},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1588486490924},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1588486490905},{"_id":"source/files/IoT-Suite.pdf","hash":"599a21375fc47fb9c55f2ebdfd5ca7c44541caad","modified":1588486490688},{"_id":"source/files/Java_1512024443940-Reviewed20180115.pdf","hash":"822b09e628f1023431d20c0dd49bba64e1d22e6b","modified":1588486490695}],"Category":[{"name":"LeetCode","_id":"cka27ixuq0011k4r36qajfq08"},{"name":"中文","_id":"cka27ixwo0026k4r3gufmjozv"},{"name":"Computer Network","_id":"cka27ixww002ck4r3o87bqxdu"},{"name":"C++","_id":"cka27ixx4002hk4r3c1yfren1"},{"name":"Concurrency","_id":"cka27ixxa002lk4r3b0vgndaw"},{"name":"Java","parent":"cka27ixwo0026k4r3gufmjozv","_id":"cka27iy0c0033k4r34nv29d27"},{"name":"Database","parent":"cka27ixwo0026k4r3gufmjozv","_id":"cka27iy0h0039k4r3wp1nx3hd"}],"Data":[],"Page":[{"layout":"false","_content":"google-site-verification: googlecc99871950e7b1b0.html\n","source":"googlecc99871950e7b1b0.html","raw":"layout: false\n---\ngoogle-site-verification: googlecc99871950e7b1b0.html\n","date":"2020-05-03T06:14:50.711Z","updated":"2020-05-03T06:14:50.711Z","path":"googlecc99871950e7b1b0.html","title":"","comments":1,"_id":"cka27ixdv0000k4r3sr3waf5i","content":"google-site-verification: googlecc99871950e7b1b0.html\n","site":{"data":{}},"excerpt":"","more":"google-site-verification: googlecc99871950e7b1b0.html\n"},{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\"\n          charset=\"utf-8\" homePageUrl=\"/\"\n          homePageName=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>\n","source":"404/index.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\"\n          charset=\"utf-8\" homePageUrl=\"/\"\n          homePageName=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>\n","date":"2020-05-03T06:14:50.668Z","updated":"2020-05-03T06:14:50.668Z","path":"404/index.html","title":"","comments":1,"layout":"page","_id":"cka27ixqb0001k4r3hym8yamv","content":"<!DOCTYPE HTML>\n<html>\n<head><meta name=\"generator\" content=\"Hexo 3.9.0\">\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>\n","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head><meta name=\"generator\" content=\"Hexo 3.9.0\">\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>\n"},{"title":"about","date":"2017-05-08T13:59:13.000Z","_content":"Contact me: racle0704@foxmail.com\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-05-08 21:59:13\n---\nContact me: racle0704@foxmail.com\n","updated":"2020-05-03T06:14:50.680Z","path":"about/index.html","comments":1,"layout":"page","_id":"cka27ixqq0003k4r3e73h759a","content":"<p>Contact me: racle0704@foxmail.com</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Contact me: racle0704@foxmail.com</p>\n"},{"_content":"version: '3.0'\n\nnetworks:\n  hono-net:\n    driver: overlay\n\nservices:\n\n  qdrouter:\n    image: registry.docker-cn.com/eclipsehono/dispatch-router:0.5-M5\n    networks:\n      - hono-net\n    command: /usr/sbin/qdrouterd -c /etc/hono/qdrouter/qdrouterd.json\n    ports:\n      - \"15671:5671\"\n      - \"15672:5672\"\n\n  hono:\n    image: registry.docker-cn.com/eclipsehono/hono-server:0.5-M5\n    networks:\n      - hono-net\n    ports:\n      - \"5671:5671\"\n    environment:\n      - HONO_DOWNSTREAM_HOST=qdrouter\n      - HONO_DOWNSTREAM_PORT=5673\n      - HONO_DOWNSTREAM_KEY_STORE_PATH=/etc/hono/certs/honoKeyStore.p12\n      - HONO_DOWNSTREAM_KEY_STORE_PASSWORD=honokeys\n      - HONO_DOWNSTREAM_TRUST_STORE_PATH=/etc/hono/certs/trusted-certs.pem\n      - HONO_SERVER_BIND_ADDRESS=0.0.0.0\n      - HONO_SERVER_KEY_STORE_PATH=/etc/hono/certs/honoKeyStore.p12\n      - HONO_SERVER_KEY_STORE_PASSWORD=honokeys\n      - HONO_SERVER_INSECURE_PORT_ENABLED=false\n      - HONO_SERVER_MAX_INSTANCES=1\n      - LOGGING_CONFIG=classpath:logback-spring.xml\n      - SPRING_PROFILES_ACTIVE=default,dev\n    volumes:\n      - /home/hono/registration\n\n  rest-adapter:\n    image: registry.docker-cn.com/eclipsehono/hono-adapter-rest-vertx:0.5-M5\n    networks:\n      - hono-net\n    ports:\n      - \"8080:8080\"\n    environment:\n      - HONO_CLIENT_NAME=Hono REST Adapter\n      - HONO_CLIENT_HOST=hono\n      - HONO_CLIENT_PORT=5671\n      - HONO_CLIENT_USERNAME=rest-adapter\n      - HONO_CLIENT_PASSWORD=secret\n      - HONO_CLIENT_TRUST_STORE_PATH=/etc/hono/certs/trusted-certs.pem\n      - HONO_HTTP_BIND_ADDRESS=0.0.0.0\n      - HONO_HTTP_MAX_INSTANCES=1\n      - SPRING_PROFILES_ACTIVE=dev\n\n  mqtt-adapter:\n    image: registry.docker-cn.com/eclipsehono/hono-adapter-mqtt-vertx:0.5-M5\n    networks:\n      - hono-net\n    ports:\n      - \"1883:1883\"\n    environment:\n      - HONO_CLIENT_NAME=Hono MQTT Adapter\n      - HONO_CLIENT_HOST=hono\n      - HONO_CLIENT_PORT=5671\n      - HONO_CLIENT_USERNAME=mqtt-adapter\n      - HONO_CLIENT_PASSWORD=secret\n      - HONO_CLIENT_TRUST_STORE_PATH=/etc/hono/certs/trusted-certs.pem\n      - HONO_MQTT_BIND_ADDRESS=0.0.0.0\n      - HONO_MQTT_MAX_INSTANCES=1\n      - SPRING_PROFILES_ACTIVE=dev\n","source":"artifacts/hono-docker-compose.yml","raw":"version: '3.0'\n\nnetworks:\n  hono-net:\n    driver: overlay\n\nservices:\n\n  qdrouter:\n    image: registry.docker-cn.com/eclipsehono/dispatch-router:0.5-M5\n    networks:\n      - hono-net\n    command: /usr/sbin/qdrouterd -c /etc/hono/qdrouter/qdrouterd.json\n    ports:\n      - \"15671:5671\"\n      - \"15672:5672\"\n\n  hono:\n    image: registry.docker-cn.com/eclipsehono/hono-server:0.5-M5\n    networks:\n      - hono-net\n    ports:\n      - \"5671:5671\"\n    environment:\n      - HONO_DOWNSTREAM_HOST=qdrouter\n      - HONO_DOWNSTREAM_PORT=5673\n      - HONO_DOWNSTREAM_KEY_STORE_PATH=/etc/hono/certs/honoKeyStore.p12\n      - HONO_DOWNSTREAM_KEY_STORE_PASSWORD=honokeys\n      - HONO_DOWNSTREAM_TRUST_STORE_PATH=/etc/hono/certs/trusted-certs.pem\n      - HONO_SERVER_BIND_ADDRESS=0.0.0.0\n      - HONO_SERVER_KEY_STORE_PATH=/etc/hono/certs/honoKeyStore.p12\n      - HONO_SERVER_KEY_STORE_PASSWORD=honokeys\n      - HONO_SERVER_INSECURE_PORT_ENABLED=false\n      - HONO_SERVER_MAX_INSTANCES=1\n      - LOGGING_CONFIG=classpath:logback-spring.xml\n      - SPRING_PROFILES_ACTIVE=default,dev\n    volumes:\n      - /home/hono/registration\n\n  rest-adapter:\n    image: registry.docker-cn.com/eclipsehono/hono-adapter-rest-vertx:0.5-M5\n    networks:\n      - hono-net\n    ports:\n      - \"8080:8080\"\n    environment:\n      - HONO_CLIENT_NAME=Hono REST Adapter\n      - HONO_CLIENT_HOST=hono\n      - HONO_CLIENT_PORT=5671\n      - HONO_CLIENT_USERNAME=rest-adapter\n      - HONO_CLIENT_PASSWORD=secret\n      - HONO_CLIENT_TRUST_STORE_PATH=/etc/hono/certs/trusted-certs.pem\n      - HONO_HTTP_BIND_ADDRESS=0.0.0.0\n      - HONO_HTTP_MAX_INSTANCES=1\n      - SPRING_PROFILES_ACTIVE=dev\n\n  mqtt-adapter:\n    image: registry.docker-cn.com/eclipsehono/hono-adapter-mqtt-vertx:0.5-M5\n    networks:\n      - hono-net\n    ports:\n      - \"1883:1883\"\n    environment:\n      - HONO_CLIENT_NAME=Hono MQTT Adapter\n      - HONO_CLIENT_HOST=hono\n      - HONO_CLIENT_PORT=5671\n      - HONO_CLIENT_USERNAME=mqtt-adapter\n      - HONO_CLIENT_PASSWORD=secret\n      - HONO_CLIENT_TRUST_STORE_PATH=/etc/hono/certs/trusted-certs.pem\n      - HONO_MQTT_BIND_ADDRESS=0.0.0.0\n      - HONO_MQTT_MAX_INSTANCES=1\n      - SPRING_PROFILES_ACTIVE=dev\n","date":"2020-05-03T06:14:50.681Z","updated":"2020-05-03T06:14:50.681Z","path":"artifacts/hono-docker-compose.json","layout":"false","title":"","comments":1,"_id":"cka27ixqs0005k4r3itub85lp","content":"{\"version\":\"3.0\",\"networks\":{\"hono-net\":{\"driver\":\"overlay\"}},\"services\":{\"qdrouter\":{\"image\":\"registry.docker-cn.com/eclipsehono/dispatch-router:0.5-M5\",\"networks\":[\"hono-net\"],\"command\":\"/usr/sbin/qdrouterd -c /etc/hono/qdrouter/qdrouterd.json\",\"ports\":[\"15671:5671\",\"15672:5672\"]},\"hono\":{\"image\":\"registry.docker-cn.com/eclipsehono/hono-server:0.5-M5\",\"networks\":[\"hono-net\"],\"ports\":[\"5671:5671\"],\"environment\":[\"HONO_DOWNSTREAM_HOST=qdrouter\",\"HONO_DOWNSTREAM_PORT=5673\",\"HONO_DOWNSTREAM_KEY_STORE_PATH=/etc/hono/certs/honoKeyStore.p12\",\"HONO_DOWNSTREAM_KEY_STORE_PASSWORD=honokeys\",\"HONO_DOWNSTREAM_TRUST_STORE_PATH=/etc/hono/certs/trusted-certs.pem\",\"HONO_SERVER_BIND_ADDRESS=0.0.0.0\",\"HONO_SERVER_KEY_STORE_PATH=/etc/hono/certs/honoKeyStore.p12\",\"HONO_SERVER_KEY_STORE_PASSWORD=honokeys\",\"HONO_SERVER_INSECURE_PORT_ENABLED=false\",\"HONO_SERVER_MAX_INSTANCES=1\",\"LOGGING_CONFIG=classpath:logback-spring.xml\",\"SPRING_PROFILES_ACTIVE=default,dev\"],\"volumes\":[\"/home/hono/registration\"]},\"rest-adapter\":{\"image\":\"registry.docker-cn.com/eclipsehono/hono-adapter-rest-vertx:0.5-M5\",\"networks\":[\"hono-net\"],\"ports\":[\"8080:8080\"],\"environment\":[\"HONO_CLIENT_NAME=Hono REST Adapter\",\"HONO_CLIENT_HOST=hono\",\"HONO_CLIENT_PORT=5671\",\"HONO_CLIENT_USERNAME=rest-adapter\",\"HONO_CLIENT_PASSWORD=secret\",\"HONO_CLIENT_TRUST_STORE_PATH=/etc/hono/certs/trusted-certs.pem\",\"HONO_HTTP_BIND_ADDRESS=0.0.0.0\",\"HONO_HTTP_MAX_INSTANCES=1\",\"SPRING_PROFILES_ACTIVE=dev\"]},\"mqtt-adapter\":{\"image\":\"registry.docker-cn.com/eclipsehono/hono-adapter-mqtt-vertx:0.5-M5\",\"networks\":[\"hono-net\"],\"ports\":[\"1883:1883\"],\"environment\":[\"HONO_CLIENT_NAME=Hono MQTT Adapter\",\"HONO_CLIENT_HOST=hono\",\"HONO_CLIENT_PORT=5671\",\"HONO_CLIENT_USERNAME=mqtt-adapter\",\"HONO_CLIENT_PASSWORD=secret\",\"HONO_CLIENT_TRUST_STORE_PATH=/etc/hono/certs/trusted-certs.pem\",\"HONO_MQTT_BIND_ADDRESS=0.0.0.0\",\"HONO_MQTT_MAX_INSTANCES=1\",\"SPRING_PROFILES_ACTIVE=dev\"]}}}","site":{"data":{}},"excerpt":"","more":"{\"version\":\"3.0\",\"networks\":{\"hono-net\":{\"driver\":\"overlay\"}},\"services\":{\"qdrouter\":{\"image\":\"registry.docker-cn.com/eclipsehono/dispatch-router:0.5-M5\",\"networks\":[\"hono-net\"],\"command\":\"/usr/sbin/qdrouterd -c /etc/hono/qdrouter/qdrouterd.json\",\"ports\":[\"15671:5671\",\"15672:5672\"]},\"hono\":{\"image\":\"registry.docker-cn.com/eclipsehono/hono-server:0.5-M5\",\"networks\":[\"hono-net\"],\"ports\":[\"5671:5671\"],\"environment\":[\"HONO_DOWNSTREAM_HOST=qdrouter\",\"HONO_DOWNSTREAM_PORT=5673\",\"HONO_DOWNSTREAM_KEY_STORE_PATH=/etc/hono/certs/honoKeyStore.p12\",\"HONO_DOWNSTREAM_KEY_STORE_PASSWORD=honokeys\",\"HONO_DOWNSTREAM_TRUST_STORE_PATH=/etc/hono/certs/trusted-certs.pem\",\"HONO_SERVER_BIND_ADDRESS=0.0.0.0\",\"HONO_SERVER_KEY_STORE_PATH=/etc/hono/certs/honoKeyStore.p12\",\"HONO_SERVER_KEY_STORE_PASSWORD=honokeys\",\"HONO_SERVER_INSECURE_PORT_ENABLED=false\",\"HONO_SERVER_MAX_INSTANCES=1\",\"LOGGING_CONFIG=classpath:logback-spring.xml\",\"SPRING_PROFILES_ACTIVE=default,dev\"],\"volumes\":[\"/home/hono/registration\"]},\"rest-adapter\":{\"image\":\"registry.docker-cn.com/eclipsehono/hono-adapter-rest-vertx:0.5-M5\",\"networks\":[\"hono-net\"],\"ports\":[\"8080:8080\"],\"environment\":[\"HONO_CLIENT_NAME=Hono REST Adapter\",\"HONO_CLIENT_HOST=hono\",\"HONO_CLIENT_PORT=5671\",\"HONO_CLIENT_USERNAME=rest-adapter\",\"HONO_CLIENT_PASSWORD=secret\",\"HONO_CLIENT_TRUST_STORE_PATH=/etc/hono/certs/trusted-certs.pem\",\"HONO_HTTP_BIND_ADDRESS=0.0.0.0\",\"HONO_HTTP_MAX_INSTANCES=1\",\"SPRING_PROFILES_ACTIVE=dev\"]},\"mqtt-adapter\":{\"image\":\"registry.docker-cn.com/eclipsehono/hono-adapter-mqtt-vertx:0.5-M5\",\"networks\":[\"hono-net\"],\"ports\":[\"1883:1883\"],\"environment\":[\"HONO_CLIENT_NAME=Hono MQTT Adapter\",\"HONO_CLIENT_HOST=hono\",\"HONO_CLIENT_PORT=5671\",\"HONO_CLIENT_USERNAME=mqtt-adapter\",\"HONO_CLIENT_PASSWORD=secret\",\"HONO_CLIENT_TRUST_STORE_PATH=/etc/hono/certs/trusted-certs.pem\",\"HONO_MQTT_BIND_ADDRESS=0.0.0.0\",\"HONO_MQTT_MAX_INSTANCES=1\",\"SPRING_PROFILES_ACTIVE=dev\"]}}}"},{"title":"categories","date":"2017-05-08T14:11:35.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-05-08 22:11:35\ntype: \"categories\"\ncomments: false\n---\n","updated":"2020-05-03T06:14:50.681Z","path":"categories/index.html","layout":"page","_id":"cka27ixqv0007k4r3pycos6eq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-05-08T14:11:46.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-05-08 22:11:46\ntype: \"tags\"\ncomments: false\n---\n","updated":"2020-05-03T06:14:50.715Z","path":"tags/index.html","layout":"page","_id":"cka27ixqx0009k4r32ebe1umd","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"100 Same Tree","date":"2019-11-04T16:10:10.000Z","_content":"## Intuition & Algorithm\nThe question asks whether the structure of the two binary trees and the values of the nodes are the same. This question has a strong reference significance on how to judge whether two objects are equal.\n\nThere are two ideas for the solution. The first one is the recursive method. First, determine whether the root nodes are the same. If they are the same, determine whether the left and right subtrees are the same, which is equivalent to determining whether the root nodes are equal in the depth traversal process. The second idea is to traverse the binary tree in the sequence, store the nodes of the current layer of the two trees in two queues, and determine whether each node is the same in turn. In this process, the left and right child nodes of the node are added to the tail end of the queue. Yes, even if the left and right child nodes are null, you need to join because the two trees may be symmetric structures (see Example 2), and the left and right nodes are not added to the queue until the current node is empty.\n\nThis question is almost identical to the [101 symmetry binary tree](https://leetcode.com/problems/symmetric-tree/) idea, except that in the recursive method, it is judged whether the left sub-tree and the right sub-tree are equal, instead of Determine whether the left subtree and the left subtree are equal. Instead of two queues in the sequence traversal, use one queue and one stack.\n\n## Complexity\n**Time Complexity:** Time complexity for traversing the entire tree  is O(N)\n\n**Space Complexity:** The recursive method depends on the height of the tree, the worst case is O(N), best case is  O(logN); the number of nodes in the sequence traversal depends on the number of nodes, the worst is O(N), best case is O(1)\n> Interestingly, the worst case space complexity in the recursive algorithm is that the binary tree  degenerates to a linked list which resulting in a tree height of O(N), so consumption of function stack is O(N), while the broad fist traversal performs best in this case with space complexity of O(1). The best case of the recursive algorithm is a complete binary tree, in which case the height of the tree is O(logN), when the binary tree is full The number of  last layer nodes is N/2, so the space consumed is O(N).\n\n## Code\n\n```\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        LinkedList<TreeNode> pl = new LinkedList<>();\n        LinkedList<TreeNode> ql = new LinkedList<>();\n        \n        pl.add(p);\n        ql.add(q);\n        while(true){\n            if(pl.size()==0 && ql.size() == 0){\n                return true;\n            }\n            else if(pl.size()==0 || ql.size() == 0)\n            {\n                return false;\n            }\n            //比较队列中的元素，并将下一层结点加入队列\n            int np = pl.size();\n            int nq = ql.size();\n            if(np != nq)return false; //结构不同，一层的节点数量不一样\n            //依次比较每个节点\n            int i = 0;\n            while(i++ < np){\n                TreeNode p1 = pl.removeFirst();\n                TreeNode q1 = ql.removeFirst();\n                if( (p1 == null && q1!=null) || (p1 != null && q1==null) )return false;\n                else if(p1!=null && q1!=null && p1.val != q1.val)return false;\n                if(p1 != null){\n                    pl.add(p1.left);pl.add(p1.right);\n                }\n                if(q1 != null){\n                    ql.add(q1.left);ql.add(q1.right);\n                }\n            }\n        }\n    }\n}\n```\n\n\n","source":"_posts/100-Same-Tree.md","raw":"---\ntitle: 100 Same Tree\ndate: 2019-11-05 00:10:10\ncategories:\n- LeetCode\ntags:\n- binary tree\n---\n## Intuition & Algorithm\nThe question asks whether the structure of the two binary trees and the values of the nodes are the same. This question has a strong reference significance on how to judge whether two objects are equal.\n\nThere are two ideas for the solution. The first one is the recursive method. First, determine whether the root nodes are the same. If they are the same, determine whether the left and right subtrees are the same, which is equivalent to determining whether the root nodes are equal in the depth traversal process. The second idea is to traverse the binary tree in the sequence, store the nodes of the current layer of the two trees in two queues, and determine whether each node is the same in turn. In this process, the left and right child nodes of the node are added to the tail end of the queue. Yes, even if the left and right child nodes are null, you need to join because the two trees may be symmetric structures (see Example 2), and the left and right nodes are not added to the queue until the current node is empty.\n\nThis question is almost identical to the [101 symmetry binary tree](https://leetcode.com/problems/symmetric-tree/) idea, except that in the recursive method, it is judged whether the left sub-tree and the right sub-tree are equal, instead of Determine whether the left subtree and the left subtree are equal. Instead of two queues in the sequence traversal, use one queue and one stack.\n\n## Complexity\n**Time Complexity:** Time complexity for traversing the entire tree  is O(N)\n\n**Space Complexity:** The recursive method depends on the height of the tree, the worst case is O(N), best case is  O(logN); the number of nodes in the sequence traversal depends on the number of nodes, the worst is O(N), best case is O(1)\n> Interestingly, the worst case space complexity in the recursive algorithm is that the binary tree  degenerates to a linked list which resulting in a tree height of O(N), so consumption of function stack is O(N), while the broad fist traversal performs best in this case with space complexity of O(1). The best case of the recursive algorithm is a complete binary tree, in which case the height of the tree is O(logN), when the binary tree is full The number of  last layer nodes is N/2, so the space consumed is O(N).\n\n## Code\n\n```\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        LinkedList<TreeNode> pl = new LinkedList<>();\n        LinkedList<TreeNode> ql = new LinkedList<>();\n        \n        pl.add(p);\n        ql.add(q);\n        while(true){\n            if(pl.size()==0 && ql.size() == 0){\n                return true;\n            }\n            else if(pl.size()==0 || ql.size() == 0)\n            {\n                return false;\n            }\n            //比较队列中的元素，并将下一层结点加入队列\n            int np = pl.size();\n            int nq = ql.size();\n            if(np != nq)return false; //结构不同，一层的节点数量不一样\n            //依次比较每个节点\n            int i = 0;\n            while(i++ < np){\n                TreeNode p1 = pl.removeFirst();\n                TreeNode q1 = ql.removeFirst();\n                if( (p1 == null && q1!=null) || (p1 != null && q1==null) )return false;\n                else if(p1!=null && q1!=null && p1.val != q1.val)return false;\n                if(p1 != null){\n                    pl.add(p1.left);pl.add(p1.right);\n                }\n                if(q1 != null){\n                    ql.add(q1.left);ql.add(q1.right);\n                }\n            }\n        }\n    }\n}\n```\n\n\n","slug":"100-Same-Tree","published":1,"updated":"2020-05-03T06:14:50.669Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixqd0002k4r3bodb3133","content":"<h2 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h2><p>The question asks whether the structure of the two binary trees and the values of the nodes are the same. This question has a strong reference significance on how to judge whether two objects are equal.</p>\n<p>There are two ideas for the solution. The first one is the recursive method. First, determine whether the root nodes are the same. If they are the same, determine whether the left and right subtrees are the same, which is equivalent to determining whether the root nodes are equal in the depth traversal process. The second idea is to traverse the binary tree in the sequence, store the nodes of the current layer of the two trees in two queues, and determine whether each node is the same in turn. In this process, the left and right child nodes of the node are added to the tail end of the queue. Yes, even if the left and right child nodes are null, you need to join because the two trees may be symmetric structures (see Example 2), and the left and right nodes are not added to the queue until the current node is empty.</p>\n<p>This question is almost identical to the <a href=\"https://leetcode.com/problems/symmetric-tree/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">101 symmetry binary tree</a> idea, except that in the recursive method, it is judged whether the left sub-tree and the right sub-tree are equal, instead of Determine whether the left subtree and the left subtree are equal. Instead of two queues in the sequence traversal, use one queue and one stack.</p>\n<h2 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h2><p><strong>Time Complexity:</strong> Time complexity for traversing the entire tree  is O(N)</p>\n<p><strong>Space Complexity:</strong> The recursive method depends on the height of the tree, the worst case is O(N), best case is  O(logN); the number of nodes in the sequence traversal depends on the number of nodes, the worst is O(N), best case is O(1)</p>\n<blockquote>\n<p>Interestingly, the worst case space complexity in the recursive algorithm is that the binary tree  degenerates to a linked list which resulting in a tree height of O(N), so consumption of function stack is O(N), while the broad fist traversal performs best in this case with space complexity of O(1). The best case of the recursive algorithm is a complete binary tree, in which case the height of the tree is O(logN), when the binary tree is full The number of  last layer nodes is N/2, so the space consumed is O(N).</p>\n</blockquote>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for a binary tree node.</span><br><span class=\"line\"> * public class TreeNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     TreeNode left;</span><br><span class=\"line\"> *     TreeNode right;</span><br><span class=\"line\"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class=\"line\">        LinkedList&lt;TreeNode&gt; pl = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        LinkedList&lt;TreeNode&gt; ql = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        pl.add(p);</span><br><span class=\"line\">        ql.add(q);</span><br><span class=\"line\">        while(true)&#123;</span><br><span class=\"line\">            if(pl.size()==0 &amp;&amp; ql.size() == 0)&#123;</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else if(pl.size()==0 || ql.size() == 0)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //比较队列中的元素，并将下一层结点加入队列</span><br><span class=\"line\">            int np = pl.size();</span><br><span class=\"line\">            int nq = ql.size();</span><br><span class=\"line\">            if(np != nq)return false; //结构不同，一层的节点数量不一样</span><br><span class=\"line\">            //依次比较每个节点</span><br><span class=\"line\">            int i = 0;</span><br><span class=\"line\">            while(i++ &lt; np)&#123;</span><br><span class=\"line\">                TreeNode p1 = pl.removeFirst();</span><br><span class=\"line\">                TreeNode q1 = ql.removeFirst();</span><br><span class=\"line\">                if( (p1 == null &amp;&amp; q1!=null) || (p1 != null &amp;&amp; q1==null) )return false;</span><br><span class=\"line\">                else if(p1!=null &amp;&amp; q1!=null &amp;&amp; p1.val != q1.val)return false;</span><br><span class=\"line\">                if(p1 != null)&#123;</span><br><span class=\"line\">                    pl.add(p1.left);pl.add(p1.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if(q1 != null)&#123;</span><br><span class=\"line\">                    ql.add(q1.left);ql.add(q1.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h2><p>The question asks whether the structure of the two binary trees and the values of the nodes are the same. This question has a strong reference significance on how to judge whether two objects are equal.</p>\n<p>There are two ideas for the solution. The first one is the recursive method. First, determine whether the root nodes are the same. If they are the same, determine whether the left and right subtrees are the same, which is equivalent to determining whether the root nodes are equal in the depth traversal process. The second idea is to traverse the binary tree in the sequence, store the nodes of the current layer of the two trees in two queues, and determine whether each node is the same in turn. In this process, the left and right child nodes of the node are added to the tail end of the queue. Yes, even if the left and right child nodes are null, you need to join because the two trees may be symmetric structures (see Example 2), and the left and right nodes are not added to the queue until the current node is empty.</p>\n<p>This question is almost identical to the <a href=\"https://leetcode.com/problems/symmetric-tree/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">101 symmetry binary tree</a> idea, except that in the recursive method, it is judged whether the left sub-tree and the right sub-tree are equal, instead of Determine whether the left subtree and the left subtree are equal. Instead of two queues in the sequence traversal, use one queue and one stack.</p>\n<h2 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h2><p><strong>Time Complexity:</strong> Time complexity for traversing the entire tree  is O(N)</p>\n<p><strong>Space Complexity:</strong> The recursive method depends on the height of the tree, the worst case is O(N), best case is  O(logN); the number of nodes in the sequence traversal depends on the number of nodes, the worst is O(N), best case is O(1)</p>\n<blockquote>\n<p>Interestingly, the worst case space complexity in the recursive algorithm is that the binary tree  degenerates to a linked list which resulting in a tree height of O(N), so consumption of function stack is O(N), while the broad fist traversal performs best in this case with space complexity of O(1). The best case of the recursive algorithm is a complete binary tree, in which case the height of the tree is O(logN), when the binary tree is full The number of  last layer nodes is N/2, so the space consumed is O(N).</p>\n</blockquote>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for a binary tree node.</span><br><span class=\"line\"> * public class TreeNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     TreeNode left;</span><br><span class=\"line\"> *     TreeNode right;</span><br><span class=\"line\"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class=\"line\">        LinkedList&lt;TreeNode&gt; pl = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        LinkedList&lt;TreeNode&gt; ql = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        pl.add(p);</span><br><span class=\"line\">        ql.add(q);</span><br><span class=\"line\">        while(true)&#123;</span><br><span class=\"line\">            if(pl.size()==0 &amp;&amp; ql.size() == 0)&#123;</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else if(pl.size()==0 || ql.size() == 0)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //比较队列中的元素，并将下一层结点加入队列</span><br><span class=\"line\">            int np = pl.size();</span><br><span class=\"line\">            int nq = ql.size();</span><br><span class=\"line\">            if(np != nq)return false; //结构不同，一层的节点数量不一样</span><br><span class=\"line\">            //依次比较每个节点</span><br><span class=\"line\">            int i = 0;</span><br><span class=\"line\">            while(i++ &lt; np)&#123;</span><br><span class=\"line\">                TreeNode p1 = pl.removeFirst();</span><br><span class=\"line\">                TreeNode q1 = ql.removeFirst();</span><br><span class=\"line\">                if( (p1 == null &amp;&amp; q1!=null) || (p1 != null &amp;&amp; q1==null) )return false;</span><br><span class=\"line\">                else if(p1!=null &amp;&amp; q1!=null &amp;&amp; p1.val != q1.val)return false;</span><br><span class=\"line\">                if(p1 != null)&#123;</span><br><span class=\"line\">                    pl.add(p1.left);pl.add(p1.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if(q1 != null)&#123;</span><br><span class=\"line\">                    ql.add(q1.left);ql.add(q1.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"121 Best Time to Buy and Sell Stock","date":"2019-11-08T16:10:58.000Z","_content":"# Intuition\nThe broute-force solution is listing all the possible combinations and finding the maximum one:\n\n$$\nmax(a[j] - a[i]) \\quad j>=i\n$$\n\nTime complexity for this algorithm is $O(n^2)$. We have linear solution actually, which is not that intuitive. Before talking about the linear solution, let's see the `Largest Sum Contiguous Subarray` problem.\n\n###### Largest Sum Contiguous Subarray\n\n> Write an efficient program to find the sum of contiguous subarray within a one-dimensional array of numbers which has the largest sum.\n\n![image](https://media.geeksforgeeks.org/wp-content/cdn-uploads/kadane-Algorithm.png)\n\nThe intuitive method for this question is dynamic programming too, but we have more efficient algorithm: Kadane's Algorithm.\n\nKadane's Algorithm keep track of positive sum contiguous subarray, and keep recording a maximum sum among them. For the above array, we have:\n```\n0:\nmax_segment: -2\nmax_so_far: -2\n\n1:\nmax_segment: -3\nmax_so_far: -2\n\n2:\nmax_segment: 4\nmax_so_far: 4\n\n3:\nmax_segment: 3\nmax_so_far: 4\n\n4:\nmax_segment: 1\nmax_so_far: 4\n\n5:\nmax_segment: 2\nmax_so_far: 4\n\n6:\nmax_segment: 7\nmax_so_far: 7\n\n7:\nmax_segment: 4\nmax_so_far: 7\n```\nIf the addition of previous segment and current element is positive, we compare the sum with the `max_so_far` and  update previous segment to the addition.\n\n# Algorithm\nOur goal is to find $max(a[j]-a[i])$, let's rewrite this formula to\n\n$$max(a[j]-a[j-1] + a[j-1]-a[j-2] +...+  a[i+1]-a[i])$$\n\nThe original question becomes a `Largest Sum Contiguous Subarray` question! We can get the largest sum within a linear time.\n\n# Code\n```\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int max_so_far = 0;\n        int max_temp = 0;\n        for(int i = 1; i < prices.length; i++){\n            int price = prices[i] - prices[i-1];\n            if(max_temp + price < 0){\n                max_temp = 0;\n            }\n            else{\n                max_temp += price;\n                max_so_far = Math.max(max_so_far, max_temp);\n            }\n        }\n        return max_so_far;\n    }\n}\n```\n\n# Complexity\n**Time Complexity:** $O(n)$\n**Space Complexity:** $O(1)$\n","source":"_posts/121-Best-Time-to-Buy-and-Sell-Stock.md","raw":"---\ntitle: 121 Best Time to Buy and Sell Stock\ndate: 2019-11-09 00:10:58\ncategories:\n- LeetCode\ntags:\n- Kanade's Algorithm\n- Subarray\n---\n# Intuition\nThe broute-force solution is listing all the possible combinations and finding the maximum one:\n\n$$\nmax(a[j] - a[i]) \\quad j>=i\n$$\n\nTime complexity for this algorithm is $O(n^2)$. We have linear solution actually, which is not that intuitive. Before talking about the linear solution, let's see the `Largest Sum Contiguous Subarray` problem.\n\n###### Largest Sum Contiguous Subarray\n\n> Write an efficient program to find the sum of contiguous subarray within a one-dimensional array of numbers which has the largest sum.\n\n![image](https://media.geeksforgeeks.org/wp-content/cdn-uploads/kadane-Algorithm.png)\n\nThe intuitive method for this question is dynamic programming too, but we have more efficient algorithm: Kadane's Algorithm.\n\nKadane's Algorithm keep track of positive sum contiguous subarray, and keep recording a maximum sum among them. For the above array, we have:\n```\n0:\nmax_segment: -2\nmax_so_far: -2\n\n1:\nmax_segment: -3\nmax_so_far: -2\n\n2:\nmax_segment: 4\nmax_so_far: 4\n\n3:\nmax_segment: 3\nmax_so_far: 4\n\n4:\nmax_segment: 1\nmax_so_far: 4\n\n5:\nmax_segment: 2\nmax_so_far: 4\n\n6:\nmax_segment: 7\nmax_so_far: 7\n\n7:\nmax_segment: 4\nmax_so_far: 7\n```\nIf the addition of previous segment and current element is positive, we compare the sum with the `max_so_far` and  update previous segment to the addition.\n\n# Algorithm\nOur goal is to find $max(a[j]-a[i])$, let's rewrite this formula to\n\n$$max(a[j]-a[j-1] + a[j-1]-a[j-2] +...+  a[i+1]-a[i])$$\n\nThe original question becomes a `Largest Sum Contiguous Subarray` question! We can get the largest sum within a linear time.\n\n# Code\n```\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int max_so_far = 0;\n        int max_temp = 0;\n        for(int i = 1; i < prices.length; i++){\n            int price = prices[i] - prices[i-1];\n            if(max_temp + price < 0){\n                max_temp = 0;\n            }\n            else{\n                max_temp += price;\n                max_so_far = Math.max(max_so_far, max_temp);\n            }\n        }\n        return max_so_far;\n    }\n}\n```\n\n# Complexity\n**Time Complexity:** $O(n)$\n**Space Complexity:** $O(1)$\n","slug":"121-Best-Time-to-Buy-and-Sell-Stock","published":1,"updated":"2020-05-03T06:14:50.670Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixqq0004k4r38vhkon4w","content":"<h1 id=\"Intuition\"><a href=\"#Intuition\" class=\"headerlink\" title=\"Intuition\"></a>Intuition</h1><p>The broute-force solution is listing all the possible combinations and finding the maximum one:</p>\n<script type=\"math/tex; mode=display\">\nmax(a[j] - a[i]) \\quad j>=i</script><p>Time complexity for this algorithm is $O(n^2)$. We have linear solution actually, which is not that intuitive. Before talking about the linear solution, let’s see the <code>Largest Sum Contiguous Subarray</code> problem.</p>\n<h6 id=\"Largest-Sum-Contiguous-Subarray\"><a href=\"#Largest-Sum-Contiguous-Subarray\" class=\"headerlink\" title=\"Largest Sum Contiguous Subarray\"></a>Largest Sum Contiguous Subarray</h6><blockquote>\n<p>Write an efficient program to find the sum of contiguous subarray within a one-dimensional array of numbers which has the largest sum.</p>\n</blockquote>\n<p><img src=\"https://media.geeksforgeeks.org/wp-content/cdn-uploads/kadane-Algorithm.png\" alt=\"image\"></p>\n<p>The intuitive method for this question is dynamic programming too, but we have more efficient algorithm: Kadane’s Algorithm.</p>\n<p>Kadane’s Algorithm keep track of positive sum contiguous subarray, and keep recording a maximum sum among them. For the above array, we have:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0:</span><br><span class=\"line\">max_segment: -2</span><br><span class=\"line\">max_so_far: -2</span><br><span class=\"line\"></span><br><span class=\"line\">1:</span><br><span class=\"line\">max_segment: -3</span><br><span class=\"line\">max_so_far: -2</span><br><span class=\"line\"></span><br><span class=\"line\">2:</span><br><span class=\"line\">max_segment: 4</span><br><span class=\"line\">max_so_far: 4</span><br><span class=\"line\"></span><br><span class=\"line\">3:</span><br><span class=\"line\">max_segment: 3</span><br><span class=\"line\">max_so_far: 4</span><br><span class=\"line\"></span><br><span class=\"line\">4:</span><br><span class=\"line\">max_segment: 1</span><br><span class=\"line\">max_so_far: 4</span><br><span class=\"line\"></span><br><span class=\"line\">5:</span><br><span class=\"line\">max_segment: 2</span><br><span class=\"line\">max_so_far: 4</span><br><span class=\"line\"></span><br><span class=\"line\">6:</span><br><span class=\"line\">max_segment: 7</span><br><span class=\"line\">max_so_far: 7</span><br><span class=\"line\"></span><br><span class=\"line\">7:</span><br><span class=\"line\">max_segment: 4</span><br><span class=\"line\">max_so_far: 7</span><br></pre></td></tr></table></figure></p>\n<p>If the addition of previous segment and current element is positive, we compare the sum with the <code>max_so_far</code> and  update previous segment to the addition.</p>\n<h1 id=\"Algorithm\"><a href=\"#Algorithm\" class=\"headerlink\" title=\"Algorithm\"></a>Algorithm</h1><p>Our goal is to find $max(a[j]-a[i])$, let’s rewrite this formula to</p>\n<script type=\"math/tex; mode=display\">max(a[j]-a[j-1] + a[j-1]-a[j-2] +...+  a[i+1]-a[i])</script><p>The original question becomes a <code>Largest Sum Contiguous Subarray</code> question! We can get the largest sum within a linear time.</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int maxProfit(int[] prices) &#123;</span><br><span class=\"line\">        int max_so_far = 0;</span><br><span class=\"line\">        int max_temp = 0;</span><br><span class=\"line\">        for(int i = 1; i &lt; prices.length; i++)&#123;</span><br><span class=\"line\">            int price = prices[i] - prices[i-1];</span><br><span class=\"line\">            if(max_temp + price &lt; 0)&#123;</span><br><span class=\"line\">                max_temp = 0;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else&#123;</span><br><span class=\"line\">                max_temp += price;</span><br><span class=\"line\">                max_so_far = Math.max(max_so_far, max_temp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return max_so_far;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(n)$<br><strong>Space Complexity:</strong> $O(1)$</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition\"><a href=\"#Intuition\" class=\"headerlink\" title=\"Intuition\"></a>Intuition</h1><p>The broute-force solution is listing all the possible combinations and finding the maximum one:</p>\n<script type=\"math/tex; mode=display\">\nmax(a[j] - a[i]) \\quad j>=i</script><p>Time complexity for this algorithm is $O(n^2)$. We have linear solution actually, which is not that intuitive. Before talking about the linear solution, let’s see the <code>Largest Sum Contiguous Subarray</code> problem.</p>\n<h6 id=\"Largest-Sum-Contiguous-Subarray\"><a href=\"#Largest-Sum-Contiguous-Subarray\" class=\"headerlink\" title=\"Largest Sum Contiguous Subarray\"></a>Largest Sum Contiguous Subarray</h6><blockquote>\n<p>Write an efficient program to find the sum of contiguous subarray within a one-dimensional array of numbers which has the largest sum.</p>\n</blockquote>\n<p><img src=\"https://media.geeksforgeeks.org/wp-content/cdn-uploads/kadane-Algorithm.png\" alt=\"image\"></p>\n<p>The intuitive method for this question is dynamic programming too, but we have more efficient algorithm: Kadane’s Algorithm.</p>\n<p>Kadane’s Algorithm keep track of positive sum contiguous subarray, and keep recording a maximum sum among them. For the above array, we have:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0:</span><br><span class=\"line\">max_segment: -2</span><br><span class=\"line\">max_so_far: -2</span><br><span class=\"line\"></span><br><span class=\"line\">1:</span><br><span class=\"line\">max_segment: -3</span><br><span class=\"line\">max_so_far: -2</span><br><span class=\"line\"></span><br><span class=\"line\">2:</span><br><span class=\"line\">max_segment: 4</span><br><span class=\"line\">max_so_far: 4</span><br><span class=\"line\"></span><br><span class=\"line\">3:</span><br><span class=\"line\">max_segment: 3</span><br><span class=\"line\">max_so_far: 4</span><br><span class=\"line\"></span><br><span class=\"line\">4:</span><br><span class=\"line\">max_segment: 1</span><br><span class=\"line\">max_so_far: 4</span><br><span class=\"line\"></span><br><span class=\"line\">5:</span><br><span class=\"line\">max_segment: 2</span><br><span class=\"line\">max_so_far: 4</span><br><span class=\"line\"></span><br><span class=\"line\">6:</span><br><span class=\"line\">max_segment: 7</span><br><span class=\"line\">max_so_far: 7</span><br><span class=\"line\"></span><br><span class=\"line\">7:</span><br><span class=\"line\">max_segment: 4</span><br><span class=\"line\">max_so_far: 7</span><br></pre></td></tr></table></figure></p>\n<p>If the addition of previous segment and current element is positive, we compare the sum with the <code>max_so_far</code> and  update previous segment to the addition.</p>\n<h1 id=\"Algorithm\"><a href=\"#Algorithm\" class=\"headerlink\" title=\"Algorithm\"></a>Algorithm</h1><p>Our goal is to find $max(a[j]-a[i])$, let’s rewrite this formula to</p>\n<script type=\"math/tex; mode=display\">max(a[j]-a[j-1] + a[j-1]-a[j-2] +...+  a[i+1]-a[i])</script><p>The original question becomes a <code>Largest Sum Contiguous Subarray</code> question! We can get the largest sum within a linear time.</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int maxProfit(int[] prices) &#123;</span><br><span class=\"line\">        int max_so_far = 0;</span><br><span class=\"line\">        int max_temp = 0;</span><br><span class=\"line\">        for(int i = 1; i &lt; prices.length; i++)&#123;</span><br><span class=\"line\">            int price = prices[i] - prices[i-1];</span><br><span class=\"line\">            if(max_temp + price &lt; 0)&#123;</span><br><span class=\"line\">                max_temp = 0;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else&#123;</span><br><span class=\"line\">                max_temp += price;</span><br><span class=\"line\">                max_so_far = Math.max(max_so_far, max_temp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return max_so_far;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(n)$<br><strong>Space Complexity:</strong> $O(1)$</p>\n"},{"title":"147 Insertion Sort List","date":"2019-11-10T12:50:18.000Z","_content":"# Intuition & Algorithm\nThe diagram and illustration in the question have given us a clear description of insertion sort algorithm.\n1. Separate the list into two parts: `sorted` and `sorting`\n2. Insert the head of `sorting` list into the sorted list\n\nWe should consider three cases during insertion(v is the node to be inserted):\n- `v < sorted.head.val` we should use this node as the new head of sorted list\n- `cur.val < v < cur.next.val` `cur` is a node in the sorted list, in this case we should insert the new node between `cur` and `cur.next`\n- `cur.next == null` this means `v` is large than any number in the list, so we append it to the tail.\n\n\n# Code\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode insertionSortList(ListNode head) {\n        if(head == null)return head;\n        ListNode sorted=head,sorting = head.next, next;\n        head.next = null;\n        while(sorting != null){\n            next = sorting.next;\n            \n            ListNode cur = sorted;\n            if(sorting.val < cur.val){\n                sorting.next = sorted;\n                sorted = sorting;\n            }\n            else{\n                while(cur.next != null){\n                    if(sorting.val >= cur.val && sorting.val <= cur.next.val)\n                    {\n                        sorting.next = cur.next;\n                        cur.next = sorting;\n                        break;\n                    }\n                    cur = cur.next;\n                }\n                if(cur.next == null){\n                    sorting.next = null;\n                    cur.next = sorting;\n                }\n            }\n            sorting = next;\n        }\n        return sorted;\n    }\n}\n```\n\n# Complexity\n**Time Complexity:** $O(n)$\n\n**Spatial Complexity:** $O(1)$\n","source":"_posts/147-Insertion-Sort-List.md","raw":"---\ntitle: 147 Insertion Sort List\ndate: 2019-11-10 20:50:18\ncategories:\n- LeetCode\ntags:\n- list\n- pointer\n---\n# Intuition & Algorithm\nThe diagram and illustration in the question have given us a clear description of insertion sort algorithm.\n1. Separate the list into two parts: `sorted` and `sorting`\n2. Insert the head of `sorting` list into the sorted list\n\nWe should consider three cases during insertion(v is the node to be inserted):\n- `v < sorted.head.val` we should use this node as the new head of sorted list\n- `cur.val < v < cur.next.val` `cur` is a node in the sorted list, in this case we should insert the new node between `cur` and `cur.next`\n- `cur.next == null` this means `v` is large than any number in the list, so we append it to the tail.\n\n\n# Code\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode insertionSortList(ListNode head) {\n        if(head == null)return head;\n        ListNode sorted=head,sorting = head.next, next;\n        head.next = null;\n        while(sorting != null){\n            next = sorting.next;\n            \n            ListNode cur = sorted;\n            if(sorting.val < cur.val){\n                sorting.next = sorted;\n                sorted = sorting;\n            }\n            else{\n                while(cur.next != null){\n                    if(sorting.val >= cur.val && sorting.val <= cur.next.val)\n                    {\n                        sorting.next = cur.next;\n                        cur.next = sorting;\n                        break;\n                    }\n                    cur = cur.next;\n                }\n                if(cur.next == null){\n                    sorting.next = null;\n                    cur.next = sorting;\n                }\n            }\n            sorting = next;\n        }\n        return sorted;\n    }\n}\n```\n\n# Complexity\n**Time Complexity:** $O(n)$\n\n**Spatial Complexity:** $O(1)$\n","slug":"147-Insertion-Sort-List","published":1,"updated":"2020-05-03T06:14:50.671Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixqt0006k4r363v5rwqh","content":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>The diagram and illustration in the question have given us a clear description of insertion sort algorithm.</p>\n<ol>\n<li>Separate the list into two parts: <code>sorted</code> and <code>sorting</code></li>\n<li>Insert the head of <code>sorting</code> list into the sorted list</li>\n</ol>\n<p>We should consider three cases during insertion(v is the node to be inserted):</p>\n<ul>\n<li><code>v &lt; sorted.head.val</code> we should use this node as the new head of sorted list</li>\n<li><code>cur.val &lt; v &lt; cur.next.val</code> <code>cur</code> is a node in the sorted list, in this case we should insert the new node between <code>cur</code> and <code>cur.next</code></li>\n<li><code>cur.next == null</code> this means <code>v</code> is large than any number in the list, so we append it to the tail.</li>\n</ul>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode insertionSortList(ListNode head) &#123;</span><br><span class=\"line\">        if(head == null)return head;</span><br><span class=\"line\">        ListNode sorted=head,sorting = head.next, next;</span><br><span class=\"line\">        head.next = null;</span><br><span class=\"line\">        while(sorting != null)&#123;</span><br><span class=\"line\">            next = sorting.next;</span><br><span class=\"line\">            </span><br><span class=\"line\">            ListNode cur = sorted;</span><br><span class=\"line\">            if(sorting.val &lt; cur.val)&#123;</span><br><span class=\"line\">                sorting.next = sorted;</span><br><span class=\"line\">                sorted = sorting;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else&#123;</span><br><span class=\"line\">                while(cur.next != null)&#123;</span><br><span class=\"line\">                    if(sorting.val &gt;= cur.val &amp;&amp; sorting.val &lt;= cur.next.val)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        sorting.next = cur.next;</span><br><span class=\"line\">                        cur.next = sorting;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    cur = cur.next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if(cur.next == null)&#123;</span><br><span class=\"line\">                    sorting.next = null;</span><br><span class=\"line\">                    cur.next = sorting;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sorting = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return sorted;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(n)$</p>\n<p><strong>Spatial Complexity:</strong> $O(1)$</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>The diagram and illustration in the question have given us a clear description of insertion sort algorithm.</p>\n<ol>\n<li>Separate the list into two parts: <code>sorted</code> and <code>sorting</code></li>\n<li>Insert the head of <code>sorting</code> list into the sorted list</li>\n</ol>\n<p>We should consider three cases during insertion(v is the node to be inserted):</p>\n<ul>\n<li><code>v &lt; sorted.head.val</code> we should use this node as the new head of sorted list</li>\n<li><code>cur.val &lt; v &lt; cur.next.val</code> <code>cur</code> is a node in the sorted list, in this case we should insert the new node between <code>cur</code> and <code>cur.next</code></li>\n<li><code>cur.next == null</code> this means <code>v</code> is large than any number in the list, so we append it to the tail.</li>\n</ul>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode insertionSortList(ListNode head) &#123;</span><br><span class=\"line\">        if(head == null)return head;</span><br><span class=\"line\">        ListNode sorted=head,sorting = head.next, next;</span><br><span class=\"line\">        head.next = null;</span><br><span class=\"line\">        while(sorting != null)&#123;</span><br><span class=\"line\">            next = sorting.next;</span><br><span class=\"line\">            </span><br><span class=\"line\">            ListNode cur = sorted;</span><br><span class=\"line\">            if(sorting.val &lt; cur.val)&#123;</span><br><span class=\"line\">                sorting.next = sorted;</span><br><span class=\"line\">                sorted = sorting;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else&#123;</span><br><span class=\"line\">                while(cur.next != null)&#123;</span><br><span class=\"line\">                    if(sorting.val &gt;= cur.val &amp;&amp; sorting.val &lt;= cur.next.val)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        sorting.next = cur.next;</span><br><span class=\"line\">                        cur.next = sorting;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    cur = cur.next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if(cur.next == null)&#123;</span><br><span class=\"line\">                    sorting.next = null;</span><br><span class=\"line\">                    cur.next = sorting;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sorting = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return sorted;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(n)$</p>\n<p><strong>Spatial Complexity:</strong> $O(1)$</p>\n"},{"title":"143 Reorder List","date":"2019-11-07T16:34:08.000Z","_content":"# Intuition\nFrom the description of this question, we need three steps to achieve the `reorder` operation for a singly linked list:\n1. seperate the list into two parts\n2. reverse the right part\n3. merge the left part and reversed right part one by one\n\n# Algorithm\n###### 1. seperate the list into two parts\nA stright and simple method is counting the node number and find the middle one. This will cost ***O(n)*** time.\n###### 2. reverse the right part\nThere are two methods for reversing the list, *recursion* and *pointers*. We are all familiar with the prons and cons of recursion. It's easy to be implemented and understood, but the size of the list are limited by the size of stack frame. The time complexity for reversing a list is still ***O(n)***.\n> To be honest, I can't resist the temptation of recursion, it's brief and concise. Sometimes recursion is like a magic, we suppose it works for some case and then deduce the relationship between the past and the future, finally we solved the whole problem, it's always a little unrealistic. We can call this method mathematical induction. Maybe when quantum computer comes out, this method will not be limited by the problem size and can be first choice of different solutions.\n\n###### 3. merge the left part and reversed right part one by one\nWe just combine two list one by one, for example `1->2->3` and `5->4` will be `1-> 5 ->2-> 4 ->3` after merge. Time complexity is still ***O(n)***.\n\n# Code\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private ListNode ansHead; \n    public void reorderList(ListNode head) {\n        int length = 0;\n        ListNode temp = head, newHead = head, pre = head;\n        while(temp!=null){\n            length++;\n            temp= temp.next;\n        }\n        if(length < 3)return ;\n        int mid = (length >> 1)  + 1;\n        for(int i = 1; i <= mid; i++){\n            pre = newHead;\n            newHead = newHead.next;            \n        }\n        pre.next = null;\n        reverse(newHead);\n        merge(head, ansHead);\n    }\n    \n    public ListNode reverse(ListNode head){\n        if(head.next == null)\n        {\n            this.ansHead = head;\n            return head;\n        }\n        ListNode next = inverse(head.next);\n        next.next = head;\n        head.next = null;\n        return head;\n    }\n    /*\n    //This function reverse a list by pointers, it cost a constant space\n     public ListNode reverse(ListNode head){\n        ListNode pre = null, cur = head, next = head;\n        while(cur.next != null){\n            next = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = next;\n        }\n        cur.next = pre;\n        ansHead = cur;\n        return cur;\n    }\n    */\n    public void merge(ListNode head1, ListNode head2){\n        while(head2 != null){\n            ListNode next= head2.next;\n            head2.next = head1.next;\n            head1.next = head2;\n            head1 = head2.next;\n            head2 = next;\n        }\n    }\n\n}\n\n```\n\n# Comlexity\n***Time Complexity:*** O(n), see analysis above.\n\n***Space Complexity:*** We cost a constant space O(1) if using *pointer* method to reverse a list, other wise it's O(n)\n\n","source":"_posts/143-Reorder-List.md","raw":"---\ntitle: 143 Reorder List\ndate: 2019-11-08 00:34:08\ncategories:\n- LeetCode\ntags:\n- list\n- recursion\n- pointer\n---\n# Intuition\nFrom the description of this question, we need three steps to achieve the `reorder` operation for a singly linked list:\n1. seperate the list into two parts\n2. reverse the right part\n3. merge the left part and reversed right part one by one\n\n# Algorithm\n###### 1. seperate the list into two parts\nA stright and simple method is counting the node number and find the middle one. This will cost ***O(n)*** time.\n###### 2. reverse the right part\nThere are two methods for reversing the list, *recursion* and *pointers*. We are all familiar with the prons and cons of recursion. It's easy to be implemented and understood, but the size of the list are limited by the size of stack frame. The time complexity for reversing a list is still ***O(n)***.\n> To be honest, I can't resist the temptation of recursion, it's brief and concise. Sometimes recursion is like a magic, we suppose it works for some case and then deduce the relationship between the past and the future, finally we solved the whole problem, it's always a little unrealistic. We can call this method mathematical induction. Maybe when quantum computer comes out, this method will not be limited by the problem size and can be first choice of different solutions.\n\n###### 3. merge the left part and reversed right part one by one\nWe just combine two list one by one, for example `1->2->3` and `5->4` will be `1-> 5 ->2-> 4 ->3` after merge. Time complexity is still ***O(n)***.\n\n# Code\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private ListNode ansHead; \n    public void reorderList(ListNode head) {\n        int length = 0;\n        ListNode temp = head, newHead = head, pre = head;\n        while(temp!=null){\n            length++;\n            temp= temp.next;\n        }\n        if(length < 3)return ;\n        int mid = (length >> 1)  + 1;\n        for(int i = 1; i <= mid; i++){\n            pre = newHead;\n            newHead = newHead.next;            \n        }\n        pre.next = null;\n        reverse(newHead);\n        merge(head, ansHead);\n    }\n    \n    public ListNode reverse(ListNode head){\n        if(head.next == null)\n        {\n            this.ansHead = head;\n            return head;\n        }\n        ListNode next = inverse(head.next);\n        next.next = head;\n        head.next = null;\n        return head;\n    }\n    /*\n    //This function reverse a list by pointers, it cost a constant space\n     public ListNode reverse(ListNode head){\n        ListNode pre = null, cur = head, next = head;\n        while(cur.next != null){\n            next = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = next;\n        }\n        cur.next = pre;\n        ansHead = cur;\n        return cur;\n    }\n    */\n    public void merge(ListNode head1, ListNode head2){\n        while(head2 != null){\n            ListNode next= head2.next;\n            head2.next = head1.next;\n            head1.next = head2;\n            head1 = head2.next;\n            head2 = next;\n        }\n    }\n\n}\n\n```\n\n# Comlexity\n***Time Complexity:*** O(n), see analysis above.\n\n***Space Complexity:*** We cost a constant space O(1) if using *pointer* method to reverse a list, other wise it's O(n)\n\n","slug":"143-Reorder-List","published":1,"updated":"2020-05-03T06:14:50.670Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixqv0008k4r3yixpktnt","content":"<h1 id=\"Intuition\"><a href=\"#Intuition\" class=\"headerlink\" title=\"Intuition\"></a>Intuition</h1><p>From the description of this question, we need three steps to achieve the <code>reorder</code> operation for a singly linked list:</p>\n<ol>\n<li>seperate the list into two parts</li>\n<li>reverse the right part</li>\n<li>merge the left part and reversed right part one by one</li>\n</ol>\n<h1 id=\"Algorithm\"><a href=\"#Algorithm\" class=\"headerlink\" title=\"Algorithm\"></a>Algorithm</h1><h6 id=\"1-seperate-the-list-into-two-parts\"><a href=\"#1-seperate-the-list-into-two-parts\" class=\"headerlink\" title=\"1. seperate the list into two parts\"></a>1. seperate the list into two parts</h6><p>A stright and simple method is counting the node number and find the middle one. This will cost <strong><em>O(n)</em></strong> time.</p>\n<h6 id=\"2-reverse-the-right-part\"><a href=\"#2-reverse-the-right-part\" class=\"headerlink\" title=\"2. reverse the right part\"></a>2. reverse the right part</h6><p>There are two methods for reversing the list, <em>recursion</em> and <em>pointers</em>. We are all familiar with the prons and cons of recursion. It’s easy to be implemented and understood, but the size of the list are limited by the size of stack frame. The time complexity for reversing a list is still <strong><em>O(n)</em></strong>.</p>\n<blockquote>\n<p>To be honest, I can’t resist the temptation of recursion, it’s brief and concise. Sometimes recursion is like a magic, we suppose it works for some case and then deduce the relationship between the past and the future, finally we solved the whole problem, it’s always a little unrealistic. We can call this method mathematical induction. Maybe when quantum computer comes out, this method will not be limited by the problem size and can be first choice of different solutions.</p>\n</blockquote>\n<h6 id=\"3-merge-the-left-part-and-reversed-right-part-one-by-one\"><a href=\"#3-merge-the-left-part-and-reversed-right-part-one-by-one\" class=\"headerlink\" title=\"3. merge the left part and reversed right part one by one\"></a>3. merge the left part and reversed right part one by one</h6><p>We just combine two list one by one, for example <code>1-&gt;2-&gt;3</code> and <code>5-&gt;4</code> will be <code>1-&gt; 5 -&gt;2-&gt; 4 -&gt;3</code> after merge. Time complexity is still <strong><em>O(n)</em></strong>.</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    private ListNode ansHead; </span><br><span class=\"line\">    public void reorderList(ListNode head) &#123;</span><br><span class=\"line\">        int length = 0;</span><br><span class=\"line\">        ListNode temp = head, newHead = head, pre = head;</span><br><span class=\"line\">        while(temp!=null)&#123;</span><br><span class=\"line\">            length++;</span><br><span class=\"line\">            temp= temp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(length &lt; 3)return ;</span><br><span class=\"line\">        int mid = (length &gt;&gt; 1)  + 1;</span><br><span class=\"line\">        for(int i = 1; i &lt;= mid; i++)&#123;</span><br><span class=\"line\">            pre = newHead;</span><br><span class=\"line\">            newHead = newHead.next;            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre.next = null;</span><br><span class=\"line\">        reverse(newHead);</span><br><span class=\"line\">        merge(head, ansHead);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public ListNode reverse(ListNode head)&#123;</span><br><span class=\"line\">        if(head.next == null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            this.ansHead = head;</span><br><span class=\"line\">            return head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode next = inverse(head.next);</span><br><span class=\"line\">        next.next = head;</span><br><span class=\"line\">        head.next = null;</span><br><span class=\"line\">        return head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /*</span><br><span class=\"line\">    //This function reverse a list by pointers, it cost a constant space</span><br><span class=\"line\">     public ListNode reverse(ListNode head)&#123;</span><br><span class=\"line\">        ListNode pre = null, cur = head, next = head;</span><br><span class=\"line\">        while(cur.next != null)&#123;</span><br><span class=\"line\">            next = cur.next;</span><br><span class=\"line\">            cur.next = pre;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur.next = pre;</span><br><span class=\"line\">        ansHead = cur;</span><br><span class=\"line\">        return cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    */</span><br><span class=\"line\">    public void merge(ListNode head1, ListNode head2)&#123;</span><br><span class=\"line\">        while(head2 != null)&#123;</span><br><span class=\"line\">            ListNode next= head2.next;</span><br><span class=\"line\">            head2.next = head1.next;</span><br><span class=\"line\">            head1.next = head2;</span><br><span class=\"line\">            head1 = head2.next;</span><br><span class=\"line\">            head2 = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Comlexity\"><a href=\"#Comlexity\" class=\"headerlink\" title=\"Comlexity\"></a>Comlexity</h1><p><strong><em>Time Complexity:</em></strong> O(n), see analysis above.</p>\n<p><strong><em>Space Complexity:</em></strong> We cost a constant space O(1) if using <em>pointer</em> method to reverse a list, other wise it’s O(n)</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition\"><a href=\"#Intuition\" class=\"headerlink\" title=\"Intuition\"></a>Intuition</h1><p>From the description of this question, we need three steps to achieve the <code>reorder</code> operation for a singly linked list:</p>\n<ol>\n<li>seperate the list into two parts</li>\n<li>reverse the right part</li>\n<li>merge the left part and reversed right part one by one</li>\n</ol>\n<h1 id=\"Algorithm\"><a href=\"#Algorithm\" class=\"headerlink\" title=\"Algorithm\"></a>Algorithm</h1><h6 id=\"1-seperate-the-list-into-two-parts\"><a href=\"#1-seperate-the-list-into-two-parts\" class=\"headerlink\" title=\"1. seperate the list into two parts\"></a>1. seperate the list into two parts</h6><p>A stright and simple method is counting the node number and find the middle one. This will cost <strong><em>O(n)</em></strong> time.</p>\n<h6 id=\"2-reverse-the-right-part\"><a href=\"#2-reverse-the-right-part\" class=\"headerlink\" title=\"2. reverse the right part\"></a>2. reverse the right part</h6><p>There are two methods for reversing the list, <em>recursion</em> and <em>pointers</em>. We are all familiar with the prons and cons of recursion. It’s easy to be implemented and understood, but the size of the list are limited by the size of stack frame. The time complexity for reversing a list is still <strong><em>O(n)</em></strong>.</p>\n<blockquote>\n<p>To be honest, I can’t resist the temptation of recursion, it’s brief and concise. Sometimes recursion is like a magic, we suppose it works for some case and then deduce the relationship between the past and the future, finally we solved the whole problem, it’s always a little unrealistic. We can call this method mathematical induction. Maybe when quantum computer comes out, this method will not be limited by the problem size and can be first choice of different solutions.</p>\n</blockquote>\n<h6 id=\"3-merge-the-left-part-and-reversed-right-part-one-by-one\"><a href=\"#3-merge-the-left-part-and-reversed-right-part-one-by-one\" class=\"headerlink\" title=\"3. merge the left part and reversed right part one by one\"></a>3. merge the left part and reversed right part one by one</h6><p>We just combine two list one by one, for example <code>1-&gt;2-&gt;3</code> and <code>5-&gt;4</code> will be <code>1-&gt; 5 -&gt;2-&gt; 4 -&gt;3</code> after merge. Time complexity is still <strong><em>O(n)</em></strong>.</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    private ListNode ansHead; </span><br><span class=\"line\">    public void reorderList(ListNode head) &#123;</span><br><span class=\"line\">        int length = 0;</span><br><span class=\"line\">        ListNode temp = head, newHead = head, pre = head;</span><br><span class=\"line\">        while(temp!=null)&#123;</span><br><span class=\"line\">            length++;</span><br><span class=\"line\">            temp= temp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(length &lt; 3)return ;</span><br><span class=\"line\">        int mid = (length &gt;&gt; 1)  + 1;</span><br><span class=\"line\">        for(int i = 1; i &lt;= mid; i++)&#123;</span><br><span class=\"line\">            pre = newHead;</span><br><span class=\"line\">            newHead = newHead.next;            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre.next = null;</span><br><span class=\"line\">        reverse(newHead);</span><br><span class=\"line\">        merge(head, ansHead);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public ListNode reverse(ListNode head)&#123;</span><br><span class=\"line\">        if(head.next == null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            this.ansHead = head;</span><br><span class=\"line\">            return head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode next = inverse(head.next);</span><br><span class=\"line\">        next.next = head;</span><br><span class=\"line\">        head.next = null;</span><br><span class=\"line\">        return head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /*</span><br><span class=\"line\">    //This function reverse a list by pointers, it cost a constant space</span><br><span class=\"line\">     public ListNode reverse(ListNode head)&#123;</span><br><span class=\"line\">        ListNode pre = null, cur = head, next = head;</span><br><span class=\"line\">        while(cur.next != null)&#123;</span><br><span class=\"line\">            next = cur.next;</span><br><span class=\"line\">            cur.next = pre;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur.next = pre;</span><br><span class=\"line\">        ansHead = cur;</span><br><span class=\"line\">        return cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    */</span><br><span class=\"line\">    public void merge(ListNode head1, ListNode head2)&#123;</span><br><span class=\"line\">        while(head2 != null)&#123;</span><br><span class=\"line\">            ListNode next= head2.next;</span><br><span class=\"line\">            head2.next = head1.next;</span><br><span class=\"line\">            head1.next = head2;</span><br><span class=\"line\">            head1 = head2.next;</span><br><span class=\"line\">            head2 = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Comlexity\"><a href=\"#Comlexity\" class=\"headerlink\" title=\"Comlexity\"></a>Comlexity</h1><p><strong><em>Time Complexity:</em></strong> O(n), see analysis above.</p>\n<p><strong><em>Space Complexity:</em></strong> We cost a constant space O(1) if using <em>pointer</em> method to reverse a list, other wise it’s O(n)</p>\n"},{"title":"19 Remove Nth Node From End of List","date":"2019-11-27T06:35:52.000Z","_content":"# Intuition & Alogorithm\nSince it's a singly linked list, we'd can only count the number of the node from head to tail. The equavalent question of this is `remove the (N-n+1)-th node from the head of list and return its head, where N is the length of the list`. There are several corner cases to notice:\n1. `n > N or n <= 0` both conditions means we try to remove unexisted nodes in the list(before the head or after the end);\n2. `n==N` this means we want to remove the head, we can deal with this one alone, or add a dummy node;\n\nBesides corner cases, we should remember to use fast-slow pointer to remove a node from the list. (I'm used to call them current and previous pointer)\n\n# Code\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        int N = 0;\n        ListNode tmp = head;\n        while(tmp!=null){\n            tmp = tmp.next;\n            N++;\n        }\n        if(n > N || n == 0){\n            return head;\n        }\n        n = N - n;\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode cur = head;\n        ListNode pre = dummy;\n        while(n-- > 0){\n            pre = cur;\n            cur = cur.next;\n        }\n        pre.next = cur.next;\n        cur = null;\n        return dummy.next;\n    }\n}\n```\n\n# Complexity\n**Time Complexity:** O(N+n) There are two for loops here, costing O(N) and O(n) respectively.\n\n**Space Complexity:** O(1)\n","source":"_posts/19-Remove-Nth-Node-From-End-of-List.md","raw":"---\ntitle: 19 Remove Nth Node From End of List\ndate: 2019-11-27 14:35:52\ntags:\n- list\ncategories:\n- LeetCode\n---\n# Intuition & Alogorithm\nSince it's a singly linked list, we'd can only count the number of the node from head to tail. The equavalent question of this is `remove the (N-n+1)-th node from the head of list and return its head, where N is the length of the list`. There are several corner cases to notice:\n1. `n > N or n <= 0` both conditions means we try to remove unexisted nodes in the list(before the head or after the end);\n2. `n==N` this means we want to remove the head, we can deal with this one alone, or add a dummy node;\n\nBesides corner cases, we should remember to use fast-slow pointer to remove a node from the list. (I'm used to call them current and previous pointer)\n\n# Code\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        int N = 0;\n        ListNode tmp = head;\n        while(tmp!=null){\n            tmp = tmp.next;\n            N++;\n        }\n        if(n > N || n == 0){\n            return head;\n        }\n        n = N - n;\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode cur = head;\n        ListNode pre = dummy;\n        while(n-- > 0){\n            pre = cur;\n            cur = cur.next;\n        }\n        pre.next = cur.next;\n        cur = null;\n        return dummy.next;\n    }\n}\n```\n\n# Complexity\n**Time Complexity:** O(N+n) There are two for loops here, costing O(N) and O(n) respectively.\n\n**Space Complexity:** O(1)\n","slug":"19-Remove-Nth-Node-From-End-of-List","published":1,"updated":"2020-05-03T06:14:50.672Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixqx000ak4r30ji6auvs","content":"<h1 id=\"Intuition-amp-Alogorithm\"><a href=\"#Intuition-amp-Alogorithm\" class=\"headerlink\" title=\"Intuition &amp; Alogorithm\"></a>Intuition &amp; Alogorithm</h1><p>Since it’s a singly linked list, we’d can only count the number of the node from head to tail. The equavalent question of this is <code>remove the (N-n+1)-th node from the head of list and return its head, where N is the length of the list</code>. There are several corner cases to notice:</p>\n<ol>\n<li><code>n &gt; N or n &lt;= 0</code> both conditions means we try to remove unexisted nodes in the list(before the head or after the end);</li>\n<li><code>n==N</code> this means we want to remove the head, we can deal with this one alone, or add a dummy node;</li>\n</ol>\n<p>Besides corner cases, we should remember to use fast-slow pointer to remove a node from the list. (I’m used to call them current and previous pointer)</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class=\"line\">        int N = 0;</span><br><span class=\"line\">        ListNode tmp = head;</span><br><span class=\"line\">        while(tmp!=null)&#123;</span><br><span class=\"line\">            tmp = tmp.next;</span><br><span class=\"line\">            N++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(n &gt; N || n == 0)&#123;</span><br><span class=\"line\">            return head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        n = N - n;</span><br><span class=\"line\">        ListNode dummy = new ListNode(0);</span><br><span class=\"line\">        dummy.next = head;</span><br><span class=\"line\">        ListNode cur = head;</span><br><span class=\"line\">        ListNode pre = dummy;</span><br><span class=\"line\">        while(n-- &gt; 0)&#123;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre.next = cur.next;</span><br><span class=\"line\">        cur = null;</span><br><span class=\"line\">        return dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> O(N+n) There are two for loops here, costing O(N) and O(n) respectively.</p>\n<p><strong>Space Complexity:</strong> O(1)</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition-amp-Alogorithm\"><a href=\"#Intuition-amp-Alogorithm\" class=\"headerlink\" title=\"Intuition &amp; Alogorithm\"></a>Intuition &amp; Alogorithm</h1><p>Since it’s a singly linked list, we’d can only count the number of the node from head to tail. The equavalent question of this is <code>remove the (N-n+1)-th node from the head of list and return its head, where N is the length of the list</code>. There are several corner cases to notice:</p>\n<ol>\n<li><code>n &gt; N or n &lt;= 0</code> both conditions means we try to remove unexisted nodes in the list(before the head or after the end);</li>\n<li><code>n==N</code> this means we want to remove the head, we can deal with this one alone, or add a dummy node;</li>\n</ol>\n<p>Besides corner cases, we should remember to use fast-slow pointer to remove a node from the list. (I’m used to call them current and previous pointer)</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class=\"line\">        int N = 0;</span><br><span class=\"line\">        ListNode tmp = head;</span><br><span class=\"line\">        while(tmp!=null)&#123;</span><br><span class=\"line\">            tmp = tmp.next;</span><br><span class=\"line\">            N++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(n &gt; N || n == 0)&#123;</span><br><span class=\"line\">            return head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        n = N - n;</span><br><span class=\"line\">        ListNode dummy = new ListNode(0);</span><br><span class=\"line\">        dummy.next = head;</span><br><span class=\"line\">        ListNode cur = head;</span><br><span class=\"line\">        ListNode pre = dummy;</span><br><span class=\"line\">        while(n-- &gt; 0)&#123;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre.next = cur.next;</span><br><span class=\"line\">        cur = null;</span><br><span class=\"line\">        return dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> O(N+n) There are two for loops here, costing O(N) and O(n) respectively.</p>\n<p><strong>Space Complexity:</strong> O(1)</p>\n"},{"title":"120  Triangle","date":"2019-11-08T15:49:20.000Z","_content":"# Intuition\nThe **broute-force solution** for this method is to list all the possible path, and then get the minimum.\nIn the top layer of the triangle, we can only choose index *0*. In the second layer, we can choose *0* or *1* for *0* in the first layer. In the third layer, we can choose *0* or *1* for *0* in second layer and *1* or *2* for *1*... these choices form a binary tree. Each path from root to leaf node is related to a path from top to bottom in the trianlgle.So the time complexity is $O(2^n)$.\n\nFrom the above analysis, we find out this is a **dynamic programming** problem, so we can use **memoization** to store the minimum sum from top to the entry in the previous layer and then compare the entries in current layer and get the minimum. For example, in the **i**th layer, for the **j**th element, we have:\n```\nmemo[i][j] = Math.min(memo[i-1][j-1], memo[i-1][j])+triangle[i][j]\n```\nThe equation above actually has also give us the state transition formula for this question. What we want is `min(memo[n-1][j])` with j from 0 to n-1. The question has an extra bonus for less space.`Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.` Currently, space complexity is $O(n^2)$, but we don't need to save all the middle result in array since current state is only relative to previous one, not all the past state. So we can use two one dimensional array, one for previous state, and one for current state. If we look deeper into the state transition equation, one array is enough, we just update elements in previous array to current array one by one.\n\n> Note: *j-1* might be less than 0 and *j* might be large than i(in the ith layer, the maximum index is i). We need to deal with these two cases.\n\n# Algorithm\nAs stated before, this is a dynamic problem, there are three methods:\n1. Recursion\n2. Memoization (Optimize for recursion)\n3. Iteration\n\nWe will only talk  about the iteration method here. Since we have given the two dimensional state  transition equation before, one dimensional state transition equation will be given here, which should be the best solution for this question. Note j is from i to 0 in case we shltered the old state before we don't need it.\n\n*State Transition:* \n\n$$\ndp[j] = min(dp[j-1],dp[j])+triangle[i][j], j\\in{i, i-1, ..., 0} \\quad i\\in0,1,...,n\n$$\n\n# Code \n```\nclass Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n\n        int n = triangle.size();\n        int[] dp = new int[n];\n        dp[0] = triangle.get(0).get(0);\n        for(int i = 1; i < n; i++){\n            for(int j = i; j >= 0; j--){\n                int l = Math.max(0, j-1);\n                int r = Math.min(i-1, j);\n                dp[j] = Math.min(dp[l], dp[r]) + triangle.get(i).get(j);\n            }\n        }\n        int ans = Integer.MAX_VALUE;\n        for(int i = 0; i < n; i++){\n            ans = Math.min(ans, dp[i]);\n        }\n        return ans;\n    }\n}\n```\n# Complexity\n**Time Complexity:** $O(n^2)$\n\n**Space Complexity:** $O(n)$\n\n","source":"_posts/120-Triangle.md","raw":"---\ntitle: 120  Triangle\ndate: 2019-11-08 23:49:20\ncategories:\n- LeetCode\ntags:\n- dynamic programming\n---\n# Intuition\nThe **broute-force solution** for this method is to list all the possible path, and then get the minimum.\nIn the top layer of the triangle, we can only choose index *0*. In the second layer, we can choose *0* or *1* for *0* in the first layer. In the third layer, we can choose *0* or *1* for *0* in second layer and *1* or *2* for *1*... these choices form a binary tree. Each path from root to leaf node is related to a path from top to bottom in the trianlgle.So the time complexity is $O(2^n)$.\n\nFrom the above analysis, we find out this is a **dynamic programming** problem, so we can use **memoization** to store the minimum sum from top to the entry in the previous layer and then compare the entries in current layer and get the minimum. For example, in the **i**th layer, for the **j**th element, we have:\n```\nmemo[i][j] = Math.min(memo[i-1][j-1], memo[i-1][j])+triangle[i][j]\n```\nThe equation above actually has also give us the state transition formula for this question. What we want is `min(memo[n-1][j])` with j from 0 to n-1. The question has an extra bonus for less space.`Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.` Currently, space complexity is $O(n^2)$, but we don't need to save all the middle result in array since current state is only relative to previous one, not all the past state. So we can use two one dimensional array, one for previous state, and one for current state. If we look deeper into the state transition equation, one array is enough, we just update elements in previous array to current array one by one.\n\n> Note: *j-1* might be less than 0 and *j* might be large than i(in the ith layer, the maximum index is i). We need to deal with these two cases.\n\n# Algorithm\nAs stated before, this is a dynamic problem, there are three methods:\n1. Recursion\n2. Memoization (Optimize for recursion)\n3. Iteration\n\nWe will only talk  about the iteration method here. Since we have given the two dimensional state  transition equation before, one dimensional state transition equation will be given here, which should be the best solution for this question. Note j is from i to 0 in case we shltered the old state before we don't need it.\n\n*State Transition:* \n\n$$\ndp[j] = min(dp[j-1],dp[j])+triangle[i][j], j\\in{i, i-1, ..., 0} \\quad i\\in0,1,...,n\n$$\n\n# Code \n```\nclass Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n\n        int n = triangle.size();\n        int[] dp = new int[n];\n        dp[0] = triangle.get(0).get(0);\n        for(int i = 1; i < n; i++){\n            for(int j = i; j >= 0; j--){\n                int l = Math.max(0, j-1);\n                int r = Math.min(i-1, j);\n                dp[j] = Math.min(dp[l], dp[r]) + triangle.get(i).get(j);\n            }\n        }\n        int ans = Integer.MAX_VALUE;\n        for(int i = 0; i < n; i++){\n            ans = Math.min(ans, dp[i]);\n        }\n        return ans;\n    }\n}\n```\n# Complexity\n**Time Complexity:** $O(n^2)$\n\n**Space Complexity:** $O(n)$\n\n","slug":"120-Triangle","published":1,"updated":"2020-05-03T06:14:50.670Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixr5000bk4r3luqhgqsd","content":"<h1 id=\"Intuition\"><a href=\"#Intuition\" class=\"headerlink\" title=\"Intuition\"></a>Intuition</h1><p>The <strong>broute-force solution</strong> for this method is to list all the possible path, and then get the minimum.<br>In the top layer of the triangle, we can only choose index <em>0</em>. In the second layer, we can choose <em>0</em> or <em>1</em> for <em>0</em> in the first layer. In the third layer, we can choose <em>0</em> or <em>1</em> for <em>0</em> in second layer and <em>1</em> or <em>2</em> for <em>1</em>… these choices form a binary tree. Each path from root to leaf node is related to a path from top to bottom in the trianlgle.So the time complexity is $O(2^n)$.</p>\n<p>From the above analysis, we find out this is a <strong>dynamic programming</strong> problem, so we can use <strong>memoization</strong> to store the minimum sum from top to the entry in the previous layer and then compare the entries in current layer and get the minimum. For example, in the <strong>i</strong>th layer, for the <strong>j</strong>th element, we have:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">memo[i][j] = Math.min(memo[i-1][j-1], memo[i-1][j])+triangle[i][j]</span><br></pre></td></tr></table></figure></p>\n<p>The equation above actually has also give us the state transition formula for this question. What we want is <code>min(memo[n-1][j])</code> with j from 0 to n-1. The question has an extra bonus for less space.<code>Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</code> Currently, space complexity is $O(n^2)$, but we don’t need to save all the middle result in array since current state is only relative to previous one, not all the past state. So we can use two one dimensional array, one for previous state, and one for current state. If we look deeper into the state transition equation, one array is enough, we just update elements in previous array to current array one by one.</p>\n<blockquote>\n<p>Note: <em>j-1</em> might be less than 0 and <em>j</em> might be large than i(in the ith layer, the maximum index is i). We need to deal with these two cases.</p>\n</blockquote>\n<h1 id=\"Algorithm\"><a href=\"#Algorithm\" class=\"headerlink\" title=\"Algorithm\"></a>Algorithm</h1><p>As stated before, this is a dynamic problem, there are three methods:</p>\n<ol>\n<li>Recursion</li>\n<li>Memoization (Optimize for recursion)</li>\n<li>Iteration</li>\n</ol>\n<p>We will only talk  about the iteration method here. Since we have given the two dimensional state  transition equation before, one dimensional state transition equation will be given here, which should be the best solution for this question. Note j is from i to 0 in case we shltered the old state before we don’t need it.</p>\n<p><em>State Transition:</em> </p>\n<script type=\"math/tex; mode=display\">\ndp[j] = min(dp[j-1],dp[j])+triangle[i][j], j\\in{i, i-1, ..., 0} \\quad i\\in0,1,...,n</script><h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        int n = triangle.size();</span><br><span class=\"line\">        int[] dp = new int[n];</span><br><span class=\"line\">        dp[0] = triangle.get(0).get(0);</span><br><span class=\"line\">        for(int i = 1; i &lt; n; i++)&#123;</span><br><span class=\"line\">            for(int j = i; j &gt;= 0; j--)&#123;</span><br><span class=\"line\">                int l = Math.max(0, j-1);</span><br><span class=\"line\">                int r = Math.min(i-1, j);</span><br><span class=\"line\">                dp[j] = Math.min(dp[l], dp[r]) + triangle.get(i).get(j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int ans = Integer.MAX_VALUE;</span><br><span class=\"line\">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class=\"line\">            ans = Math.min(ans, dp[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(n^2)$</p>\n<p><strong>Space Complexity:</strong> $O(n)$</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition\"><a href=\"#Intuition\" class=\"headerlink\" title=\"Intuition\"></a>Intuition</h1><p>The <strong>broute-force solution</strong> for this method is to list all the possible path, and then get the minimum.<br>In the top layer of the triangle, we can only choose index <em>0</em>. In the second layer, we can choose <em>0</em> or <em>1</em> for <em>0</em> in the first layer. In the third layer, we can choose <em>0</em> or <em>1</em> for <em>0</em> in second layer and <em>1</em> or <em>2</em> for <em>1</em>… these choices form a binary tree. Each path from root to leaf node is related to a path from top to bottom in the trianlgle.So the time complexity is $O(2^n)$.</p>\n<p>From the above analysis, we find out this is a <strong>dynamic programming</strong> problem, so we can use <strong>memoization</strong> to store the minimum sum from top to the entry in the previous layer and then compare the entries in current layer and get the minimum. For example, in the <strong>i</strong>th layer, for the <strong>j</strong>th element, we have:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">memo[i][j] = Math.min(memo[i-1][j-1], memo[i-1][j])+triangle[i][j]</span><br></pre></td></tr></table></figure></p>\n<p>The equation above actually has also give us the state transition formula for this question. What we want is <code>min(memo[n-1][j])</code> with j from 0 to n-1. The question has an extra bonus for less space.<code>Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</code> Currently, space complexity is $O(n^2)$, but we don’t need to save all the middle result in array since current state is only relative to previous one, not all the past state. So we can use two one dimensional array, one for previous state, and one for current state. If we look deeper into the state transition equation, one array is enough, we just update elements in previous array to current array one by one.</p>\n<blockquote>\n<p>Note: <em>j-1</em> might be less than 0 and <em>j</em> might be large than i(in the ith layer, the maximum index is i). We need to deal with these two cases.</p>\n</blockquote>\n<h1 id=\"Algorithm\"><a href=\"#Algorithm\" class=\"headerlink\" title=\"Algorithm\"></a>Algorithm</h1><p>As stated before, this is a dynamic problem, there are three methods:</p>\n<ol>\n<li>Recursion</li>\n<li>Memoization (Optimize for recursion)</li>\n<li>Iteration</li>\n</ol>\n<p>We will only talk  about the iteration method here. Since we have given the two dimensional state  transition equation before, one dimensional state transition equation will be given here, which should be the best solution for this question. Note j is from i to 0 in case we shltered the old state before we don’t need it.</p>\n<p><em>State Transition:</em> </p>\n<script type=\"math/tex; mode=display\">\ndp[j] = min(dp[j-1],dp[j])+triangle[i][j], j\\in{i, i-1, ..., 0} \\quad i\\in0,1,...,n</script><h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        int n = triangle.size();</span><br><span class=\"line\">        int[] dp = new int[n];</span><br><span class=\"line\">        dp[0] = triangle.get(0).get(0);</span><br><span class=\"line\">        for(int i = 1; i &lt; n; i++)&#123;</span><br><span class=\"line\">            for(int j = i; j &gt;= 0; j--)&#123;</span><br><span class=\"line\">                int l = Math.max(0, j-1);</span><br><span class=\"line\">                int r = Math.min(i-1, j);</span><br><span class=\"line\">                dp[j] = Math.min(dp[l], dp[r]) + triangle.get(i).get(j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int ans = Integer.MAX_VALUE;</span><br><span class=\"line\">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class=\"line\">            ans = Math.min(ans, dp[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(n^2)$</p>\n<p><strong>Space Complexity:</strong> $O(n)$</p>\n"},{"title":"148 Sort List","date":"2019-11-10T12:54:24.000Z","_content":"# Intuition & Algorithm\nThe diagram and illustration in the question have given us a clear description of insertion sort algorithm.\n1. Separate the list into two parts: `sorted` and `sorting`\n2. Insert the head of `sorting` list into the sorted list\n\nWe should consider three cases during insertion(v is the node to be inserted):\n- `v < sorted.head.val` we should use this node as the new head of sorted list\n- `cur.val < v < cur.next.val` `cur` is a node in the sorted list, in this case we should insert the new node between `cur` and `cur.next`\n- `cur.next == null` this means `v` is large than any number in the list, so we append it to the tail.\n\n\n# Code\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode insertionSortList(ListNode head) {\n        if(head == null)return head;\n        ListNode sorted=head,sorting = head.next, next;\n        head.next = null;\n        while(sorting != null){\n            next = sorting.next;\n            \n            ListNode cur = sorted;\n            if(sorting.val < cur.val){\n                sorting.next = sorted;\n                sorted = sorting;\n            }\n            else{\n                while(cur.next != null){\n                    if(sorting.val >= cur.val && sorting.val <= cur.next.val)\n                    {\n                        sorting.next = cur.next;\n                        cur.next = sorting;\n                        break;\n                    }\n                    cur = cur.next;\n                }\n                if(cur.next == null){\n                    sorting.next = null;\n                    cur.next = sorting;\n                }\n            }\n            sorting = next;\n        }\n        return sorted;\n    }\n}\n```\n\n# Complexity\n**Time Complexity:** $O(n)$\n\n**Spatial Complexity:** $O(1)$\n","source":"_posts/148-Sort-List.md","raw":"---\ntitle: 148 Sort List\ndate: 2019-11-10 20:54:24\ncategories:\n- LeetCode\ntags:\n- list\n- pointer\n---\n# Intuition & Algorithm\nThe diagram and illustration in the question have given us a clear description of insertion sort algorithm.\n1. Separate the list into two parts: `sorted` and `sorting`\n2. Insert the head of `sorting` list into the sorted list\n\nWe should consider three cases during insertion(v is the node to be inserted):\n- `v < sorted.head.val` we should use this node as the new head of sorted list\n- `cur.val < v < cur.next.val` `cur` is a node in the sorted list, in this case we should insert the new node between `cur` and `cur.next`\n- `cur.next == null` this means `v` is large than any number in the list, so we append it to the tail.\n\n\n# Code\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode insertionSortList(ListNode head) {\n        if(head == null)return head;\n        ListNode sorted=head,sorting = head.next, next;\n        head.next = null;\n        while(sorting != null){\n            next = sorting.next;\n            \n            ListNode cur = sorted;\n            if(sorting.val < cur.val){\n                sorting.next = sorted;\n                sorted = sorting;\n            }\n            else{\n                while(cur.next != null){\n                    if(sorting.val >= cur.val && sorting.val <= cur.next.val)\n                    {\n                        sorting.next = cur.next;\n                        cur.next = sorting;\n                        break;\n                    }\n                    cur = cur.next;\n                }\n                if(cur.next == null){\n                    sorting.next = null;\n                    cur.next = sorting;\n                }\n            }\n            sorting = next;\n        }\n        return sorted;\n    }\n}\n```\n\n# Complexity\n**Time Complexity:** $O(n)$\n\n**Spatial Complexity:** $O(1)$\n","slug":"148-Sort-List","published":1,"updated":"2020-05-03T06:14:50.672Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixr6000ck4r35g9x89k6","content":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>The diagram and illustration in the question have given us a clear description of insertion sort algorithm.</p>\n<ol>\n<li>Separate the list into two parts: <code>sorted</code> and <code>sorting</code></li>\n<li>Insert the head of <code>sorting</code> list into the sorted list</li>\n</ol>\n<p>We should consider three cases during insertion(v is the node to be inserted):</p>\n<ul>\n<li><code>v &lt; sorted.head.val</code> we should use this node as the new head of sorted list</li>\n<li><code>cur.val &lt; v &lt; cur.next.val</code> <code>cur</code> is a node in the sorted list, in this case we should insert the new node between <code>cur</code> and <code>cur.next</code></li>\n<li><code>cur.next == null</code> this means <code>v</code> is large than any number in the list, so we append it to the tail.</li>\n</ul>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode insertionSortList(ListNode head) &#123;</span><br><span class=\"line\">        if(head == null)return head;</span><br><span class=\"line\">        ListNode sorted=head,sorting = head.next, next;</span><br><span class=\"line\">        head.next = null;</span><br><span class=\"line\">        while(sorting != null)&#123;</span><br><span class=\"line\">            next = sorting.next;</span><br><span class=\"line\">            </span><br><span class=\"line\">            ListNode cur = sorted;</span><br><span class=\"line\">            if(sorting.val &lt; cur.val)&#123;</span><br><span class=\"line\">                sorting.next = sorted;</span><br><span class=\"line\">                sorted = sorting;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else&#123;</span><br><span class=\"line\">                while(cur.next != null)&#123;</span><br><span class=\"line\">                    if(sorting.val &gt;= cur.val &amp;&amp; sorting.val &lt;= cur.next.val)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        sorting.next = cur.next;</span><br><span class=\"line\">                        cur.next = sorting;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    cur = cur.next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if(cur.next == null)&#123;</span><br><span class=\"line\">                    sorting.next = null;</span><br><span class=\"line\">                    cur.next = sorting;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sorting = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return sorted;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(n)$</p>\n<p><strong>Spatial Complexity:</strong> $O(1)$</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>The diagram and illustration in the question have given us a clear description of insertion sort algorithm.</p>\n<ol>\n<li>Separate the list into two parts: <code>sorted</code> and <code>sorting</code></li>\n<li>Insert the head of <code>sorting</code> list into the sorted list</li>\n</ol>\n<p>We should consider three cases during insertion(v is the node to be inserted):</p>\n<ul>\n<li><code>v &lt; sorted.head.val</code> we should use this node as the new head of sorted list</li>\n<li><code>cur.val &lt; v &lt; cur.next.val</code> <code>cur</code> is a node in the sorted list, in this case we should insert the new node between <code>cur</code> and <code>cur.next</code></li>\n<li><code>cur.next == null</code> this means <code>v</code> is large than any number in the list, so we append it to the tail.</li>\n</ul>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode insertionSortList(ListNode head) &#123;</span><br><span class=\"line\">        if(head == null)return head;</span><br><span class=\"line\">        ListNode sorted=head,sorting = head.next, next;</span><br><span class=\"line\">        head.next = null;</span><br><span class=\"line\">        while(sorting != null)&#123;</span><br><span class=\"line\">            next = sorting.next;</span><br><span class=\"line\">            </span><br><span class=\"line\">            ListNode cur = sorted;</span><br><span class=\"line\">            if(sorting.val &lt; cur.val)&#123;</span><br><span class=\"line\">                sorting.next = sorted;</span><br><span class=\"line\">                sorted = sorting;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else&#123;</span><br><span class=\"line\">                while(cur.next != null)&#123;</span><br><span class=\"line\">                    if(sorting.val &gt;= cur.val &amp;&amp; sorting.val &lt;= cur.next.val)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        sorting.next = cur.next;</span><br><span class=\"line\">                        cur.next = sorting;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    cur = cur.next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if(cur.next == null)&#123;</span><br><span class=\"line\">                    sorting.next = null;</span><br><span class=\"line\">                    cur.next = sorting;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sorting = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return sorted;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(n)$</p>\n<p><strong>Spatial Complexity:</strong> $O(1)$</p>\n"},{"title":"216 Combination Sum III","date":"2019-11-20T05:42:31.000Z","comments":1,"_content":"# Intuition & Algorithm\nNumbers 1-9 can be seen as candidates in the previous questions, the constraints of this question are:\n1. We can only pick one number one time, but we can only pick `k` numbers.\n2. All numbers are unique\n\nActually,  this question is much easier than before since numbers are unique and we can only pick one number one time. If we pick these numbers by ascending order, there will be no duplicates. We only need to record the depth of the path in dfs, ensuring it no more than `k`.\n\n\n# Code\n```\nclass Solution {\n    List<Integer> path = new LinkedList<>();\n    List<List<Integer>> ans = new LinkedList<>();\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        if(k > 9 || n <= 0)\n            return ans;\n        dfs(k, n, 1);\n        return ans;\n    }\n    private void dfs(int k, int n , int c){\n        if(k==0 && n==0){\n            ans.add(new ArrayList<Integer>(path));\n            return;\n        }\n        if(k==0 || n<=0 || c>9)\n        {\n            return;\n        }\n        for(int i = c; i < 10; i++){\n            path.add(i);\n            dfs(k-1, n-i, i+1);\n            path.remove(path.size()-1);\n        }\n    }\n}\n```\n\n# Complexity\n**Time Complexity:** $O(9^k)$\n\n**Space Complexity:** $O(km)$ where m is the number of solutions, it's a math problem and I'm not sure what it is. \n","source":"_posts/216-Combination-Sum-III.md","raw":"---\ntitle: 216 Combination Sum III\ndate: 2019-11-20 13:42:31\ntags:\n- dfs\ncategories:\n- LeetCode\ncomments: true\n---\n# Intuition & Algorithm\nNumbers 1-9 can be seen as candidates in the previous questions, the constraints of this question are:\n1. We can only pick one number one time, but we can only pick `k` numbers.\n2. All numbers are unique\n\nActually,  this question is much easier than before since numbers are unique and we can only pick one number one time. If we pick these numbers by ascending order, there will be no duplicates. We only need to record the depth of the path in dfs, ensuring it no more than `k`.\n\n\n# Code\n```\nclass Solution {\n    List<Integer> path = new LinkedList<>();\n    List<List<Integer>> ans = new LinkedList<>();\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        if(k > 9 || n <= 0)\n            return ans;\n        dfs(k, n, 1);\n        return ans;\n    }\n    private void dfs(int k, int n , int c){\n        if(k==0 && n==0){\n            ans.add(new ArrayList<Integer>(path));\n            return;\n        }\n        if(k==0 || n<=0 || c>9)\n        {\n            return;\n        }\n        for(int i = c; i < 10; i++){\n            path.add(i);\n            dfs(k-1, n-i, i+1);\n            path.remove(path.size()-1);\n        }\n    }\n}\n```\n\n# Complexity\n**Time Complexity:** $O(9^k)$\n\n**Space Complexity:** $O(km)$ where m is the number of solutions, it's a math problem and I'm not sure what it is. \n","slug":"216-Combination-Sum-III","published":1,"updated":"2020-05-03T06:14:50.672Z","layout":"post","photos":[],"link":"","_id":"cka27ixr8000dk4r30vn85ehv","content":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>Numbers 1-9 can be seen as candidates in the previous questions, the constraints of this question are:</p>\n<ol>\n<li>We can only pick one number one time, but we can only pick <code>k</code> numbers.</li>\n<li>All numbers are unique</li>\n</ol>\n<p>Actually,  this question is much easier than before since numbers are unique and we can only pick one number one time. If we pick these numbers by ascending order, there will be no duplicates. We only need to record the depth of the path in dfs, ensuring it no more than <code>k</code>.</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    List&lt;Integer&gt; path = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class=\"line\">        if(k &gt; 9 || n &lt;= 0)</span><br><span class=\"line\">            return ans;</span><br><span class=\"line\">        dfs(k, n, 1);</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private void dfs(int k, int n , int c)&#123;</span><br><span class=\"line\">        if(k==0 &amp;&amp; n==0)&#123;</span><br><span class=\"line\">            ans.add(new ArrayList&lt;Integer&gt;(path));</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(k==0 || n&lt;=0 || c&gt;9)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for(int i = c; i &lt; 10; i++)&#123;</span><br><span class=\"line\">            path.add(i);</span><br><span class=\"line\">            dfs(k-1, n-i, i+1);</span><br><span class=\"line\">            path.remove(path.size()-1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(9^k)$</p>\n<p><strong>Space Complexity:</strong> $O(km)$ where m is the number of solutions, it’s a math problem and I’m not sure what it is. </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>Numbers 1-9 can be seen as candidates in the previous questions, the constraints of this question are:</p>\n<ol>\n<li>We can only pick one number one time, but we can only pick <code>k</code> numbers.</li>\n<li>All numbers are unique</li>\n</ol>\n<p>Actually,  this question is much easier than before since numbers are unique and we can only pick one number one time. If we pick these numbers by ascending order, there will be no duplicates. We only need to record the depth of the path in dfs, ensuring it no more than <code>k</code>.</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    List&lt;Integer&gt; path = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class=\"line\">        if(k &gt; 9 || n &lt;= 0)</span><br><span class=\"line\">            return ans;</span><br><span class=\"line\">        dfs(k, n, 1);</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private void dfs(int k, int n , int c)&#123;</span><br><span class=\"line\">        if(k==0 &amp;&amp; n==0)&#123;</span><br><span class=\"line\">            ans.add(new ArrayList&lt;Integer&gt;(path));</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(k==0 || n&lt;=0 || c&gt;9)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for(int i = c; i &lt; 10; i++)&#123;</span><br><span class=\"line\">            path.add(i);</span><br><span class=\"line\">            dfs(k-1, n-i, i+1);</span><br><span class=\"line\">            path.remove(path.size()-1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(9^k)$</p>\n<p><strong>Space Complexity:</strong> $O(km)$ where m is the number of solutions, it’s a math problem and I’m not sure what it is. </p>\n"},{"title":"25 Reverse Nodes in k-Group","date":"2019-11-23T13:25:25.000Z","_content":"# Intuition & Algorithm\nThe very intuitive method to solve this problem is:\n1. splice the List into k nodes a group\n2. reverse the group list\n3. reconnect groups\n\nA simple implementation is recursion, first reverse the last group, return its head, and then reverse the group before the last one, set its tail to last group's head and return current group head. The whole process goes until the first group is reversed and its tail is set, head is the final answer. The iteration version of this method is using a stack to store each group's head, the algorithm goes similar.\n\nAnother algorithm not so straight-forward I call it forward iteration. Because we don't reverse the group from the last one to the first one, we reverse the first group and record it's tail and next group's head, and then connect them together.\n# Code\n1. Forward Iteration \n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        int n = 0;\n        ListNode c = head;\n        while(c!=null){\n            n++;c=c.next;\n        }\n        ListNode pre = dummy, tail = head;\n        while(n>=k){a\n            for(int i = 1 ; i < k; i++){\n                ListNode next = tail.next.next;\n                tail.next.next = pre.next;\n                pre.next = tail.next;\n                tail.next = next;\n            }\n            pre = tail;\n            tail = tail.next;\n            n-=k;\n        }\n        return dummy.next;\n    }\n}\n```\n2. Backward Recursion\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n   public ListNode reverseKGroup(ListNode head, int k) {\n    ListNode curr = head;\n    int count = 0;\n    while (curr != null && count != k) {\n        curr = curr.next;\n        count++;\n    }\n    if (count == k) { \n        curr = reverseKGroup(curr, k); \n        while (count-- > 0) { \n            ListNode tmp = head.next; \n            head.next = curr;  \n            curr = head; \n            head = tmp; \n        }\n        head = curr;\n    }\n    return head;\n}\n}\n```\n3. Backward Iteration\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        // If less than k nodes, return directly\n        if(k<=1)return head;\n        List<ListNode> stack = new LinkedList<>();\n        int count = 0;\n        ListNode cur = head, lastHead = null;\n        int start = 0;\n        while(cur != null){\n            count++;\n            if(count % k == 1)stack.add(cur);\n            cur = cur.next;\n        }\n        start = stack.size()-1;\n        if(count < k)return head;\n        if(count % k != 0)\n        {\n            lastHead = stack.get(start--);\n        }\n        for(int i = start; i>=0; i--){\n            lastHead = reverseGroup(stack.get(i), lastHead, k);\n        }\n        return lastHead;\n    }\n    private ListNode reverseGroup(ListNode head, ListNode lastHead, int k){\n        ListNode cur = head, next = head.next;\n        while(k-- > 0){\n            cur.next = lastHead;\n            lastHead = cur;\n            cur = next;\n            if(cur != null)\n            next = cur.next;\n        }\n        return lastHead;\n    }\n    \n}\n```\n\n# Complexity\n\n**Time Complexity:** $O(n)$ All the solutions are linear since we have to traverse over the entire list.\n\n**Space Complexity:** For the forward iteration solution it's $O(1)$, for the other two, we need $O(\\lceil n/k \\rceil)$ to store the head node of all groups.\n\n","source":"_posts/25-Reverse-Nodes-in-k-Group.md","raw":"---\ntitle: 25 Reverse Nodes in k-Group\ndate: 2019-11-23 21:25:25\ntags:\n- list\ncategories:\n- LeetCode\n---\n# Intuition & Algorithm\nThe very intuitive method to solve this problem is:\n1. splice the List into k nodes a group\n2. reverse the group list\n3. reconnect groups\n\nA simple implementation is recursion, first reverse the last group, return its head, and then reverse the group before the last one, set its tail to last group's head and return current group head. The whole process goes until the first group is reversed and its tail is set, head is the final answer. The iteration version of this method is using a stack to store each group's head, the algorithm goes similar.\n\nAnother algorithm not so straight-forward I call it forward iteration. Because we don't reverse the group from the last one to the first one, we reverse the first group and record it's tail and next group's head, and then connect them together.\n# Code\n1. Forward Iteration \n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        int n = 0;\n        ListNode c = head;\n        while(c!=null){\n            n++;c=c.next;\n        }\n        ListNode pre = dummy, tail = head;\n        while(n>=k){a\n            for(int i = 1 ; i < k; i++){\n                ListNode next = tail.next.next;\n                tail.next.next = pre.next;\n                pre.next = tail.next;\n                tail.next = next;\n            }\n            pre = tail;\n            tail = tail.next;\n            n-=k;\n        }\n        return dummy.next;\n    }\n}\n```\n2. Backward Recursion\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n   public ListNode reverseKGroup(ListNode head, int k) {\n    ListNode curr = head;\n    int count = 0;\n    while (curr != null && count != k) {\n        curr = curr.next;\n        count++;\n    }\n    if (count == k) { \n        curr = reverseKGroup(curr, k); \n        while (count-- > 0) { \n            ListNode tmp = head.next; \n            head.next = curr;  \n            curr = head; \n            head = tmp; \n        }\n        head = curr;\n    }\n    return head;\n}\n}\n```\n3. Backward Iteration\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        // If less than k nodes, return directly\n        if(k<=1)return head;\n        List<ListNode> stack = new LinkedList<>();\n        int count = 0;\n        ListNode cur = head, lastHead = null;\n        int start = 0;\n        while(cur != null){\n            count++;\n            if(count % k == 1)stack.add(cur);\n            cur = cur.next;\n        }\n        start = stack.size()-1;\n        if(count < k)return head;\n        if(count % k != 0)\n        {\n            lastHead = stack.get(start--);\n        }\n        for(int i = start; i>=0; i--){\n            lastHead = reverseGroup(stack.get(i), lastHead, k);\n        }\n        return lastHead;\n    }\n    private ListNode reverseGroup(ListNode head, ListNode lastHead, int k){\n        ListNode cur = head, next = head.next;\n        while(k-- > 0){\n            cur.next = lastHead;\n            lastHead = cur;\n            cur = next;\n            if(cur != null)\n            next = cur.next;\n        }\n        return lastHead;\n    }\n    \n}\n```\n\n# Complexity\n\n**Time Complexity:** $O(n)$ All the solutions are linear since we have to traverse over the entire list.\n\n**Space Complexity:** For the forward iteration solution it's $O(1)$, for the other two, we need $O(\\lceil n/k \\rceil)$ to store the head node of all groups.\n\n","slug":"25-Reverse-Nodes-in-k-Group","published":1,"updated":"2020-05-03T06:14:50.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixra000ek4r3wy95cqvf","content":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>The very intuitive method to solve this problem is:</p>\n<ol>\n<li>splice the List into k nodes a group</li>\n<li>reverse the group list</li>\n<li>reconnect groups</li>\n</ol>\n<p>A simple implementation is recursion, first reverse the last group, return its head, and then reverse the group before the last one, set its tail to last group’s head and return current group head. The whole process goes until the first group is reversed and its tail is set, head is the final answer. The iteration version of this method is using a stack to store each group’s head, the algorithm goes similar.</p>\n<p>Another algorithm not so straight-forward I call it forward iteration. Because we don’t reverse the group from the last one to the first one, we reverse the first group and record it’s tail and next group’s head, and then connect them together.</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><ol>\n<li><p>Forward Iteration </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode reverseKGroup(ListNode head, int k) &#123;</span><br><span class=\"line\">        ListNode dummy = new ListNode(0);</span><br><span class=\"line\">        dummy.next = head;</span><br><span class=\"line\">        int n = 0;</span><br><span class=\"line\">        ListNode c = head;</span><br><span class=\"line\">        while(c!=null)&#123;</span><br><span class=\"line\">            n++;c=c.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode pre = dummy, tail = head;</span><br><span class=\"line\">        while(n&gt;=k)&#123;a</span><br><span class=\"line\">            for(int i = 1 ; i &lt; k; i++)&#123;</span><br><span class=\"line\">                ListNode next = tail.next.next;</span><br><span class=\"line\">                tail.next.next = pre.next;</span><br><span class=\"line\">                pre.next = tail.next;</span><br><span class=\"line\">                tail.next = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            pre = tail;</span><br><span class=\"line\">            tail = tail.next;</span><br><span class=\"line\">            n-=k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Backward Recursion</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">   public ListNode reverseKGroup(ListNode head, int k) &#123;</span><br><span class=\"line\">    ListNode curr = head;</span><br><span class=\"line\">    int count = 0;</span><br><span class=\"line\">    while (curr != null &amp;&amp; count != k) &#123;</span><br><span class=\"line\">        curr = curr.next;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (count == k) &#123; </span><br><span class=\"line\">        curr = reverseKGroup(curr, k); </span><br><span class=\"line\">        while (count-- &gt; 0) &#123; </span><br><span class=\"line\">            ListNode tmp = head.next; </span><br><span class=\"line\">            head.next = curr;  </span><br><span class=\"line\">            curr = head; </span><br><span class=\"line\">            head = tmp; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        head = curr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Backward Iteration</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode reverseKGroup(ListNode head, int k) &#123;</span><br><span class=\"line\">        // If less than k nodes, return directly</span><br><span class=\"line\">        if(k&lt;=1)return head;</span><br><span class=\"line\">        List&lt;ListNode&gt; stack = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        int count = 0;</span><br><span class=\"line\">        ListNode cur = head, lastHead = null;</span><br><span class=\"line\">        int start = 0;</span><br><span class=\"line\">        while(cur != null)&#123;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            if(count % k == 1)stack.add(cur);</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        start = stack.size()-1;</span><br><span class=\"line\">        if(count &lt; k)return head;</span><br><span class=\"line\">        if(count % k != 0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            lastHead = stack.get(start--);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for(int i = start; i&gt;=0; i--)&#123;</span><br><span class=\"line\">            lastHead = reverseGroup(stack.get(i), lastHead, k);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return lastHead;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private ListNode reverseGroup(ListNode head, ListNode lastHead, int k)&#123;</span><br><span class=\"line\">        ListNode cur = head, next = head.next;</span><br><span class=\"line\">        while(k-- &gt; 0)&#123;</span><br><span class=\"line\">            cur.next = lastHead;</span><br><span class=\"line\">            lastHead = cur;</span><br><span class=\"line\">            cur = next;</span><br><span class=\"line\">            if(cur != null)</span><br><span class=\"line\">            next = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return lastHead;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(n)$ All the solutions are linear since we have to traverse over the entire list.</p>\n<p><strong>Space Complexity:</strong> For the forward iteration solution it’s $O(1)$, for the other two, we need $O(\\lceil n/k \\rceil)$ to store the head node of all groups.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>The very intuitive method to solve this problem is:</p>\n<ol>\n<li>splice the List into k nodes a group</li>\n<li>reverse the group list</li>\n<li>reconnect groups</li>\n</ol>\n<p>A simple implementation is recursion, first reverse the last group, return its head, and then reverse the group before the last one, set its tail to last group’s head and return current group head. The whole process goes until the first group is reversed and its tail is set, head is the final answer. The iteration version of this method is using a stack to store each group’s head, the algorithm goes similar.</p>\n<p>Another algorithm not so straight-forward I call it forward iteration. Because we don’t reverse the group from the last one to the first one, we reverse the first group and record it’s tail and next group’s head, and then connect them together.</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><ol>\n<li><p>Forward Iteration </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode reverseKGroup(ListNode head, int k) &#123;</span><br><span class=\"line\">        ListNode dummy = new ListNode(0);</span><br><span class=\"line\">        dummy.next = head;</span><br><span class=\"line\">        int n = 0;</span><br><span class=\"line\">        ListNode c = head;</span><br><span class=\"line\">        while(c!=null)&#123;</span><br><span class=\"line\">            n++;c=c.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode pre = dummy, tail = head;</span><br><span class=\"line\">        while(n&gt;=k)&#123;a</span><br><span class=\"line\">            for(int i = 1 ; i &lt; k; i++)&#123;</span><br><span class=\"line\">                ListNode next = tail.next.next;</span><br><span class=\"line\">                tail.next.next = pre.next;</span><br><span class=\"line\">                pre.next = tail.next;</span><br><span class=\"line\">                tail.next = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            pre = tail;</span><br><span class=\"line\">            tail = tail.next;</span><br><span class=\"line\">            n-=k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Backward Recursion</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">   public ListNode reverseKGroup(ListNode head, int k) &#123;</span><br><span class=\"line\">    ListNode curr = head;</span><br><span class=\"line\">    int count = 0;</span><br><span class=\"line\">    while (curr != null &amp;&amp; count != k) &#123;</span><br><span class=\"line\">        curr = curr.next;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (count == k) &#123; </span><br><span class=\"line\">        curr = reverseKGroup(curr, k); </span><br><span class=\"line\">        while (count-- &gt; 0) &#123; </span><br><span class=\"line\">            ListNode tmp = head.next; </span><br><span class=\"line\">            head.next = curr;  </span><br><span class=\"line\">            curr = head; </span><br><span class=\"line\">            head = tmp; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        head = curr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Backward Iteration</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode reverseKGroup(ListNode head, int k) &#123;</span><br><span class=\"line\">        // If less than k nodes, return directly</span><br><span class=\"line\">        if(k&lt;=1)return head;</span><br><span class=\"line\">        List&lt;ListNode&gt; stack = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        int count = 0;</span><br><span class=\"line\">        ListNode cur = head, lastHead = null;</span><br><span class=\"line\">        int start = 0;</span><br><span class=\"line\">        while(cur != null)&#123;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            if(count % k == 1)stack.add(cur);</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        start = stack.size()-1;</span><br><span class=\"line\">        if(count &lt; k)return head;</span><br><span class=\"line\">        if(count % k != 0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            lastHead = stack.get(start--);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for(int i = start; i&gt;=0; i--)&#123;</span><br><span class=\"line\">            lastHead = reverseGroup(stack.get(i), lastHead, k);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return lastHead;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private ListNode reverseGroup(ListNode head, ListNode lastHead, int k)&#123;</span><br><span class=\"line\">        ListNode cur = head, next = head.next;</span><br><span class=\"line\">        while(k-- &gt; 0)&#123;</span><br><span class=\"line\">            cur.next = lastHead;</span><br><span class=\"line\">            lastHead = cur;</span><br><span class=\"line\">            cur = next;</span><br><span class=\"line\">            if(cur != null)</span><br><span class=\"line\">            next = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return lastHead;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(n)$ All the solutions are linear since we have to traverse over the entire list.</p>\n<p><strong>Space Complexity:</strong> For the forward iteration solution it’s $O(1)$, for the other two, we need $O(\\lceil n/k \\rceil)$ to store the head node of all groups.</p>\n"},{"title":"377 Combination Sum IV","date":"2019-11-20T05:42:42.000Z","comments":1,"_content":"# Intuition & Algorithm\nAt the first glampse of this question, I write down the dfs algorithm immediately. It works of course, but will encounter the `Time Exceed` error. The problem here is \nit costs too much time to search all the possible paths, there are duplicates. For example:\n> [1, 2, 3] target=6\n\nwhen we have picked 1 and 2, we need to find a combination summing to 3. When we have picked 3, again we need to find a combination whose sum is 3. So we do this subproblem multiple times\n> [1,2,3] target=3\n\nIt reminds us that dynamic programming can be used here. The state transition equation is:\n\n$$dp[target] = dp[target-nums[0]]+dp[target-nums[1]]+...+dp[target-nums[n]]$$\n\n\n# Code\n```\nclass Solution {\n\n    public int combinationSum4(int[] nums, int target) {\n        Arrays.sort(nums);\n        if(nums.length == 0 || nums[0] > target)\n            return 0;\n        int[] dp = new int[target + 1];\n        dp[nums[0]] = 1;\n        dp[0] = 1;\n        for(int i = nums[0]+1; i <= target;i++){\n            for(int j = 0; j < nums.length; j++){\n                if(i < nums[j])break;\n                dp[i] += dp[i-nums[j]];\n            } \n        }\n        return dp[target];\n    }\n   \n}\n```\n\n# Complexity\n**Time Complexity:** $O(target*n)$ Outter for loop iterates from nums[0] to target and inner for loop iterates over the array.\n\n**Space Complexity:** $O(target)$ The cost of `dp` arrray. \n","source":"_posts/377-Combination-Sum-IV.md","raw":"---\ntitle: 377 Combination Sum IV\ndate: 2019-11-20 13:42:42\ntags:\n- dynamic programming\ncategories:\n- LeetCode\ncomments: true\n---\n# Intuition & Algorithm\nAt the first glampse of this question, I write down the dfs algorithm immediately. It works of course, but will encounter the `Time Exceed` error. The problem here is \nit costs too much time to search all the possible paths, there are duplicates. For example:\n> [1, 2, 3] target=6\n\nwhen we have picked 1 and 2, we need to find a combination summing to 3. When we have picked 3, again we need to find a combination whose sum is 3. So we do this subproblem multiple times\n> [1,2,3] target=3\n\nIt reminds us that dynamic programming can be used here. The state transition equation is:\n\n$$dp[target] = dp[target-nums[0]]+dp[target-nums[1]]+...+dp[target-nums[n]]$$\n\n\n# Code\n```\nclass Solution {\n\n    public int combinationSum4(int[] nums, int target) {\n        Arrays.sort(nums);\n        if(nums.length == 0 || nums[0] > target)\n            return 0;\n        int[] dp = new int[target + 1];\n        dp[nums[0]] = 1;\n        dp[0] = 1;\n        for(int i = nums[0]+1; i <= target;i++){\n            for(int j = 0; j < nums.length; j++){\n                if(i < nums[j])break;\n                dp[i] += dp[i-nums[j]];\n            } \n        }\n        return dp[target];\n    }\n   \n}\n```\n\n# Complexity\n**Time Complexity:** $O(target*n)$ Outter for loop iterates from nums[0] to target and inner for loop iterates over the array.\n\n**Space Complexity:** $O(target)$ The cost of `dp` arrray. \n","slug":"377-Combination-Sum-IV","published":1,"updated":"2020-05-03T06:14:50.674Z","layout":"post","photos":[],"link":"","_id":"cka27ixrc000fk4r3jnnhkyzj","content":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>At the first glampse of this question, I write down the dfs algorithm immediately. It works of course, but will encounter the <code>Time Exceed</code> error. The problem here is<br>it costs too much time to search all the possible paths, there are duplicates. For example:</p>\n<blockquote>\n<p>[1, 2, 3] target=6</p>\n</blockquote>\n<p>when we have picked 1 and 2, we need to find a combination summing to 3. When we have picked 3, again we need to find a combination whose sum is 3. So we do this subproblem multiple times</p>\n<blockquote>\n<p>[1,2,3] target=3</p>\n</blockquote>\n<p>It reminds us that dynamic programming can be used here. The state transition equation is:</p>\n<script type=\"math/tex; mode=display\">dp[target] = dp[target-nums[0]]+dp[target-nums[1]]+...+dp[target-nums[n]]</script><h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int combinationSum4(int[] nums, int target) &#123;</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        if(nums.length == 0 || nums[0] &gt; target)</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        int[] dp = new int[target + 1];</span><br><span class=\"line\">        dp[nums[0]] = 1;</span><br><span class=\"line\">        dp[0] = 1;</span><br><span class=\"line\">        for(int i = nums[0]+1; i &lt;= target;i++)&#123;</span><br><span class=\"line\">            for(int j = 0; j &lt; nums.length; j++)&#123;</span><br><span class=\"line\">                if(i &lt; nums[j])break;</span><br><span class=\"line\">                dp[i] += dp[i-nums[j]];</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[target];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(target*n)$ Outter for loop iterates from nums[0] to target and inner for loop iterates over the array.</p>\n<p><strong>Space Complexity:</strong> $O(target)$ The cost of <code>dp</code> arrray. </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>At the first glampse of this question, I write down the dfs algorithm immediately. It works of course, but will encounter the <code>Time Exceed</code> error. The problem here is<br>it costs too much time to search all the possible paths, there are duplicates. For example:</p>\n<blockquote>\n<p>[1, 2, 3] target=6</p>\n</blockquote>\n<p>when we have picked 1 and 2, we need to find a combination summing to 3. When we have picked 3, again we need to find a combination whose sum is 3. So we do this subproblem multiple times</p>\n<blockquote>\n<p>[1,2,3] target=3</p>\n</blockquote>\n<p>It reminds us that dynamic programming can be used here. The state transition equation is:</p>\n<script type=\"math/tex; mode=display\">dp[target] = dp[target-nums[0]]+dp[target-nums[1]]+...+dp[target-nums[n]]</script><h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int combinationSum4(int[] nums, int target) &#123;</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        if(nums.length == 0 || nums[0] &gt; target)</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        int[] dp = new int[target + 1];</span><br><span class=\"line\">        dp[nums[0]] = 1;</span><br><span class=\"line\">        dp[0] = 1;</span><br><span class=\"line\">        for(int i = nums[0]+1; i &lt;= target;i++)&#123;</span><br><span class=\"line\">            for(int j = 0; j &lt; nums.length; j++)&#123;</span><br><span class=\"line\">                if(i &lt; nums[j])break;</span><br><span class=\"line\">                dp[i] += dp[i-nums[j]];</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[target];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(target*n)$ Outter for loop iterates from nums[0] to target and inner for loop iterates over the array.</p>\n<p><strong>Space Complexity:</strong> $O(target)$ The cost of <code>dp</code> arrray. </p>\n"},{"title":"23 Merge k Sorted Lists","date":"2019-11-27T06:36:20.000Z","_content":"# Intuition \nThis seems to be a general question of merging two sorted lists. The naive method of this question is quite intuitive. If you are interested in more efficient solutions, skip to `Partition Algorithm` and `Heap Algorithm` directly. Let's look at the example below to illustrate our naive method.\n>Input: <br>\n[<br>\n  1->4->5,<br>\n  1->3->4,<br>\n  2->6<br>\n]<br>\nOutput: 1->1->2->3->4->4->5->6<br>\n\nLet's start with a `dummy` node to represent our final list. The next node of `dummy` should be the minimum one from three headers: 1,1,2, it's the first header or the second one, either is ok, let's take the first one in this case. And we should move the header of the first list to its next one. \n\n>lists: <br>\n[<br>\n  4->5,<br>\n  1->3->4,<br>\n  2->6<br>\n]<br>\nans: -1(dummy)->1<br>\n\nThen we pick the minimum node from lists into `ans` list again. It's the head node from second list.\n>lists: <br>\n[<br>\n  4->5,<br>\n  3->4,<br>\n  2->6<br>\n]<br>\nans: -1(dummy)->1->1<br>\n\nWe do this `N` times in total. We compare `k` headers each time. where `k` is the number of lists to be merged. So time complexity is $O(Nk)$ in this method.\n\n# Heap Algorithm\nWhere is the bottleneck of naive method? We have to pick `N` nodes, so the time complexity must be $O(N*X)$. Can we reduce X from `k` to something smaller than it? The answer is yes. Review the process when we pick a node, we pick it from k nodes, and then change one of the k nodes, other k-1 nodes remains the same. In this circumstance\n, heap is a perfect data structure. The query complexity and insert complexity for a small root queue are $O(logk)$ instead of $O(k)$ in the naive method.\n# Partition Algorithm\nDon't forget it's a merge sortion question although this is for lists. Recall that how do we merge sorted arrays, every two of them are merged into one sorted array, and then we merge the new arrays with half number of previous one. Finally, we merge two sorted array. Actually, this is the same case for lists. Each time we merge every two of them, they will be merged into one after $log(k)$ times. So the time complexity is $O(Nlogk)$.  \n# Code\n1. Heap Algorithm\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> heap = new PriorityQueue<>(new Comparator<ListNode>(){\n            public int compare(ListNode n1, ListNode n2){\n                if(n1.val < n2.val){\n                    return -1;\n                }\n                else if(n1.val == n2.val){\n                    return 0;\n                }\n                else\n                    return 1;\n            }}\n        );\n        for(ListNode n : lists){\n            if(n != null)\n                heap.add(n);\n        }\n        ListNode dummy = new ListNode(-1), cur = dummy;\n        while(heap.size() > 0){\n            cur.next = heap.poll();\n            cur = cur.next;\n            if(cur.next != null){\n                heap.add(cur.next);\n            }\n        }\n        return dummy.next;\n    }\n}\n\n```\n2. Partition Algorithm\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if(lists.length == 0)return null;\n        List<ListNode> pool = new ArrayList<ListNode>(Arrays.asList(lists));\n        while(pool.size() > 1){\n            pool = merge(pool);\n        }\n        return pool.get(0);\n    }\n    private List<ListNode> merge(List<ListNode> pool){\n        List<ListNode> res = new ArrayList<ListNode>();\n        for(int i = 0; i< pool.size(); i+=2){\n            if(i == pool.size()-1){\n                res.add(pool.get(i));\n                break;\n            }\n            res.add(mergeTwoLists(pool.get(i), pool.get(i+1)));\n        }\n        return res;\n    }\n    private ListNode mergeTwoLists(ListNode list1, ListNode list2){\n        if(list1 == null) return list2;\n        if(list2 == null) return list1;\n        ListNode dummy = new ListNode(0), cur = dummy;\n        while(list1 != null && list2 != null){\n            if(list1.val < list2.val)\n            {\n                cur.next = list1;\n                list1 = list1.next;\n            }\n            else{\n                cur.next = list2;\n                list2 = list2.next;\n            }\n            cur = cur.next;\n        }\n        if(list1 == null){\n            cur.next = list2;\n        }\n        else{\n            cur.next = list1;\n        }\n        return dummy.next;\n    }\n}\n```\n# Complexity\n**Time Complexity:** $O(Nlog(k))$ See explanations in Algorithm sections.\n\n**Space Complexity:** $O(k)$ for the heap\n","source":"_posts/23-Merge-k-Sorted-Lists.md","raw":"---\ntitle: 23 Merge k Sorted Lists\ndate: 2019-11-27 14:36:20\ntags:\n- list\ncategories:\n- LeetCode\n---\n# Intuition \nThis seems to be a general question of merging two sorted lists. The naive method of this question is quite intuitive. If you are interested in more efficient solutions, skip to `Partition Algorithm` and `Heap Algorithm` directly. Let's look at the example below to illustrate our naive method.\n>Input: <br>\n[<br>\n  1->4->5,<br>\n  1->3->4,<br>\n  2->6<br>\n]<br>\nOutput: 1->1->2->3->4->4->5->6<br>\n\nLet's start with a `dummy` node to represent our final list. The next node of `dummy` should be the minimum one from three headers: 1,1,2, it's the first header or the second one, either is ok, let's take the first one in this case. And we should move the header of the first list to its next one. \n\n>lists: <br>\n[<br>\n  4->5,<br>\n  1->3->4,<br>\n  2->6<br>\n]<br>\nans: -1(dummy)->1<br>\n\nThen we pick the minimum node from lists into `ans` list again. It's the head node from second list.\n>lists: <br>\n[<br>\n  4->5,<br>\n  3->4,<br>\n  2->6<br>\n]<br>\nans: -1(dummy)->1->1<br>\n\nWe do this `N` times in total. We compare `k` headers each time. where `k` is the number of lists to be merged. So time complexity is $O(Nk)$ in this method.\n\n# Heap Algorithm\nWhere is the bottleneck of naive method? We have to pick `N` nodes, so the time complexity must be $O(N*X)$. Can we reduce X from `k` to something smaller than it? The answer is yes. Review the process when we pick a node, we pick it from k nodes, and then change one of the k nodes, other k-1 nodes remains the same. In this circumstance\n, heap is a perfect data structure. The query complexity and insert complexity for a small root queue are $O(logk)$ instead of $O(k)$ in the naive method.\n# Partition Algorithm\nDon't forget it's a merge sortion question although this is for lists. Recall that how do we merge sorted arrays, every two of them are merged into one sorted array, and then we merge the new arrays with half number of previous one. Finally, we merge two sorted array. Actually, this is the same case for lists. Each time we merge every two of them, they will be merged into one after $log(k)$ times. So the time complexity is $O(Nlogk)$.  \n# Code\n1. Heap Algorithm\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> heap = new PriorityQueue<>(new Comparator<ListNode>(){\n            public int compare(ListNode n1, ListNode n2){\n                if(n1.val < n2.val){\n                    return -1;\n                }\n                else if(n1.val == n2.val){\n                    return 0;\n                }\n                else\n                    return 1;\n            }}\n        );\n        for(ListNode n : lists){\n            if(n != null)\n                heap.add(n);\n        }\n        ListNode dummy = new ListNode(-1), cur = dummy;\n        while(heap.size() > 0){\n            cur.next = heap.poll();\n            cur = cur.next;\n            if(cur.next != null){\n                heap.add(cur.next);\n            }\n        }\n        return dummy.next;\n    }\n}\n\n```\n2. Partition Algorithm\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if(lists.length == 0)return null;\n        List<ListNode> pool = new ArrayList<ListNode>(Arrays.asList(lists));\n        while(pool.size() > 1){\n            pool = merge(pool);\n        }\n        return pool.get(0);\n    }\n    private List<ListNode> merge(List<ListNode> pool){\n        List<ListNode> res = new ArrayList<ListNode>();\n        for(int i = 0; i< pool.size(); i+=2){\n            if(i == pool.size()-1){\n                res.add(pool.get(i));\n                break;\n            }\n            res.add(mergeTwoLists(pool.get(i), pool.get(i+1)));\n        }\n        return res;\n    }\n    private ListNode mergeTwoLists(ListNode list1, ListNode list2){\n        if(list1 == null) return list2;\n        if(list2 == null) return list1;\n        ListNode dummy = new ListNode(0), cur = dummy;\n        while(list1 != null && list2 != null){\n            if(list1.val < list2.val)\n            {\n                cur.next = list1;\n                list1 = list1.next;\n            }\n            else{\n                cur.next = list2;\n                list2 = list2.next;\n            }\n            cur = cur.next;\n        }\n        if(list1 == null){\n            cur.next = list2;\n        }\n        else{\n            cur.next = list1;\n        }\n        return dummy.next;\n    }\n}\n```\n# Complexity\n**Time Complexity:** $O(Nlog(k))$ See explanations in Algorithm sections.\n\n**Space Complexity:** $O(k)$ for the heap\n","slug":"23-Merge-k-Sorted-Lists","published":1,"updated":"2020-05-03T06:14:50.673Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixrd000gk4r321lhatpo","content":"<h1 id=\"Intuition\"><a href=\"#Intuition\" class=\"headerlink\" title=\"Intuition\"></a>Intuition</h1><p>This seems to be a general question of merging two sorted lists. The naive method of this question is quite intuitive. If you are interested in more efficient solutions, skip to <code>Partition Algorithm</code> and <code>Heap Algorithm</code> directly. Let’s look at the example below to illustrate our naive method.</p>\n<blockquote>\n<p>Input: <br><br>[<br><br>  1-&gt;4-&gt;5,<br><br>  1-&gt;3-&gt;4,<br><br>  2-&gt;6<br><br>]<br><br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br></p>\n</blockquote>\n<p>Let’s start with a <code>dummy</code> node to represent our final list. The next node of <code>dummy</code> should be the minimum one from three headers: 1,1,2, it’s the first header or the second one, either is ok, let’s take the first one in this case. And we should move the header of the first list to its next one. </p>\n<blockquote>\n<p>lists: <br><br>[<br><br>  4-&gt;5,<br><br>  1-&gt;3-&gt;4,<br><br>  2-&gt;6<br><br>]<br><br>ans: -1(dummy)-&gt;1<br></p>\n</blockquote>\n<p>Then we pick the minimum node from lists into <code>ans</code> list again. It’s the head node from second list.</p>\n<blockquote>\n<p>lists: <br><br>[<br><br>  4-&gt;5,<br><br>  3-&gt;4,<br><br>  2-&gt;6<br><br>]<br><br>ans: -1(dummy)-&gt;1-&gt;1<br></p>\n</blockquote>\n<p>We do this <code>N</code> times in total. We compare <code>k</code> headers each time. where <code>k</code> is the number of lists to be merged. So time complexity is $O(Nk)$ in this method.</p>\n<h1 id=\"Heap-Algorithm\"><a href=\"#Heap-Algorithm\" class=\"headerlink\" title=\"Heap Algorithm\"></a>Heap Algorithm</h1><p>Where is the bottleneck of naive method? We have to pick <code>N</code> nodes, so the time complexity must be $O(N*X)$. Can we reduce X from <code>k</code> to something smaller than it? The answer is yes. Review the process when we pick a node, we pick it from k nodes, and then change one of the k nodes, other k-1 nodes remains the same. In this circumstance<br>, heap is a perfect data structure. The query complexity and insert complexity for a small root queue are $O(logk)$ instead of $O(k)$ in the naive method.</p>\n<h1 id=\"Partition-Algorithm\"><a href=\"#Partition-Algorithm\" class=\"headerlink\" title=\"Partition Algorithm\"></a>Partition Algorithm</h1><p>Don’t forget it’s a merge sortion question although this is for lists. Recall that how do we merge sorted arrays, every two of them are merged into one sorted array, and then we merge the new arrays with half number of previous one. Finally, we merge two sorted array. Actually, this is the same case for lists. Each time we merge every two of them, they will be merged into one after $log(k)$ times. So the time complexity is $O(Nlogk)$.  </p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><ol>\n<li><p>Heap Algorithm</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode mergeKLists(ListNode[] lists) &#123;</span><br><span class=\"line\">        PriorityQueue&lt;ListNode&gt; heap = new PriorityQueue&lt;&gt;(new Comparator&lt;ListNode&gt;()&#123;</span><br><span class=\"line\">            public int compare(ListNode n1, ListNode n2)&#123;</span><br><span class=\"line\">                if(n1.val &lt; n2.val)&#123;</span><br><span class=\"line\">                    return -1;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                else if(n1.val == n2.val)&#123;</span><br><span class=\"line\">                    return 0;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    return 1;</span><br><span class=\"line\">            &#125;&#125;</span><br><span class=\"line\">        );</span><br><span class=\"line\">        for(ListNode n : lists)&#123;</span><br><span class=\"line\">            if(n != null)</span><br><span class=\"line\">                heap.add(n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode dummy = new ListNode(-1), cur = dummy;</span><br><span class=\"line\">        while(heap.size() &gt; 0)&#123;</span><br><span class=\"line\">            cur.next = heap.poll();</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">            if(cur.next != null)&#123;</span><br><span class=\"line\">                heap.add(cur.next);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Partition Algorithm</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode mergeKLists(ListNode[] lists) &#123;</span><br><span class=\"line\">        if(lists.length == 0)return null;</span><br><span class=\"line\">        List&lt;ListNode&gt; pool = new ArrayList&lt;ListNode&gt;(Arrays.asList(lists));</span><br><span class=\"line\">        while(pool.size() &gt; 1)&#123;</span><br><span class=\"line\">            pool = merge(pool);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return pool.get(0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private List&lt;ListNode&gt; merge(List&lt;ListNode&gt; pool)&#123;</span><br><span class=\"line\">        List&lt;ListNode&gt; res = new ArrayList&lt;ListNode&gt;();</span><br><span class=\"line\">        for(int i = 0; i&lt; pool.size(); i+=2)&#123;</span><br><span class=\"line\">            if(i == pool.size()-1)&#123;</span><br><span class=\"line\">                res.add(pool.get(i));</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.add(mergeTwoLists(pool.get(i), pool.get(i+1)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private ListNode mergeTwoLists(ListNode list1, ListNode list2)&#123;</span><br><span class=\"line\">        if(list1 == null) return list2;</span><br><span class=\"line\">        if(list2 == null) return list1;</span><br><span class=\"line\">        ListNode dummy = new ListNode(0), cur = dummy;</span><br><span class=\"line\">        while(list1 != null &amp;&amp; list2 != null)&#123;</span><br><span class=\"line\">            if(list1.val &lt; list2.val)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cur.next = list1;</span><br><span class=\"line\">                list1 = list1.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else&#123;</span><br><span class=\"line\">                cur.next = list2;</span><br><span class=\"line\">                list2 = list2.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(list1 == null)&#123;</span><br><span class=\"line\">            cur.next = list2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else&#123;</span><br><span class=\"line\">            cur.next = list1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(Nlog(k))$ See explanations in Algorithm sections.</p>\n<p><strong>Space Complexity:</strong> $O(k)$ for the heap</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition\"><a href=\"#Intuition\" class=\"headerlink\" title=\"Intuition\"></a>Intuition</h1><p>This seems to be a general question of merging two sorted lists. The naive method of this question is quite intuitive. If you are interested in more efficient solutions, skip to <code>Partition Algorithm</code> and <code>Heap Algorithm</code> directly. Let’s look at the example below to illustrate our naive method.</p>\n<blockquote>\n<p>Input: <br><br>[<br><br>  1-&gt;4-&gt;5,<br><br>  1-&gt;3-&gt;4,<br><br>  2-&gt;6<br><br>]<br><br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br></p>\n</blockquote>\n<p>Let’s start with a <code>dummy</code> node to represent our final list. The next node of <code>dummy</code> should be the minimum one from three headers: 1,1,2, it’s the first header or the second one, either is ok, let’s take the first one in this case. And we should move the header of the first list to its next one. </p>\n<blockquote>\n<p>lists: <br><br>[<br><br>  4-&gt;5,<br><br>  1-&gt;3-&gt;4,<br><br>  2-&gt;6<br><br>]<br><br>ans: -1(dummy)-&gt;1<br></p>\n</blockquote>\n<p>Then we pick the minimum node from lists into <code>ans</code> list again. It’s the head node from second list.</p>\n<blockquote>\n<p>lists: <br><br>[<br><br>  4-&gt;5,<br><br>  3-&gt;4,<br><br>  2-&gt;6<br><br>]<br><br>ans: -1(dummy)-&gt;1-&gt;1<br></p>\n</blockquote>\n<p>We do this <code>N</code> times in total. We compare <code>k</code> headers each time. where <code>k</code> is the number of lists to be merged. So time complexity is $O(Nk)$ in this method.</p>\n<h1 id=\"Heap-Algorithm\"><a href=\"#Heap-Algorithm\" class=\"headerlink\" title=\"Heap Algorithm\"></a>Heap Algorithm</h1><p>Where is the bottleneck of naive method? We have to pick <code>N</code> nodes, so the time complexity must be $O(N*X)$. Can we reduce X from <code>k</code> to something smaller than it? The answer is yes. Review the process when we pick a node, we pick it from k nodes, and then change one of the k nodes, other k-1 nodes remains the same. In this circumstance<br>, heap is a perfect data structure. The query complexity and insert complexity for a small root queue are $O(logk)$ instead of $O(k)$ in the naive method.</p>\n<h1 id=\"Partition-Algorithm\"><a href=\"#Partition-Algorithm\" class=\"headerlink\" title=\"Partition Algorithm\"></a>Partition Algorithm</h1><p>Don’t forget it’s a merge sortion question although this is for lists. Recall that how do we merge sorted arrays, every two of them are merged into one sorted array, and then we merge the new arrays with half number of previous one. Finally, we merge two sorted array. Actually, this is the same case for lists. Each time we merge every two of them, they will be merged into one after $log(k)$ times. So the time complexity is $O(Nlogk)$.  </p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><ol>\n<li><p>Heap Algorithm</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode mergeKLists(ListNode[] lists) &#123;</span><br><span class=\"line\">        PriorityQueue&lt;ListNode&gt; heap = new PriorityQueue&lt;&gt;(new Comparator&lt;ListNode&gt;()&#123;</span><br><span class=\"line\">            public int compare(ListNode n1, ListNode n2)&#123;</span><br><span class=\"line\">                if(n1.val &lt; n2.val)&#123;</span><br><span class=\"line\">                    return -1;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                else if(n1.val == n2.val)&#123;</span><br><span class=\"line\">                    return 0;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    return 1;</span><br><span class=\"line\">            &#125;&#125;</span><br><span class=\"line\">        );</span><br><span class=\"line\">        for(ListNode n : lists)&#123;</span><br><span class=\"line\">            if(n != null)</span><br><span class=\"line\">                heap.add(n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode dummy = new ListNode(-1), cur = dummy;</span><br><span class=\"line\">        while(heap.size() &gt; 0)&#123;</span><br><span class=\"line\">            cur.next = heap.poll();</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">            if(cur.next != null)&#123;</span><br><span class=\"line\">                heap.add(cur.next);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Partition Algorithm</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode mergeKLists(ListNode[] lists) &#123;</span><br><span class=\"line\">        if(lists.length == 0)return null;</span><br><span class=\"line\">        List&lt;ListNode&gt; pool = new ArrayList&lt;ListNode&gt;(Arrays.asList(lists));</span><br><span class=\"line\">        while(pool.size() &gt; 1)&#123;</span><br><span class=\"line\">            pool = merge(pool);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return pool.get(0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private List&lt;ListNode&gt; merge(List&lt;ListNode&gt; pool)&#123;</span><br><span class=\"line\">        List&lt;ListNode&gt; res = new ArrayList&lt;ListNode&gt;();</span><br><span class=\"line\">        for(int i = 0; i&lt; pool.size(); i+=2)&#123;</span><br><span class=\"line\">            if(i == pool.size()-1)&#123;</span><br><span class=\"line\">                res.add(pool.get(i));</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.add(mergeTwoLists(pool.get(i), pool.get(i+1)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private ListNode mergeTwoLists(ListNode list1, ListNode list2)&#123;</span><br><span class=\"line\">        if(list1 == null) return list2;</span><br><span class=\"line\">        if(list2 == null) return list1;</span><br><span class=\"line\">        ListNode dummy = new ListNode(0), cur = dummy;</span><br><span class=\"line\">        while(list1 != null &amp;&amp; list2 != null)&#123;</span><br><span class=\"line\">            if(list1.val &lt; list2.val)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cur.next = list1;</span><br><span class=\"line\">                list1 = list1.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else&#123;</span><br><span class=\"line\">                cur.next = list2;</span><br><span class=\"line\">                list2 = list2.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(list1 == null)&#123;</span><br><span class=\"line\">            cur.next = list2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else&#123;</span><br><span class=\"line\">            cur.next = list1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(Nlog(k))$ See explanations in Algorithm sections.</p>\n<p><strong>Space Complexity:</strong> $O(k)$ for the heap</p>\n"},{"title":"39 Combination Sum","date":"2019-11-18T16:08:36.000Z","comments":1,"_content":"# Intuition && Algorithm\nIt's `dfs`+`dynamic programming` problem. To get all the possible combination adding up to the target, we need to solve several subproblems. Before all, let's think about when will there be no solution set for this problem. The naive idea is to sort the array, if the first number is less than target there will be no solution.\n\nLet's look at an example and see how to solve it.\n> Input: candidates = [2,3,6,7], target = 7, \n<br/>A solution set is:\n[\n  [7],\n  [2,2,3]\n]\n\nFirst, suppose there is a `2` in one possible solution(one path if considering dfs), and then we need to solve a combination sum of target `5`(7-2=5) and the same candidates problem. When the target is equal to one candidate, we find a solution(path). But if this target is smaller than the first value, then this is not a possible solution. We can use a formula to describe this solution.\n\n$$S(target)=S(target-candidate[0])+S(target-candidate[1])+...+S(target-candidate[n])$$\n\n$S(i)$ denotes a solution set, it can be empty.\n\nBy far, this is a typic process for solving `dfs`+`dynamic programming` problem. But we ignored one import thing, the solutions in solution set can't be duplicated. For the example above, $S(7)=S(5)+S(4)+S(1)+[7]$, and $S(5)=[2,3]$ $S(4)=[2,2]$, both of them give the same solution indeed $[2,2,3]=[3,2,2]$. Duplicated solution occurs because we can choose value in any sequence. If we are only allowed to choose them in non-decreasing order, duplicates can be avoided. In this case only $[2,2,3]$ is allowed.\n# Code\n```\nclass Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        return findSolutionSet(candidates, target, 0);\n    }\n    private List<List<Integer>> findSolutionSet(int[] candidates, int target, int pre){\n        List<List<Integer>> ans = new ArrayList<>();\n        // terminate condition\n        if(target < candidates[0])\n            return ans;\n        for(int i = 0; i < candidates.length; i++){           \n            int cur = candidates[i];\n            if(cur < target && cur >= pre){\n                List<List<Integer>> preRes = findSolutionSet(candidates, target - cur, cur);\n                if(preRes.size() > 0){\n                    for(List<Integer> r: preRes){\n                        r.add(cur);\n                        ans.add(r);\n                    }\n                }\n            }\n            else if(cur == target && cur >= pre){\n                List<Integer> t = new ArrayList<>();\n                t.add(cur);\n                ans.add(t);\n\n            }\n        }\n        return ans;\n    }\n}\n```\n\n# Complexity\n\n**Time Complexity:** Time Complexity for sorting an array is $O(nlogn)$ and for dynamic programming portion it's about $O(n^{target})$. You can get the approximate time complexity from the equation for solving this problem above, all the possible solutions construct a tree. \n\n**Space Complexity:** From the equation above, we can simply think it as $O(target)$ since the solution set has `target` member in the worst case.\n","source":"_posts/39-Combination-Sum.md","raw":"---\ntitle: 39 Combination Sum\ndate: 2019-11-19 00:08:36\ntags:\n- dfs\n- dynamic programming\ncategories:\n- LeetCode\ncomments: true\n---\n# Intuition && Algorithm\nIt's `dfs`+`dynamic programming` problem. To get all the possible combination adding up to the target, we need to solve several subproblems. Before all, let's think about when will there be no solution set for this problem. The naive idea is to sort the array, if the first number is less than target there will be no solution.\n\nLet's look at an example and see how to solve it.\n> Input: candidates = [2,3,6,7], target = 7, \n<br/>A solution set is:\n[\n  [7],\n  [2,2,3]\n]\n\nFirst, suppose there is a `2` in one possible solution(one path if considering dfs), and then we need to solve a combination sum of target `5`(7-2=5) and the same candidates problem. When the target is equal to one candidate, we find a solution(path). But if this target is smaller than the first value, then this is not a possible solution. We can use a formula to describe this solution.\n\n$$S(target)=S(target-candidate[0])+S(target-candidate[1])+...+S(target-candidate[n])$$\n\n$S(i)$ denotes a solution set, it can be empty.\n\nBy far, this is a typic process for solving `dfs`+`dynamic programming` problem. But we ignored one import thing, the solutions in solution set can't be duplicated. For the example above, $S(7)=S(5)+S(4)+S(1)+[7]$, and $S(5)=[2,3]$ $S(4)=[2,2]$, both of them give the same solution indeed $[2,2,3]=[3,2,2]$. Duplicated solution occurs because we can choose value in any sequence. If we are only allowed to choose them in non-decreasing order, duplicates can be avoided. In this case only $[2,2,3]$ is allowed.\n# Code\n```\nclass Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        return findSolutionSet(candidates, target, 0);\n    }\n    private List<List<Integer>> findSolutionSet(int[] candidates, int target, int pre){\n        List<List<Integer>> ans = new ArrayList<>();\n        // terminate condition\n        if(target < candidates[0])\n            return ans;\n        for(int i = 0; i < candidates.length; i++){           \n            int cur = candidates[i];\n            if(cur < target && cur >= pre){\n                List<List<Integer>> preRes = findSolutionSet(candidates, target - cur, cur);\n                if(preRes.size() > 0){\n                    for(List<Integer> r: preRes){\n                        r.add(cur);\n                        ans.add(r);\n                    }\n                }\n            }\n            else if(cur == target && cur >= pre){\n                List<Integer> t = new ArrayList<>();\n                t.add(cur);\n                ans.add(t);\n\n            }\n        }\n        return ans;\n    }\n}\n```\n\n# Complexity\n\n**Time Complexity:** Time Complexity for sorting an array is $O(nlogn)$ and for dynamic programming portion it's about $O(n^{target})$. You can get the approximate time complexity from the equation for solving this problem above, all the possible solutions construct a tree. \n\n**Space Complexity:** From the equation above, we can simply think it as $O(target)$ since the solution set has `target` member in the worst case.\n","slug":"39-Combination-Sum","published":1,"updated":"2020-05-03T06:14:50.674Z","layout":"post","photos":[],"link":"","_id":"cka27ixre000hk4r3hmfezy6k","content":"<h1 id=\"Intuition-amp-amp-Algorithm\"><a href=\"#Intuition-amp-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp;&amp; Algorithm\"></a>Intuition &amp;&amp; Algorithm</h1><p>It’s <code>dfs</code>+<code>dynamic programming</code> problem. To get all the possible combination adding up to the target, we need to solve several subproblems. Before all, let’s think about when will there be no solution set for this problem. The naive idea is to sort the array, if the first number is less than target there will be no solution.</p>\n<p>Let’s look at an example and see how to solve it.</p>\n<blockquote>\n<p>Input: candidates = [2,3,6,7], target = 7,<br><br>A solution set is:<br>[<br>  [7],<br>  [2,2,3]<br>]</p>\n</blockquote>\n<p>First, suppose there is a <code>2</code> in one possible solution(one path if considering dfs), and then we need to solve a combination sum of target <code>5</code>(7-2=5) and the same candidates problem. When the target is equal to one candidate, we find a solution(path). But if this target is smaller than the first value, then this is not a possible solution. We can use a formula to describe this solution.</p>\n<script type=\"math/tex; mode=display\">S(target)=S(target-candidate[0])+S(target-candidate[1])+...+S(target-candidate[n])</script><p>$S(i)$ denotes a solution set, it can be empty.</p>\n<p>By far, this is a typic process for solving <code>dfs</code>+<code>dynamic programming</code> problem. But we ignored one import thing, the solutions in solution set can’t be duplicated. For the example above, $S(7)=S(5)+S(4)+S(1)+[7]$, and $S(5)=[2,3]$ $S(4)=[2,2]$, both of them give the same solution indeed $[2,2,3]=[3,2,2]$. Duplicated solution occurs because we can choose value in any sequence. If we are only allowed to choose them in non-decreasing order, duplicates can be avoided. In this case only $[2,2,3]$ is allowed.</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class=\"line\">        Arrays.sort(candidates);</span><br><span class=\"line\">        return findSolutionSet(candidates, target, 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private List&lt;List&lt;Integer&gt;&gt; findSolutionSet(int[] candidates, int target, int pre)&#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        // terminate condition</span><br><span class=\"line\">        if(target &lt; candidates[0])</span><br><span class=\"line\">            return ans;</span><br><span class=\"line\">        for(int i = 0; i &lt; candidates.length; i++)&#123;           </span><br><span class=\"line\">            int cur = candidates[i];</span><br><span class=\"line\">            if(cur &lt; target &amp;&amp; cur &gt;= pre)&#123;</span><br><span class=\"line\">                List&lt;List&lt;Integer&gt;&gt; preRes = findSolutionSet(candidates, target - cur, cur);</span><br><span class=\"line\">                if(preRes.size() &gt; 0)&#123;</span><br><span class=\"line\">                    for(List&lt;Integer&gt; r: preRes)&#123;</span><br><span class=\"line\">                        r.add(cur);</span><br><span class=\"line\">                        ans.add(r);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else if(cur == target &amp;&amp; cur &gt;= pre)&#123;</span><br><span class=\"line\">                List&lt;Integer&gt; t = new ArrayList&lt;&gt;();</span><br><span class=\"line\">                t.add(cur);</span><br><span class=\"line\">                ans.add(t);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> Time Complexity for sorting an array is $O(nlogn)$ and for dynamic programming portion it’s about $O(n^{target})$. You can get the approximate time complexity from the equation for solving this problem above, all the possible solutions construct a tree. </p>\n<p><strong>Space Complexity:</strong> From the equation above, we can simply think it as $O(target)$ since the solution set has <code>target</code> member in the worst case.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition-amp-amp-Algorithm\"><a href=\"#Intuition-amp-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp;&amp; Algorithm\"></a>Intuition &amp;&amp; Algorithm</h1><p>It’s <code>dfs</code>+<code>dynamic programming</code> problem. To get all the possible combination adding up to the target, we need to solve several subproblems. Before all, let’s think about when will there be no solution set for this problem. The naive idea is to sort the array, if the first number is less than target there will be no solution.</p>\n<p>Let’s look at an example and see how to solve it.</p>\n<blockquote>\n<p>Input: candidates = [2,3,6,7], target = 7,<br><br>A solution set is:<br>[<br>  [7],<br>  [2,2,3]<br>]</p>\n</blockquote>\n<p>First, suppose there is a <code>2</code> in one possible solution(one path if considering dfs), and then we need to solve a combination sum of target <code>5</code>(7-2=5) and the same candidates problem. When the target is equal to one candidate, we find a solution(path). But if this target is smaller than the first value, then this is not a possible solution. We can use a formula to describe this solution.</p>\n<script type=\"math/tex; mode=display\">S(target)=S(target-candidate[0])+S(target-candidate[1])+...+S(target-candidate[n])</script><p>$S(i)$ denotes a solution set, it can be empty.</p>\n<p>By far, this is a typic process for solving <code>dfs</code>+<code>dynamic programming</code> problem. But we ignored one import thing, the solutions in solution set can’t be duplicated. For the example above, $S(7)=S(5)+S(4)+S(1)+[7]$, and $S(5)=[2,3]$ $S(4)=[2,2]$, both of them give the same solution indeed $[2,2,3]=[3,2,2]$. Duplicated solution occurs because we can choose value in any sequence. If we are only allowed to choose them in non-decreasing order, duplicates can be avoided. In this case only $[2,2,3]$ is allowed.</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class=\"line\">        Arrays.sort(candidates);</span><br><span class=\"line\">        return findSolutionSet(candidates, target, 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private List&lt;List&lt;Integer&gt;&gt; findSolutionSet(int[] candidates, int target, int pre)&#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        // terminate condition</span><br><span class=\"line\">        if(target &lt; candidates[0])</span><br><span class=\"line\">            return ans;</span><br><span class=\"line\">        for(int i = 0; i &lt; candidates.length; i++)&#123;           </span><br><span class=\"line\">            int cur = candidates[i];</span><br><span class=\"line\">            if(cur &lt; target &amp;&amp; cur &gt;= pre)&#123;</span><br><span class=\"line\">                List&lt;List&lt;Integer&gt;&gt; preRes = findSolutionSet(candidates, target - cur, cur);</span><br><span class=\"line\">                if(preRes.size() &gt; 0)&#123;</span><br><span class=\"line\">                    for(List&lt;Integer&gt; r: preRes)&#123;</span><br><span class=\"line\">                        r.add(cur);</span><br><span class=\"line\">                        ans.add(r);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else if(cur == target &amp;&amp; cur &gt;= pre)&#123;</span><br><span class=\"line\">                List&lt;Integer&gt; t = new ArrayList&lt;&gt;();</span><br><span class=\"line\">                t.add(cur);</span><br><span class=\"line\">                ans.add(t);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> Time Complexity for sorting an array is $O(nlogn)$ and for dynamic programming portion it’s about $O(n^{target})$. You can get the approximate time complexity from the equation for solving this problem above, all the possible solutions construct a tree. </p>\n<p><strong>Space Complexity:</strong> From the equation above, we can simply think it as $O(target)$ since the solution set has <code>target</code> member in the worst case.</p>\n"},{"title":"46 Permutations","date":"2019-11-15T16:34:37.000Z","comments":1,"_content":"# Intuition & Algorithm\nIt's a dynamic programming question. Suppose we have get the permutations of i number, the `i+1`th number will be added to the previous solution set. For Each permution in the previous solution set, the `i+1`th number can be added to the first place, the second place,... or the last place. These new permutations will be added to the new solution set, and then add `i+2`th number. It's a little sophiscated to describe the state transition equation, so we will go through an example instead.\n\n> Given Numbers: [1,2,3]\n> The change of solution set:\n> 1. [[1]]\n> 2. [[2,1], [1,2]]\n> 3. [[3,2,1], [2,3,1], [2,1,3], [3,1,2], [1,3,2], [1,2,3]]\n\n# Code\n```\nclass Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        if(nums.length == 0) return ans;\n        List<Integer> temp = new ArrayList<>();\n        temp.add(nums[0]);\n        ans.add(temp);\n        \n        for(int i = 1; i < nums.length; i++){\n            List<List<Integer>> curAns = new ArrayList<List<Integer>>();\n            for(List<Integer> ele: ans){\n                for(int j = 0; j <= ele.size(); j++){\n                    List<Integer> data = new ArrayList<>();\n                    data.addAll(ele);\n                    /*\n                    for(int k = 0; k< ele.size(); k++){\n                        data.add(0);\n                    }\n                    Collections.copy(data, ele);*/\n                    data.add(j, nums[i]);\n                    curAns.add(data);\n                }\n            }\n            ans = curAns;\n        }\n        return ans;\n    }\n}\n```\n# Complexity\n\n**Time Complexity:** See the code above, when i = 1, the size of `ans` is 1 and the size of `ele` is 1. When i = n-1, `ans` size is (n-1)! and the size of `ele` is n-1. So the entire time complexity is $T(n)=1*1 + 2 * 2 + ...+ (n-1)!(n-1) $, it's about $O(n!)$\n\n**Space Complexity:** $O(n!)$ for storing all the permutations\n","source":"_posts/46-Permutations.md","raw":"---\ntitle: 46 Permutations\ndate: 2019-11-16 00:34:37\ncategories:\n- LeetCode\ncomments: true\ntags:\n- backtracking\n- dynamic programming\n---\n# Intuition & Algorithm\nIt's a dynamic programming question. Suppose we have get the permutations of i number, the `i+1`th number will be added to the previous solution set. For Each permution in the previous solution set, the `i+1`th number can be added to the first place, the second place,... or the last place. These new permutations will be added to the new solution set, and then add `i+2`th number. It's a little sophiscated to describe the state transition equation, so we will go through an example instead.\n\n> Given Numbers: [1,2,3]\n> The change of solution set:\n> 1. [[1]]\n> 2. [[2,1], [1,2]]\n> 3. [[3,2,1], [2,3,1], [2,1,3], [3,1,2], [1,3,2], [1,2,3]]\n\n# Code\n```\nclass Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        if(nums.length == 0) return ans;\n        List<Integer> temp = new ArrayList<>();\n        temp.add(nums[0]);\n        ans.add(temp);\n        \n        for(int i = 1; i < nums.length; i++){\n            List<List<Integer>> curAns = new ArrayList<List<Integer>>();\n            for(List<Integer> ele: ans){\n                for(int j = 0; j <= ele.size(); j++){\n                    List<Integer> data = new ArrayList<>();\n                    data.addAll(ele);\n                    /*\n                    for(int k = 0; k< ele.size(); k++){\n                        data.add(0);\n                    }\n                    Collections.copy(data, ele);*/\n                    data.add(j, nums[i]);\n                    curAns.add(data);\n                }\n            }\n            ans = curAns;\n        }\n        return ans;\n    }\n}\n```\n# Complexity\n\n**Time Complexity:** See the code above, when i = 1, the size of `ans` is 1 and the size of `ele` is 1. When i = n-1, `ans` size is (n-1)! and the size of `ele` is n-1. So the entire time complexity is $T(n)=1*1 + 2 * 2 + ...+ (n-1)!(n-1) $, it's about $O(n!)$\n\n**Space Complexity:** $O(n!)$ for storing all the permutations\n","slug":"46-Permutations","published":1,"updated":"2020-05-03T06:14:50.675Z","layout":"post","photos":[],"link":"","_id":"cka27ixrf000ik4r31yyvbksg","content":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>It’s a dynamic programming question. Suppose we have get the permutations of i number, the <code>i+1</code>th number will be added to the previous solution set. For Each permution in the previous solution set, the <code>i+1</code>th number can be added to the first place, the second place,… or the last place. These new permutations will be added to the new solution set, and then add <code>i+2</code>th number. It’s a little sophiscated to describe the state transition equation, so we will go through an example instead.</p>\n<blockquote>\n<p>Given Numbers: [1,2,3]<br>The change of solution set:</p>\n<ol>\n<li>[[1]]</li>\n<li>[[2,1], [1,2]]</li>\n<li>[[3,2,1], [2,3,1], [2,1,3], [3,1,2], [1,3,2], [1,2,3]]</li>\n</ol>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">        if(nums.length == 0) return ans;</span><br><span class=\"line\">        List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        temp.add(nums[0]);</span><br><span class=\"line\">        ans.add(temp);</span><br><span class=\"line\">        </span><br><span class=\"line\">        for(int i = 1; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">            List&lt;List&lt;Integer&gt;&gt; curAns = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">            for(List&lt;Integer&gt; ele: ans)&#123;</span><br><span class=\"line\">                for(int j = 0; j &lt;= ele.size(); j++)&#123;</span><br><span class=\"line\">                    List&lt;Integer&gt; data = new ArrayList&lt;&gt;();</span><br><span class=\"line\">                    data.addAll(ele);</span><br><span class=\"line\">                    /*</span><br><span class=\"line\">                    for(int k = 0; k&lt; ele.size(); k++)&#123;</span><br><span class=\"line\">                        data.add(0);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    Collections.copy(data, ele);*/</span><br><span class=\"line\">                    data.add(j, nums[i]);</span><br><span class=\"line\">                    curAns.add(data);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans = curAns;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> See the code above, when i = 1, the size of <code>ans</code> is 1 and the size of <code>ele</code> is 1. When i = n-1, <code>ans</code> size is (n-1)! and the size of <code>ele</code> is n-1. So the entire time complexity is $T(n)=1<em>1 + 2 </em> 2 + …+ (n-1)!(n-1) $, it’s about $O(n!)$</p>\n<p><strong>Space Complexity:</strong> $O(n!)$ for storing all the permutations</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>It’s a dynamic programming question. Suppose we have get the permutations of i number, the <code>i+1</code>th number will be added to the previous solution set. For Each permution in the previous solution set, the <code>i+1</code>th number can be added to the first place, the second place,… or the last place. These new permutations will be added to the new solution set, and then add <code>i+2</code>th number. It’s a little sophiscated to describe the state transition equation, so we will go through an example instead.</p>\n<blockquote>\n<p>Given Numbers: [1,2,3]<br>The change of solution set:</p>\n<ol>\n<li>[[1]]</li>\n<li>[[2,1], [1,2]]</li>\n<li>[[3,2,1], [2,3,1], [2,1,3], [3,1,2], [1,3,2], [1,2,3]]</li>\n</ol>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">        if(nums.length == 0) return ans;</span><br><span class=\"line\">        List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        temp.add(nums[0]);</span><br><span class=\"line\">        ans.add(temp);</span><br><span class=\"line\">        </span><br><span class=\"line\">        for(int i = 1; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">            List&lt;List&lt;Integer&gt;&gt; curAns = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">            for(List&lt;Integer&gt; ele: ans)&#123;</span><br><span class=\"line\">                for(int j = 0; j &lt;= ele.size(); j++)&#123;</span><br><span class=\"line\">                    List&lt;Integer&gt; data = new ArrayList&lt;&gt;();</span><br><span class=\"line\">                    data.addAll(ele);</span><br><span class=\"line\">                    /*</span><br><span class=\"line\">                    for(int k = 0; k&lt; ele.size(); k++)&#123;</span><br><span class=\"line\">                        data.add(0);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    Collections.copy(data, ele);*/</span><br><span class=\"line\">                    data.add(j, nums[i]);</span><br><span class=\"line\">                    curAns.add(data);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans = curAns;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> See the code above, when i = 1, the size of <code>ans</code> is 1 and the size of <code>ele</code> is 1. When i = n-1, <code>ans</code> size is (n-1)! and the size of <code>ele</code> is n-1. So the entire time complexity is $T(n)=1<em>1 + 2 </em> 2 + …+ (n-1)!(n-1) $, it’s about $O(n!)$</p>\n<p><strong>Space Complexity:</strong> $O(n!)$ for storing all the permutations</p>\n"},{"title":"24 Swap Nodes in Pairs","date":"2019-11-23T13:25:15.000Z","_content":"# Intuition & Algorithm\n>Question 25 is a more general question of this one.\n\nSuppose there are three pairs $p_0$, $p_1$ and $p_2$. We need to swap nodes in $p_1$, after that, we should reconnect it to it's adjacent pairs by:\n\n$$\np_0(1).next=p_1(0)\np_1(1).next=p_2(0)\n$$\n\nFor the first pair, $p_0(1)=null$ so we don't need the first equation and and for the last one, $p_2(0)=null$;\n# Code\n1. Recursion\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        return dp(head);\n    }\n    \n    private ListNode dp(ListNode head){\n        if(head == null || head.next == null)\n            return head;\n        ListNode next = head.next.next;\n        head.next.next = head;\n        head = head.next;\n        head.next.next = dp(next);\n        return head;\n    }\n}\n```\n\n2.Iteration\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null)\n            return head;\n        ListNode gH = head;\n        ListNode gT = head.next;\n        head = gT;\n        while(gH != null && gT != null){\n            ListNode tmp = gT.next;\n            gT.next = gH;\n            if(tmp != null && tmp.next != null){\n                gH.next = tmp.next;\n                gH = tmp; gT = tmp.next;\n            }\n            else{\n                gH.next = tmp;\n                gH = tmp; gT = null;\n            }\n        }\n        return head;\n    }\n}\n```\n\n# Complexity\n**Time Complexity:** $O(n)$ becasue we iterate over the entire list\n\n**Space Complexity:** For the recursion solution, $O(\\lceil n/2 \\rceil)$ space is necessary to store all the pairs. We cost constant space $O(1)$ for the iteration method.\n","source":"_posts/24-Swap-Nodes-in-Pairs.md","raw":"---\ntitle: 24 Swap Nodes in Pairs\ndate: 2019-11-23 21:25:15\ntags:\n- list\ncategories:\n- LeetCode\n---\n# Intuition & Algorithm\n>Question 25 is a more general question of this one.\n\nSuppose there are three pairs $p_0$, $p_1$ and $p_2$. We need to swap nodes in $p_1$, after that, we should reconnect it to it's adjacent pairs by:\n\n$$\np_0(1).next=p_1(0)\np_1(1).next=p_2(0)\n$$\n\nFor the first pair, $p_0(1)=null$ so we don't need the first equation and and for the last one, $p_2(0)=null$;\n# Code\n1. Recursion\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        return dp(head);\n    }\n    \n    private ListNode dp(ListNode head){\n        if(head == null || head.next == null)\n            return head;\n        ListNode next = head.next.next;\n        head.next.next = head;\n        head = head.next;\n        head.next.next = dp(next);\n        return head;\n    }\n}\n```\n\n2.Iteration\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null)\n            return head;\n        ListNode gH = head;\n        ListNode gT = head.next;\n        head = gT;\n        while(gH != null && gT != null){\n            ListNode tmp = gT.next;\n            gT.next = gH;\n            if(tmp != null && tmp.next != null){\n                gH.next = tmp.next;\n                gH = tmp; gT = tmp.next;\n            }\n            else{\n                gH.next = tmp;\n                gH = tmp; gT = null;\n            }\n        }\n        return head;\n    }\n}\n```\n\n# Complexity\n**Time Complexity:** $O(n)$ becasue we iterate over the entire list\n\n**Space Complexity:** For the recursion solution, $O(\\lceil n/2 \\rceil)$ space is necessary to store all the pairs. We cost constant space $O(1)$ for the iteration method.\n","slug":"24-Swap-Nodes-in-Pairs","published":1,"updated":"2020-05-03T06:14:50.673Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixrg000jk4r3tteao7kv","content":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><blockquote>\n<p>Question 25 is a more general question of this one.</p>\n</blockquote>\n<p>Suppose there are three pairs $p_0$, $p_1$ and $p_2$. We need to swap nodes in $p_1$, after that, we should reconnect it to it’s adjacent pairs by:</p>\n<script type=\"math/tex; mode=display\">\np_0(1).next=p_1(0)\np_1(1).next=p_2(0)</script><p>For the first pair, $p_0(1)=null$ so we don’t need the first equation and and for the last one, $p_2(0)=null$;</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><ol>\n<li>Recursion<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class=\"line\">        return dp(head);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    private ListNode dp(ListNode head)&#123;</span><br><span class=\"line\">        if(head == null || head.next == null)</span><br><span class=\"line\">            return head;</span><br><span class=\"line\">        ListNode next = head.next.next;</span><br><span class=\"line\">        head.next.next = head;</span><br><span class=\"line\">        head = head.next;</span><br><span class=\"line\">        head.next.next = dp(next);</span><br><span class=\"line\">        return head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>2.Iteration<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class=\"line\">        if(head == null || head.next == null)</span><br><span class=\"line\">            return head;</span><br><span class=\"line\">        ListNode gH = head;</span><br><span class=\"line\">        ListNode gT = head.next;</span><br><span class=\"line\">        head = gT;</span><br><span class=\"line\">        while(gH != null &amp;&amp; gT != null)&#123;</span><br><span class=\"line\">            ListNode tmp = gT.next;</span><br><span class=\"line\">            gT.next = gH;</span><br><span class=\"line\">            if(tmp != null &amp;&amp; tmp.next != null)&#123;</span><br><span class=\"line\">                gH.next = tmp.next;</span><br><span class=\"line\">                gH = tmp; gT = tmp.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else&#123;</span><br><span class=\"line\">                gH.next = tmp;</span><br><span class=\"line\">                gH = tmp; gT = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(n)$ becasue we iterate over the entire list</p>\n<p><strong>Space Complexity:</strong> For the recursion solution, $O(\\lceil n/2 \\rceil)$ space is necessary to store all the pairs. We cost constant space $O(1)$ for the iteration method.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><blockquote>\n<p>Question 25 is a more general question of this one.</p>\n</blockquote>\n<p>Suppose there are three pairs $p_0$, $p_1$ and $p_2$. We need to swap nodes in $p_1$, after that, we should reconnect it to it’s adjacent pairs by:</p>\n<script type=\"math/tex; mode=display\">\np_0(1).next=p_1(0)\np_1(1).next=p_2(0)</script><p>For the first pair, $p_0(1)=null$ so we don’t need the first equation and and for the last one, $p_2(0)=null$;</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><ol>\n<li>Recursion<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class=\"line\">        return dp(head);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    private ListNode dp(ListNode head)&#123;</span><br><span class=\"line\">        if(head == null || head.next == null)</span><br><span class=\"line\">            return head;</span><br><span class=\"line\">        ListNode next = head.next.next;</span><br><span class=\"line\">        head.next.next = head;</span><br><span class=\"line\">        head = head.next;</span><br><span class=\"line\">        head.next.next = dp(next);</span><br><span class=\"line\">        return head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>2.Iteration<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class=\"line\">        if(head == null || head.next == null)</span><br><span class=\"line\">            return head;</span><br><span class=\"line\">        ListNode gH = head;</span><br><span class=\"line\">        ListNode gT = head.next;</span><br><span class=\"line\">        head = gT;</span><br><span class=\"line\">        while(gH != null &amp;&amp; gT != null)&#123;</span><br><span class=\"line\">            ListNode tmp = gT.next;</span><br><span class=\"line\">            gT.next = gH;</span><br><span class=\"line\">            if(tmp != null &amp;&amp; tmp.next != null)&#123;</span><br><span class=\"line\">                gH.next = tmp.next;</span><br><span class=\"line\">                gH = tmp; gT = tmp.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else&#123;</span><br><span class=\"line\">                gH.next = tmp;</span><br><span class=\"line\">                gH = tmp; gT = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(n)$ becasue we iterate over the entire list</p>\n<p><strong>Space Complexity:</strong> For the recursion solution, $O(\\lceil n/2 \\rceil)$ space is necessary to store all the pairs. We cost constant space $O(1)$ for the iteration method.</p>\n"},{"title":"40 Combination Sum II","date":"2019-11-20T05:42:13.000Z","comments":1,"_content":"# Intuition & Algorithm\nI think it's better to compare this question with last question [39 Combination Sum](https://racla.github.io/39-Combination-Sum/). Their difference is:\n\n> One number can appears multiple times, but can only be used once. In last qestion, one number appears once but can be used multiple times.\n\nThe constraints of this question is still duplicate combinations is not allowed.Similar to last question, we should focus on how to guarentee unique solution path while using dfs method. Let's see a example below:\n> [1,1,1,2,2], target=4\n\nAfter we add first `1` into our path, can we add the second `1`? The answer is yes, because there is no `1`s between these two `1`s, so another path can't contain other `1`s, there will be no duplicates. But what if the third `1`, can we add it to the path? The answer is no, because there may be another path containing the second `1` and does contain the third `1`, this will cause duplication.  So the crucial part is add `1`s one by one, if previous `1` are not added, we can't add current `1`.\n\n# Code\n```\nclass Solution {\n    private List<Integer> path = new LinkedList<Integer>();\n    private List<List<Integer>> ans = new LinkedList<>();\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        dfs(candidates, target, 0);\n        return ans;\n    }\n    private void dfs(int[] cand, int target, int start){\n        if(target < 0)return;\n        if(target ==0 ){\n            ans.add(new ArrayList(path));\n            return;\n        }\n        for(int i = start; i < cand.length ;i++){\n            if(i > start && cand[i]==cand[i-1])continue;\n            if(cand[i] > target)break;\n            path.add(cand[i]);\n            dfs(cand, target - cand[i], i+1);\n            path.remove(path.size()-1);\n        }\n    }\n}\n```\n# Complexity\n**Time Complexity:** $O(n^{target})$\n\n**Space Complexity:** $O(target)$\n\nSee detailed explanations [here](https://racla.github.io/39-Combination-Sum/)\n\n","source":"_posts/40-Combination-Sum-II.md","raw":"---\ntitle: 40 Combination Sum II\ndate: 2019-11-20 13:42:13\ntags:\n- dfs\ncategories:\n- LeetCode\ncomments: true\n---\n# Intuition & Algorithm\nI think it's better to compare this question with last question [39 Combination Sum](https://racla.github.io/39-Combination-Sum/). Their difference is:\n\n> One number can appears multiple times, but can only be used once. In last qestion, one number appears once but can be used multiple times.\n\nThe constraints of this question is still duplicate combinations is not allowed.Similar to last question, we should focus on how to guarentee unique solution path while using dfs method. Let's see a example below:\n> [1,1,1,2,2], target=4\n\nAfter we add first `1` into our path, can we add the second `1`? The answer is yes, because there is no `1`s between these two `1`s, so another path can't contain other `1`s, there will be no duplicates. But what if the third `1`, can we add it to the path? The answer is no, because there may be another path containing the second `1` and does contain the third `1`, this will cause duplication.  So the crucial part is add `1`s one by one, if previous `1` are not added, we can't add current `1`.\n\n# Code\n```\nclass Solution {\n    private List<Integer> path = new LinkedList<Integer>();\n    private List<List<Integer>> ans = new LinkedList<>();\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        dfs(candidates, target, 0);\n        return ans;\n    }\n    private void dfs(int[] cand, int target, int start){\n        if(target < 0)return;\n        if(target ==0 ){\n            ans.add(new ArrayList(path));\n            return;\n        }\n        for(int i = start; i < cand.length ;i++){\n            if(i > start && cand[i]==cand[i-1])continue;\n            if(cand[i] > target)break;\n            path.add(cand[i]);\n            dfs(cand, target - cand[i], i+1);\n            path.remove(path.size()-1);\n        }\n    }\n}\n```\n# Complexity\n**Time Complexity:** $O(n^{target})$\n\n**Space Complexity:** $O(target)$\n\nSee detailed explanations [here](https://racla.github.io/39-Combination-Sum/)\n\n","slug":"40-Combination-Sum-II","published":1,"updated":"2020-05-03T06:14:50.675Z","layout":"post","photos":[],"link":"","_id":"cka27ixrh000kk4r3qdcbv3ah","content":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>I think it’s better to compare this question with last question <a href=\"https://racla.github.io/39-Combination-Sum/\">39 Combination Sum</a>. Their difference is:</p>\n<blockquote>\n<p>One number can appears multiple times, but can only be used once. In last qestion, one number appears once but can be used multiple times.</p>\n</blockquote>\n<p>The constraints of this question is still duplicate combinations is not allowed.Similar to last question, we should focus on how to guarentee unique solution path while using dfs method. Let’s see a example below:</p>\n<blockquote>\n<p>[1,1,1,2,2], target=4</p>\n</blockquote>\n<p>After we add first <code>1</code> into our path, can we add the second <code>1</code>? The answer is yes, because there is no <code>1</code>s between these two <code>1</code>s, so another path can’t contain other <code>1</code>s, there will be no duplicates. But what if the third <code>1</code>, can we add it to the path? The answer is no, because there may be another path containing the second <code>1</code> and does contain the third <code>1</code>, this will cause duplication.  So the crucial part is add <code>1</code>s one by one, if previous <code>1</code> are not added, we can’t add current <code>1</code>.</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    private List&lt;Integer&gt; path = new LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">    private List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</span><br><span class=\"line\">        Arrays.sort(candidates);</span><br><span class=\"line\">        dfs(candidates, target, 0);</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private void dfs(int[] cand, int target, int start)&#123;</span><br><span class=\"line\">        if(target &lt; 0)return;</span><br><span class=\"line\">        if(target ==0 )&#123;</span><br><span class=\"line\">            ans.add(new ArrayList(path));</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for(int i = start; i &lt; cand.length ;i++)&#123;</span><br><span class=\"line\">            if(i &gt; start &amp;&amp; cand[i]==cand[i-1])continue;</span><br><span class=\"line\">            if(cand[i] &gt; target)break;</span><br><span class=\"line\">            path.add(cand[i]);</span><br><span class=\"line\">            dfs(cand, target - cand[i], i+1);</span><br><span class=\"line\">            path.remove(path.size()-1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(n^{target})$</p>\n<p><strong>Space Complexity:</strong> $O(target)$</p>\n<p>See detailed explanations <a href=\"https://racla.github.io/39-Combination-Sum/\">here</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>I think it’s better to compare this question with last question <a href=\"https://racla.github.io/39-Combination-Sum/\">39 Combination Sum</a>. Their difference is:</p>\n<blockquote>\n<p>One number can appears multiple times, but can only be used once. In last qestion, one number appears once but can be used multiple times.</p>\n</blockquote>\n<p>The constraints of this question is still duplicate combinations is not allowed.Similar to last question, we should focus on how to guarentee unique solution path while using dfs method. Let’s see a example below:</p>\n<blockquote>\n<p>[1,1,1,2,2], target=4</p>\n</blockquote>\n<p>After we add first <code>1</code> into our path, can we add the second <code>1</code>? The answer is yes, because there is no <code>1</code>s between these two <code>1</code>s, so another path can’t contain other <code>1</code>s, there will be no duplicates. But what if the third <code>1</code>, can we add it to the path? The answer is no, because there may be another path containing the second <code>1</code> and does contain the third <code>1</code>, this will cause duplication.  So the crucial part is add <code>1</code>s one by one, if previous <code>1</code> are not added, we can’t add current <code>1</code>.</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    private List&lt;Integer&gt; path = new LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">    private List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</span><br><span class=\"line\">        Arrays.sort(candidates);</span><br><span class=\"line\">        dfs(candidates, target, 0);</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private void dfs(int[] cand, int target, int start)&#123;</span><br><span class=\"line\">        if(target &lt; 0)return;</span><br><span class=\"line\">        if(target ==0 )&#123;</span><br><span class=\"line\">            ans.add(new ArrayList(path));</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for(int i = start; i &lt; cand.length ;i++)&#123;</span><br><span class=\"line\">            if(i &gt; start &amp;&amp; cand[i]==cand[i-1])continue;</span><br><span class=\"line\">            if(cand[i] &gt; target)break;</span><br><span class=\"line\">            path.add(cand[i]);</span><br><span class=\"line\">            dfs(cand, target - cand[i], i+1);</span><br><span class=\"line\">            path.remove(path.size()-1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(n^{target})$</p>\n<p><strong>Space Complexity:</strong> $O(target)$</p>\n<p>See detailed explanations <a href=\"https://racla.github.io/39-Combination-Sum/\">here</a></p>\n"},{"title":"49 Group Anagrams","date":"2019-11-15T16:34:23.000Z","comments":1,"_content":"# Intuition & Algorithm\nThe primitive problem of this question is how to define anagrams. The definition from wikipedia is:\n> An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\nSo if two strings have the same letters neglecting their appearing sequences, they are anagrams. The typical solution is using an array with length 26( since there are only `a-z` in this question) to count how many times each letter has appeared in this word. The time complexity of this question is $O(mn)$ where m is the average length of each string, n is the number of original strings. This is an approximate time complexity, and you can get the accurate by the code below.\n\nSome would like to sort the string(don't forget it's a char sequence) to determine if two strings are anagrams, but that will change the time complexity to $o(mlogm*n)$. Another thing to notice is that you can determine two equal array by `Arrays.toString` method, but `Arrays.hashCode` will work faster, see the details in the discussion of this question.\n\nThere is still one thing we are worry about: will `Arrays.hashCode` arise collision? Here is the implementation of it:\n```\n     *\n     * <p>The value returned by this method is the same value that would be\n     * obtained by invoking the {@link List#hashCode() <tt>hashCode</tt>}\n     * method on a {@link List} containing a sequence of {@link Integer}\n     * instances representing the elements of <tt>a</tt> in the same order.\n     * If <tt>a</tt> is <tt>null</tt>, this method returns 0.\n     *\n     * @param a the array whose hash value to compute\n     * @return a content-based hash code for <tt>a</tt>\n     * @since 1.5\n     */\n    public static int hashCode(int a[]) {\n        if (a == null)\n            return 0;\n\n        int result = 1;\n        for (int element : a)\n            result = 31 * result + element;\n\n        return result;\n    }\n```\n\nSuppose the final count array is $a_1, a_2, ..., a_26$, the hashCode we get is:\n\n$$31*(31*(31 * 1 + a_1) + a_2)+...=1*31^{27} + a_1*31^{26}+a_2*31^{25}+...+a_{26}*31^{1}$$\n\nIf all elements in the array is less than 31 and the total sum is less than `Integer.MAX_VALUE`, there will be no collision . We can create a example that will cause collision easily:\n\n`[\"abbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\", \"aa\"]`\n\nIn this case, $a_1=1,a_2=31$ and $a_1=2, a_2 = 0$ would get the same hashCode, so these two strings will be classified as anagrams although they are not in fact.\n\n# Code\n```\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        HashMap<Integer, List<String>> map = new HashMap<>();\n        for(int i = 0; i < strs.length; i++){\n            Integer key = encode(strs[i]);\n            List<String> entry = map.getOrDefault(key, new ArrayList<>());\n            entry.add(strs[i]);\n            map.put(key, entry);\n        }\n        return new ArrayList<>(map.values());\n    }\n    private static int encode(String input){\n        int[] sta = new int[26];\n        for(Character c: input.toCharArray()){\n            sta[c-97]++;\n        }\n        /*We can use hashCode here, but don't forget the collision case*/\n        return Arrays.toString(sta);\n    }\n}\n```\n# Complexity\n**Time Complexity:** $O(mn)$\n\n**Space Complexity:** $O(mn)$ it's the size of the hashmap storing final answer.\n","source":"_posts/49-Group-Anagrams.md","raw":"---\ntitle: 49 Group Anagrams\ndate: 2019-11-16 00:34:23\ncategories:\n- LeetCode\ncomments: true\ntags:\n- HashMap\n---\n# Intuition & Algorithm\nThe primitive problem of this question is how to define anagrams. The definition from wikipedia is:\n> An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\nSo if two strings have the same letters neglecting their appearing sequences, they are anagrams. The typical solution is using an array with length 26( since there are only `a-z` in this question) to count how many times each letter has appeared in this word. The time complexity of this question is $O(mn)$ where m is the average length of each string, n is the number of original strings. This is an approximate time complexity, and you can get the accurate by the code below.\n\nSome would like to sort the string(don't forget it's a char sequence) to determine if two strings are anagrams, but that will change the time complexity to $o(mlogm*n)$. Another thing to notice is that you can determine two equal array by `Arrays.toString` method, but `Arrays.hashCode` will work faster, see the details in the discussion of this question.\n\nThere is still one thing we are worry about: will `Arrays.hashCode` arise collision? Here is the implementation of it:\n```\n     *\n     * <p>The value returned by this method is the same value that would be\n     * obtained by invoking the {@link List#hashCode() <tt>hashCode</tt>}\n     * method on a {@link List} containing a sequence of {@link Integer}\n     * instances representing the elements of <tt>a</tt> in the same order.\n     * If <tt>a</tt> is <tt>null</tt>, this method returns 0.\n     *\n     * @param a the array whose hash value to compute\n     * @return a content-based hash code for <tt>a</tt>\n     * @since 1.5\n     */\n    public static int hashCode(int a[]) {\n        if (a == null)\n            return 0;\n\n        int result = 1;\n        for (int element : a)\n            result = 31 * result + element;\n\n        return result;\n    }\n```\n\nSuppose the final count array is $a_1, a_2, ..., a_26$, the hashCode we get is:\n\n$$31*(31*(31 * 1 + a_1) + a_2)+...=1*31^{27} + a_1*31^{26}+a_2*31^{25}+...+a_{26}*31^{1}$$\n\nIf all elements in the array is less than 31 and the total sum is less than `Integer.MAX_VALUE`, there will be no collision . We can create a example that will cause collision easily:\n\n`[\"abbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\", \"aa\"]`\n\nIn this case, $a_1=1,a_2=31$ and $a_1=2, a_2 = 0$ would get the same hashCode, so these two strings will be classified as anagrams although they are not in fact.\n\n# Code\n```\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        HashMap<Integer, List<String>> map = new HashMap<>();\n        for(int i = 0; i < strs.length; i++){\n            Integer key = encode(strs[i]);\n            List<String> entry = map.getOrDefault(key, new ArrayList<>());\n            entry.add(strs[i]);\n            map.put(key, entry);\n        }\n        return new ArrayList<>(map.values());\n    }\n    private static int encode(String input){\n        int[] sta = new int[26];\n        for(Character c: input.toCharArray()){\n            sta[c-97]++;\n        }\n        /*We can use hashCode here, but don't forget the collision case*/\n        return Arrays.toString(sta);\n    }\n}\n```\n# Complexity\n**Time Complexity:** $O(mn)$\n\n**Space Complexity:** $O(mn)$ it's the size of the hashmap storing final answer.\n","slug":"49-Group-Anagrams","published":1,"updated":"2020-05-03T06:14:50.676Z","layout":"post","photos":[],"link":"","_id":"cka27ixrj000lk4r3wzhnwb4j","content":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>The primitive problem of this question is how to define anagrams. The definition from wikipedia is:</p>\n<blockquote>\n<p>An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>\n</blockquote>\n<p>So if two strings have the same letters neglecting their appearing sequences, they are anagrams. The typical solution is using an array with length 26( since there are only <code>a-z</code> in this question) to count how many times each letter has appeared in this word. The time complexity of this question is $O(mn)$ where m is the average length of each string, n is the number of original strings. This is an approximate time complexity, and you can get the accurate by the code below.</p>\n<p>Some would like to sort the string(don’t forget it’s a char sequence) to determine if two strings are anagrams, but that will change the time complexity to $o(mlogm*n)$. Another thing to notice is that you can determine two equal array by <code>Arrays.toString</code> method, but <code>Arrays.hashCode</code> will work faster, see the details in the discussion of this question.</p>\n<p>There is still one thing we are worry about: will <code>Arrays.hashCode</code> arise collision? Here is the implementation of it:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> *</span><br><span class=\"line\"> * &lt;p&gt;The value returned by this method is the same value that would be</span><br><span class=\"line\"> * obtained by invoking the &#123;@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;&#125;</span><br><span class=\"line\"> * method on a &#123;@link List&#125; containing a sequence of &#123;@link Integer&#125;</span><br><span class=\"line\"> * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.</span><br><span class=\"line\"> * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param a the array whose hash value to compute</span><br><span class=\"line\"> * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;</span><br><span class=\"line\"> * @since 1.5</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static int hashCode(int a[]) &#123;</span><br><span class=\"line\">    if (a == null)</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    int result = 1;</span><br><span class=\"line\">    for (int element : a)</span><br><span class=\"line\">        result = 31 * result + element;</span><br><span class=\"line\"></span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Suppose the final count array is $a_1, a_2, …, a_26$, the hashCode we get is:</p>\n<script type=\"math/tex; mode=display\">31*(31*(31 * 1 + a_1) + a_2)+...=1*31^{27} + a_1*31^{26}+a_2*31^{25}+...+a_{26}*31^{1}</script><p>If all elements in the array is less than 31 and the total sum is less than <code>Integer.MAX_VALUE</code>, there will be no collision . We can create a example that will cause collision easily:</p>\n<p><code>[&quot;abbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;, &quot;aa&quot;]</code></p>\n<p>In this case, $a_1=1,a_2=31$ and $a_1=2, a_2 = 0$ would get the same hashCode, so these two strings will be classified as anagrams although they are not in fact.</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class=\"line\">        HashMap&lt;Integer, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">        for(int i = 0; i &lt; strs.length; i++)&#123;</span><br><span class=\"line\">            Integer key = encode(strs[i]);</span><br><span class=\"line\">            List&lt;String&gt; entry = map.getOrDefault(key, new ArrayList&lt;&gt;());</span><br><span class=\"line\">            entry.add(strs[i]);</span><br><span class=\"line\">            map.put(key, entry);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return new ArrayList&lt;&gt;(map.values());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private static int encode(String input)&#123;</span><br><span class=\"line\">        int[] sta = new int[26];</span><br><span class=\"line\">        for(Character c: input.toCharArray())&#123;</span><br><span class=\"line\">            sta[c-97]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        /*We can use hashCode here, but don&apos;t forget the collision case*/</span><br><span class=\"line\">        return Arrays.toString(sta);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(mn)$</p>\n<p><strong>Space Complexity:</strong> $O(mn)$ it’s the size of the hashmap storing final answer.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>The primitive problem of this question is how to define anagrams. The definition from wikipedia is:</p>\n<blockquote>\n<p>An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>\n</blockquote>\n<p>So if two strings have the same letters neglecting their appearing sequences, they are anagrams. The typical solution is using an array with length 26( since there are only <code>a-z</code> in this question) to count how many times each letter has appeared in this word. The time complexity of this question is $O(mn)$ where m is the average length of each string, n is the number of original strings. This is an approximate time complexity, and you can get the accurate by the code below.</p>\n<p>Some would like to sort the string(don’t forget it’s a char sequence) to determine if two strings are anagrams, but that will change the time complexity to $o(mlogm*n)$. Another thing to notice is that you can determine two equal array by <code>Arrays.toString</code> method, but <code>Arrays.hashCode</code> will work faster, see the details in the discussion of this question.</p>\n<p>There is still one thing we are worry about: will <code>Arrays.hashCode</code> arise collision? Here is the implementation of it:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> *</span><br><span class=\"line\"> * &lt;p&gt;The value returned by this method is the same value that would be</span><br><span class=\"line\"> * obtained by invoking the &#123;@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;&#125;</span><br><span class=\"line\"> * method on a &#123;@link List&#125; containing a sequence of &#123;@link Integer&#125;</span><br><span class=\"line\"> * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.</span><br><span class=\"line\"> * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param a the array whose hash value to compute</span><br><span class=\"line\"> * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;</span><br><span class=\"line\"> * @since 1.5</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static int hashCode(int a[]) &#123;</span><br><span class=\"line\">    if (a == null)</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    int result = 1;</span><br><span class=\"line\">    for (int element : a)</span><br><span class=\"line\">        result = 31 * result + element;</span><br><span class=\"line\"></span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Suppose the final count array is $a_1, a_2, …, a_26$, the hashCode we get is:</p>\n<script type=\"math/tex; mode=display\">31*(31*(31 * 1 + a_1) + a_2)+...=1*31^{27} + a_1*31^{26}+a_2*31^{25}+...+a_{26}*31^{1}</script><p>If all elements in the array is less than 31 and the total sum is less than <code>Integer.MAX_VALUE</code>, there will be no collision . We can create a example that will cause collision easily:</p>\n<p><code>[&quot;abbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;, &quot;aa&quot;]</code></p>\n<p>In this case, $a_1=1,a_2=31$ and $a_1=2, a_2 = 0$ would get the same hashCode, so these two strings will be classified as anagrams although they are not in fact.</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class=\"line\">        HashMap&lt;Integer, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">        for(int i = 0; i &lt; strs.length; i++)&#123;</span><br><span class=\"line\">            Integer key = encode(strs[i]);</span><br><span class=\"line\">            List&lt;String&gt; entry = map.getOrDefault(key, new ArrayList&lt;&gt;());</span><br><span class=\"line\">            entry.add(strs[i]);</span><br><span class=\"line\">            map.put(key, entry);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return new ArrayList&lt;&gt;(map.values());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private static int encode(String input)&#123;</span><br><span class=\"line\">        int[] sta = new int[26];</span><br><span class=\"line\">        for(Character c: input.toCharArray())&#123;</span><br><span class=\"line\">            sta[c-97]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        /*We can use hashCode here, but don&apos;t forget the collision case*/</span><br><span class=\"line\">        return Arrays.toString(sta);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(mn)$</p>\n<p><strong>Space Complexity:</strong> $O(mn)$ it’s the size of the hashmap storing final answer.</p>\n"},{"title":"47 Permutations II","date":"2019-11-15T16:34:52.000Z","comments":1,"_content":"# Intuition & Algorithm\nRecall how we get permutations for numbers without duplication: for each permutation in last solution set, we insert the new number to all possible places. We won't have any duplicated new permutation in this case. But if we insert a number that have been in the permutation, we may get duplicated new permutation. Here are two example:\n\n`[2,2,1]` For this permutation, we want to insert value 1 in the first, second until the last place, that will give us new permutations: [1,2,2,1], [2,1,2,1], [2,2,1,1] [2,2,1,1]. Notice the last two permutation, we get two duplicated permutation because we try to insert a value before and after another value, and they are equal, so we get equal permutation. In this case, we try to insert 1 before 1 and after 1, both of them will get `1,1`. So we can use a flag to record the last value we inserted before, if it's equal to the value we want to insert, we shouldn't insert the value after it.\n\n`[2,1,1], [1,2,1]` In this case, we want to insert value 2 into two permutations. If we insert 2 into the third place of the first permutation, this will give us `[2,1,2,1]`. If we insert 2 into the first place of the second permutation, we still get `[2,1,2,1]`. The insertion of the second permutation shouldn't start from the first place, actually it should start before the last position of 2 instead. The reason here is if we insert before the last 2, and then we remove last 2 from the permutation, we will get an old permutation that already exist. In this case, we insert 2 in the first place , we get `[2,1,2,1]`, and then we remove last 2, it becomes `[2,1,1]`! This means we can get `[2,1,2,1]` from `[2,1,1]` by insert 2 between two 1s.So compared to the normal permutation problem, we should start from the last index of the value to be inserted instead of 0.\n# Code\n```\nclass Solution {\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<>();\n        if(nums.length == 0) return ans;\n        List<Integer> t = new ArrayList<>();\n        t.add(nums[0]);\n        ans.add(t);\n        for(int i = 1 ; i < nums.length; i++){\n            List<List<Integer>> curAns = new ArrayList<>();\n            for(List<Integer> ele : ans){\n                int flag = Integer.MIN_VALUE;\n                int k = Math.max(0, ele.lastIndexOf(nums[i]));\n                for(int j = k; j <= i; j++){\n                    if(nums[i] != flag){\n                        List<Integer> copy = new ArrayList<>();\n                        copy.addAll(ele);\n                        copy.add(j, nums[i]);\n                        curAns.add(copy);\n                    }\n                    if(j != i)\n                    flag = ele.get(j);\n                }\n            }\n            ans = curAns;\n        }\n        return ans;\n    }\n}\n```\n# Complexity\n**Time Complexity:** $O(n!)$\n\n**Space Complexity:** $O(n!)$\n\nSee the analysis in `46 permutation`, they are similar, we only add two conditions in this solution.\n\n","source":"_posts/47-Permutations-II.md","raw":"---\ntitle: 47 Permutations II\ndate: 2019-11-16 00:34:52\ncategories:\n- LeetCode\ncomments: true\ntags:\n- backtracking\n- dynamic programming\n- review\n---\n# Intuition & Algorithm\nRecall how we get permutations for numbers without duplication: for each permutation in last solution set, we insert the new number to all possible places. We won't have any duplicated new permutation in this case. But if we insert a number that have been in the permutation, we may get duplicated new permutation. Here are two example:\n\n`[2,2,1]` For this permutation, we want to insert value 1 in the first, second until the last place, that will give us new permutations: [1,2,2,1], [2,1,2,1], [2,2,1,1] [2,2,1,1]. Notice the last two permutation, we get two duplicated permutation because we try to insert a value before and after another value, and they are equal, so we get equal permutation. In this case, we try to insert 1 before 1 and after 1, both of them will get `1,1`. So we can use a flag to record the last value we inserted before, if it's equal to the value we want to insert, we shouldn't insert the value after it.\n\n`[2,1,1], [1,2,1]` In this case, we want to insert value 2 into two permutations. If we insert 2 into the third place of the first permutation, this will give us `[2,1,2,1]`. If we insert 2 into the first place of the second permutation, we still get `[2,1,2,1]`. The insertion of the second permutation shouldn't start from the first place, actually it should start before the last position of 2 instead. The reason here is if we insert before the last 2, and then we remove last 2 from the permutation, we will get an old permutation that already exist. In this case, we insert 2 in the first place , we get `[2,1,2,1]`, and then we remove last 2, it becomes `[2,1,1]`! This means we can get `[2,1,2,1]` from `[2,1,1]` by insert 2 between two 1s.So compared to the normal permutation problem, we should start from the last index of the value to be inserted instead of 0.\n# Code\n```\nclass Solution {\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<>();\n        if(nums.length == 0) return ans;\n        List<Integer> t = new ArrayList<>();\n        t.add(nums[0]);\n        ans.add(t);\n        for(int i = 1 ; i < nums.length; i++){\n            List<List<Integer>> curAns = new ArrayList<>();\n            for(List<Integer> ele : ans){\n                int flag = Integer.MIN_VALUE;\n                int k = Math.max(0, ele.lastIndexOf(nums[i]));\n                for(int j = k; j <= i; j++){\n                    if(nums[i] != flag){\n                        List<Integer> copy = new ArrayList<>();\n                        copy.addAll(ele);\n                        copy.add(j, nums[i]);\n                        curAns.add(copy);\n                    }\n                    if(j != i)\n                    flag = ele.get(j);\n                }\n            }\n            ans = curAns;\n        }\n        return ans;\n    }\n}\n```\n# Complexity\n**Time Complexity:** $O(n!)$\n\n**Space Complexity:** $O(n!)$\n\nSee the analysis in `46 permutation`, they are similar, we only add two conditions in this solution.\n\n","slug":"47-Permutations-II","published":1,"updated":"2020-05-03T06:14:50.675Z","layout":"post","photos":[],"link":"","_id":"cka27ixrj000mk4r34rdsftja","content":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>Recall how we get permutations for numbers without duplication: for each permutation in last solution set, we insert the new number to all possible places. We won’t have any duplicated new permutation in this case. But if we insert a number that have been in the permutation, we may get duplicated new permutation. Here are two example:</p>\n<p><code>[2,2,1]</code> For this permutation, we want to insert value 1 in the first, second until the last place, that will give us new permutations: [1,2,2,1], [2,1,2,1], [2,2,1,1] [2,2,1,1]. Notice the last two permutation, we get two duplicated permutation because we try to insert a value before and after another value, and they are equal, so we get equal permutation. In this case, we try to insert 1 before 1 and after 1, both of them will get <code>1,1</code>. So we can use a flag to record the last value we inserted before, if it’s equal to the value we want to insert, we shouldn’t insert the value after it.</p>\n<p><code>[2,1,1], [1,2,1]</code> In this case, we want to insert value 2 into two permutations. If we insert 2 into the third place of the first permutation, this will give us <code>[2,1,2,1]</code>. If we insert 2 into the first place of the second permutation, we still get <code>[2,1,2,1]</code>. The insertion of the second permutation shouldn’t start from the first place, actually it should start before the last position of 2 instead. The reason here is if we insert before the last 2, and then we remove last 2 from the permutation, we will get an old permutation that already exist. In this case, we insert 2 in the first place , we get <code>[2,1,2,1]</code>, and then we remove last 2, it becomes <code>[2,1,1]</code>! This means we can get <code>[2,1,2,1]</code> from <code>[2,1,1]</code> by insert 2 between two 1s.So compared to the normal permutation problem, we should start from the last index of the value to be inserted instead of 0.</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        if(nums.length == 0) return ans;</span><br><span class=\"line\">        List&lt;Integer&gt; t = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        t.add(nums[0]);</span><br><span class=\"line\">        ans.add(t);</span><br><span class=\"line\">        for(int i = 1 ; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">            List&lt;List&lt;Integer&gt;&gt; curAns = new ArrayList&lt;&gt;();</span><br><span class=\"line\">            for(List&lt;Integer&gt; ele : ans)&#123;</span><br><span class=\"line\">                int flag = Integer.MIN_VALUE;</span><br><span class=\"line\">                int k = Math.max(0, ele.lastIndexOf(nums[i]));</span><br><span class=\"line\">                for(int j = k; j &lt;= i; j++)&#123;</span><br><span class=\"line\">                    if(nums[i] != flag)&#123;</span><br><span class=\"line\">                        List&lt;Integer&gt; copy = new ArrayList&lt;&gt;();</span><br><span class=\"line\">                        copy.addAll(ele);</span><br><span class=\"line\">                        copy.add(j, nums[i]);</span><br><span class=\"line\">                        curAns.add(copy);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    if(j != i)</span><br><span class=\"line\">                    flag = ele.get(j);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans = curAns;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(n!)$</p>\n<p><strong>Space Complexity:</strong> $O(n!)$</p>\n<p>See the analysis in <code>46 permutation</code>, they are similar, we only add two conditions in this solution.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>Recall how we get permutations for numbers without duplication: for each permutation in last solution set, we insert the new number to all possible places. We won’t have any duplicated new permutation in this case. But if we insert a number that have been in the permutation, we may get duplicated new permutation. Here are two example:</p>\n<p><code>[2,2,1]</code> For this permutation, we want to insert value 1 in the first, second until the last place, that will give us new permutations: [1,2,2,1], [2,1,2,1], [2,2,1,1] [2,2,1,1]. Notice the last two permutation, we get two duplicated permutation because we try to insert a value before and after another value, and they are equal, so we get equal permutation. In this case, we try to insert 1 before 1 and after 1, both of them will get <code>1,1</code>. So we can use a flag to record the last value we inserted before, if it’s equal to the value we want to insert, we shouldn’t insert the value after it.</p>\n<p><code>[2,1,1], [1,2,1]</code> In this case, we want to insert value 2 into two permutations. If we insert 2 into the third place of the first permutation, this will give us <code>[2,1,2,1]</code>. If we insert 2 into the first place of the second permutation, we still get <code>[2,1,2,1]</code>. The insertion of the second permutation shouldn’t start from the first place, actually it should start before the last position of 2 instead. The reason here is if we insert before the last 2, and then we remove last 2 from the permutation, we will get an old permutation that already exist. In this case, we insert 2 in the first place , we get <code>[2,1,2,1]</code>, and then we remove last 2, it becomes <code>[2,1,1]</code>! This means we can get <code>[2,1,2,1]</code> from <code>[2,1,1]</code> by insert 2 between two 1s.So compared to the normal permutation problem, we should start from the last index of the value to be inserted instead of 0.</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        if(nums.length == 0) return ans;</span><br><span class=\"line\">        List&lt;Integer&gt; t = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        t.add(nums[0]);</span><br><span class=\"line\">        ans.add(t);</span><br><span class=\"line\">        for(int i = 1 ; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">            List&lt;List&lt;Integer&gt;&gt; curAns = new ArrayList&lt;&gt;();</span><br><span class=\"line\">            for(List&lt;Integer&gt; ele : ans)&#123;</span><br><span class=\"line\">                int flag = Integer.MIN_VALUE;</span><br><span class=\"line\">                int k = Math.max(0, ele.lastIndexOf(nums[i]));</span><br><span class=\"line\">                for(int j = k; j &lt;= i; j++)&#123;</span><br><span class=\"line\">                    if(nums[i] != flag)&#123;</span><br><span class=\"line\">                        List&lt;Integer&gt; copy = new ArrayList&lt;&gt;();</span><br><span class=\"line\">                        copy.addAll(ele);</span><br><span class=\"line\">                        copy.add(j, nums[i]);</span><br><span class=\"line\">                        curAns.add(copy);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    if(j != i)</span><br><span class=\"line\">                    flag = ele.get(j);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans = curAns;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(n!)$</p>\n<p><strong>Space Complexity:</strong> $O(n!)$</p>\n<p>See the analysis in <code>46 permutation</code>, they are similar, we only add two conditions in this solution.</p>\n"},{"title":"55 Jump Game","date":"2019-11-04T16:10:24.000Z","_content":"# Intuition & Algorithm\nIt's a typical dynamic programming problem, so we can find three kinds of solution.\n- Recursion\n- Memoization (Optimization of Recursion)\n- Bottom-up (Iteration)\n\nEach element in the array represents the maximum length we can jump and we need to find out if we can reach the last element starting from the first element.\n\n###### 1. Recursion\nThe broute-force solution is  recursion and backtracking. Let's assum the length of the given array `nums[i]` is `n`, and we want to check if we can jump to the last element from position `i`, this process can be represent as following equation:\n\n```\nS(i) = S(i+1) || ... || S(m), m = min(i+k, n), k=nums[i]\n```\n\nSo the problem is seperated into several sub-problems and the terminated case is `S(n-1)=true` since we just stand on the last element. \n\n***Time complexity*** is O(2^n) because we can choose skip each position or not in each possible solution. ***Space comlexcity*** is O(n) consumed by function stack frame.\n\n###### 2. Memoization\nThe problem of recursion is the solution of each subproblem is imutable, but we calculate it multiple times. Say, `S(i) = S(i+1) || S(i+2) || S(i+3)` and `S(i-1) = S(i+1) || S(i+2) `， `S(i+2)` is repeatedly calculated. So we can store each solution `S(i)`, when we need it just return it. For each `i`, we solved `nums[i]` problems, and `nums[i]` is at most `n`, so time complexity is `O(n^2)`. Space comlexity is O(2n) since we need O(n) for stack frame and O(n) for memo table.\n\n###### 3. Bottom-up\nThe top-down recusion process of above solution is redundant. We can first get `S(n-2)` with the precondition `S(n-1) = true` and then get `S(n-3)`, `S(n-2)`...until `S(0)`. This saves the space consumption for stack frame in recursion. Even more, the scale of this problem is not limited by recusion. For instance, the length of the array is 100000, so we need 100000 stack frame in the worst case. Operating system has limited the size of stack frame. Recursion will cause the `stack overflow` error. \n\nThe implementation of bottom-up solution is quite easy too , we can use an array to store the result of the subproblems and update the element from the last to the first. S(0) is the final answer. Time complexity is still O(n^2) and space complexity is O(n).\n\n###### 4. Greedy(Best)\nIn the above solution, we are finding the nearst position that can jump to the last. An clear illustration can be got from the above equation:\n`S(i) = S(i+1) || ... || S(m)` Logic operation `||` will terminated when an operand is true from left to right, that's exactly the **nearst** jumpable position. The neast jumpable position `njp` is `n-1`, we update it as searching from `n-2` to `0`. While at position `i`, if `i+nums[i] < njp`, we can't jump to the nearst jumpable position so we can't jump to the end, otherwise we set position `i` to jumpable and `njp` to `i`.\nTime complexity is O(n) and Space complexity is O(1). This is the best solution for ***Jump Game*** problem.\n# Complexity\nLook up the details in the above section.\n\n###### 1. Recursion\n**Time Complexity:**  O(2^n)\n\n**Space Complexity:**  O(n)\n\n###### 2. Memoization\n**Time Complexity:**  O(n^2)\n\n**Space Complexity:**  O(n)\n\n###### 3. Bottom-up\n**Time Complexity:**  O(n^2)\n\n**Space Complexity:**  O(n)\n\n###### 4. Greedy(Best)\n**Time Complexity:**  O(n)\n\n**Space Complexity:**  O(1)\n\n# Code\n###### 1. Recursion\n```\npublic class Solution {\n    public boolean canJumpFromPosition(int position, int[] nums) {\n        if (position == nums.length - 1) {\n            return true;\n        }\n\n        int furthestJump = Math.min(position + nums[position], nums.length - 1);\n        for (int nextPosition = position + 1; nextPosition <= furthestJump; nextPosition++) {\n            if (canJumpFromPosition(nextPosition, nums)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public boolean canJump(int[] nums) {\n        return canJumpFromPosition(0, nums);\n    }\n}\n```\n\n###### 2. Memoization\n```\n/**\n* Official Solution: GOOD denotes jumpable position, BAD is not jumpable\n*/\nenum Index {\n    GOOD, BAD, UNKNOWN\n}\n\npublic class Solution {\n    Index[] memo;\n\n    public boolean canJumpFromPosition(int position, int[] nums) {\n        if (memo[position] != Index.UNKNOWN) {\n            return memo[position] == Index.GOOD ? true : false;\n        }\n\n        int furthestJump = Math.min(position + nums[position], nums.length - 1);\n        for (int nextPosition = position + 1; nextPosition <= furthestJump; nextPosition++) {\n            if (canJumpFromPosition(nextPosition, nums)) {\n                memo[position] = Index.GOOD;\n                return true;\n            }\n        }\n\n        memo[position] = Index.BAD;\n        return false;\n    }\n\n    public boolean canJump(int[] nums) {\n        memo = new Index[nums.length];\n        for (int i = 0; i < memo.length; i++) {\n            memo[i] = Index.UNKNOWN;\n        }\n        memo[memo.length - 1] = Index.GOOD;\n        return canJumpFromPosition(0, nums);\n    }\n}\n```\n\n###### 3. Bottom-up\n```\nclass Solution {\n    public boolean canJump(int[] nums) {\n        boolean[] dp = new boolean[nums.length];\n        dp[nums.length - 1] = true;\n        for(int i = nums.length - 2; i >= 0; i--){\n            int k = nums[i];\n            dp[i] = false;\n            int mb = Math.min(k, nums.length-i-1);\n            for(int j = 1 ; j <= mb; j++){\n                if(dp[i+j])\n                {\n                    dp[i] = true;break;\n                }\n            }\n        }\n        return dp[0];\n    }\n}\n```\n\n###### 4. Greedy(Best)\n```\nclass Solution {\n    public boolean canJump(int[] nums) {\n        int njp = nums.length -1;\n        for(int i = nums.length -2 ;  i >=0; i--){\n            if(nums[i] + i >= njp){\n                njp = i;\n            }\n        }\n        return njp == 0; \n    }\n}\n```\n\n# Reference\n[What Is Dynamic Programming and How To Use It](https://www.youtube.com/watch?v=vYquumk4nWw&feature=youtu.be)\n\n[Official Solution](https://leetcode.com/problems/jump-game/solution/)\n","source":"_posts/55-Jump-Game.md","raw":"---\ntitle: 55 Jump Game\ndate: 2019-11-05 00:10:24\ncategories:\n- LeetCode\ntags:\n- dynamic programming\n---\n# Intuition & Algorithm\nIt's a typical dynamic programming problem, so we can find three kinds of solution.\n- Recursion\n- Memoization (Optimization of Recursion)\n- Bottom-up (Iteration)\n\nEach element in the array represents the maximum length we can jump and we need to find out if we can reach the last element starting from the first element.\n\n###### 1. Recursion\nThe broute-force solution is  recursion and backtracking. Let's assum the length of the given array `nums[i]` is `n`, and we want to check if we can jump to the last element from position `i`, this process can be represent as following equation:\n\n```\nS(i) = S(i+1) || ... || S(m), m = min(i+k, n), k=nums[i]\n```\n\nSo the problem is seperated into several sub-problems and the terminated case is `S(n-1)=true` since we just stand on the last element. \n\n***Time complexity*** is O(2^n) because we can choose skip each position or not in each possible solution. ***Space comlexcity*** is O(n) consumed by function stack frame.\n\n###### 2. Memoization\nThe problem of recursion is the solution of each subproblem is imutable, but we calculate it multiple times. Say, `S(i) = S(i+1) || S(i+2) || S(i+3)` and `S(i-1) = S(i+1) || S(i+2) `， `S(i+2)` is repeatedly calculated. So we can store each solution `S(i)`, when we need it just return it. For each `i`, we solved `nums[i]` problems, and `nums[i]` is at most `n`, so time complexity is `O(n^2)`. Space comlexity is O(2n) since we need O(n) for stack frame and O(n) for memo table.\n\n###### 3. Bottom-up\nThe top-down recusion process of above solution is redundant. We can first get `S(n-2)` with the precondition `S(n-1) = true` and then get `S(n-3)`, `S(n-2)`...until `S(0)`. This saves the space consumption for stack frame in recursion. Even more, the scale of this problem is not limited by recusion. For instance, the length of the array is 100000, so we need 100000 stack frame in the worst case. Operating system has limited the size of stack frame. Recursion will cause the `stack overflow` error. \n\nThe implementation of bottom-up solution is quite easy too , we can use an array to store the result of the subproblems and update the element from the last to the first. S(0) is the final answer. Time complexity is still O(n^2) and space complexity is O(n).\n\n###### 4. Greedy(Best)\nIn the above solution, we are finding the nearst position that can jump to the last. An clear illustration can be got from the above equation:\n`S(i) = S(i+1) || ... || S(m)` Logic operation `||` will terminated when an operand is true from left to right, that's exactly the **nearst** jumpable position. The neast jumpable position `njp` is `n-1`, we update it as searching from `n-2` to `0`. While at position `i`, if `i+nums[i] < njp`, we can't jump to the nearst jumpable position so we can't jump to the end, otherwise we set position `i` to jumpable and `njp` to `i`.\nTime complexity is O(n) and Space complexity is O(1). This is the best solution for ***Jump Game*** problem.\n# Complexity\nLook up the details in the above section.\n\n###### 1. Recursion\n**Time Complexity:**  O(2^n)\n\n**Space Complexity:**  O(n)\n\n###### 2. Memoization\n**Time Complexity:**  O(n^2)\n\n**Space Complexity:**  O(n)\n\n###### 3. Bottom-up\n**Time Complexity:**  O(n^2)\n\n**Space Complexity:**  O(n)\n\n###### 4. Greedy(Best)\n**Time Complexity:**  O(n)\n\n**Space Complexity:**  O(1)\n\n# Code\n###### 1. Recursion\n```\npublic class Solution {\n    public boolean canJumpFromPosition(int position, int[] nums) {\n        if (position == nums.length - 1) {\n            return true;\n        }\n\n        int furthestJump = Math.min(position + nums[position], nums.length - 1);\n        for (int nextPosition = position + 1; nextPosition <= furthestJump; nextPosition++) {\n            if (canJumpFromPosition(nextPosition, nums)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public boolean canJump(int[] nums) {\n        return canJumpFromPosition(0, nums);\n    }\n}\n```\n\n###### 2. Memoization\n```\n/**\n* Official Solution: GOOD denotes jumpable position, BAD is not jumpable\n*/\nenum Index {\n    GOOD, BAD, UNKNOWN\n}\n\npublic class Solution {\n    Index[] memo;\n\n    public boolean canJumpFromPosition(int position, int[] nums) {\n        if (memo[position] != Index.UNKNOWN) {\n            return memo[position] == Index.GOOD ? true : false;\n        }\n\n        int furthestJump = Math.min(position + nums[position], nums.length - 1);\n        for (int nextPosition = position + 1; nextPosition <= furthestJump; nextPosition++) {\n            if (canJumpFromPosition(nextPosition, nums)) {\n                memo[position] = Index.GOOD;\n                return true;\n            }\n        }\n\n        memo[position] = Index.BAD;\n        return false;\n    }\n\n    public boolean canJump(int[] nums) {\n        memo = new Index[nums.length];\n        for (int i = 0; i < memo.length; i++) {\n            memo[i] = Index.UNKNOWN;\n        }\n        memo[memo.length - 1] = Index.GOOD;\n        return canJumpFromPosition(0, nums);\n    }\n}\n```\n\n###### 3. Bottom-up\n```\nclass Solution {\n    public boolean canJump(int[] nums) {\n        boolean[] dp = new boolean[nums.length];\n        dp[nums.length - 1] = true;\n        for(int i = nums.length - 2; i >= 0; i--){\n            int k = nums[i];\n            dp[i] = false;\n            int mb = Math.min(k, nums.length-i-1);\n            for(int j = 1 ; j <= mb; j++){\n                if(dp[i+j])\n                {\n                    dp[i] = true;break;\n                }\n            }\n        }\n        return dp[0];\n    }\n}\n```\n\n###### 4. Greedy(Best)\n```\nclass Solution {\n    public boolean canJump(int[] nums) {\n        int njp = nums.length -1;\n        for(int i = nums.length -2 ;  i >=0; i--){\n            if(nums[i] + i >= njp){\n                njp = i;\n            }\n        }\n        return njp == 0; \n    }\n}\n```\n\n# Reference\n[What Is Dynamic Programming and How To Use It](https://www.youtube.com/watch?v=vYquumk4nWw&feature=youtu.be)\n\n[Official Solution](https://leetcode.com/problems/jump-game/solution/)\n","slug":"55-Jump-Game","published":1,"updated":"2020-05-03T06:14:50.676Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixrk000nk4r33by9h7t5","content":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>It’s a typical dynamic programming problem, so we can find three kinds of solution.</p>\n<ul>\n<li>Recursion</li>\n<li>Memoization (Optimization of Recursion)</li>\n<li>Bottom-up (Iteration)</li>\n</ul>\n<p>Each element in the array represents the maximum length we can jump and we need to find out if we can reach the last element starting from the first element.</p>\n<h6 id=\"1-Recursion\"><a href=\"#1-Recursion\" class=\"headerlink\" title=\"1. Recursion\"></a>1. Recursion</h6><p>The broute-force solution is  recursion and backtracking. Let’s assum the length of the given array <code>nums[i]</code> is <code>n</code>, and we want to check if we can jump to the last element from position <code>i</code>, this process can be represent as following equation:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S(i) = S(i+1) || ... || S(m), m = min(i+k, n), k=nums[i]</span><br></pre></td></tr></table></figure>\n<p>So the problem is seperated into several sub-problems and the terminated case is <code>S(n-1)=true</code> since we just stand on the last element. </p>\n<p><strong><em>Time complexity</em></strong> is O(2^n) because we can choose skip each position or not in each possible solution. <strong><em>Space comlexcity</em></strong> is O(n) consumed by function stack frame.</p>\n<h6 id=\"2-Memoization\"><a href=\"#2-Memoization\" class=\"headerlink\" title=\"2. Memoization\"></a>2. Memoization</h6><p>The problem of recursion is the solution of each subproblem is imutable, but we calculate it multiple times. Say, <code>S(i) = S(i+1) || S(i+2) || S(i+3)</code> and <code>S(i-1) = S(i+1) || S(i+2)</code>， <code>S(i+2)</code> is repeatedly calculated. So we can store each solution <code>S(i)</code>, when we need it just return it. For each <code>i</code>, we solved <code>nums[i]</code> problems, and <code>nums[i]</code> is at most <code>n</code>, so time complexity is <code>O(n^2)</code>. Space comlexity is O(2n) since we need O(n) for stack frame and O(n) for memo table.</p>\n<h6 id=\"3-Bottom-up\"><a href=\"#3-Bottom-up\" class=\"headerlink\" title=\"3. Bottom-up\"></a>3. Bottom-up</h6><p>The top-down recusion process of above solution is redundant. We can first get <code>S(n-2)</code> with the precondition <code>S(n-1) = true</code> and then get <code>S(n-3)</code>, <code>S(n-2)</code>…until <code>S(0)</code>. This saves the space consumption for stack frame in recursion. Even more, the scale of this problem is not limited by recusion. For instance, the length of the array is 100000, so we need 100000 stack frame in the worst case. Operating system has limited the size of stack frame. Recursion will cause the <code>stack overflow</code> error. </p>\n<p>The implementation of bottom-up solution is quite easy too , we can use an array to store the result of the subproblems and update the element from the last to the first. S(0) is the final answer. Time complexity is still O(n^2) and space complexity is O(n).</p>\n<h6 id=\"4-Greedy-Best\"><a href=\"#4-Greedy-Best\" class=\"headerlink\" title=\"4. Greedy(Best)\"></a>4. Greedy(Best)</h6><p>In the above solution, we are finding the nearst position that can jump to the last. An clear illustration can be got from the above equation:<br><code>S(i) = S(i+1) || ... || S(m)</code> Logic operation <code>||</code> will terminated when an operand is true from left to right, that’s exactly the <strong>nearst</strong> jumpable position. The neast jumpable position <code>njp</code> is <code>n-1</code>, we update it as searching from <code>n-2</code> to <code>0</code>. While at position <code>i</code>, if <code>i+nums[i] &lt; njp</code>, we can’t jump to the nearst jumpable position so we can’t jump to the end, otherwise we set position <code>i</code> to jumpable and <code>njp</code> to <code>i</code>.<br>Time complexity is O(n) and Space complexity is O(1). This is the best solution for <strong><em>Jump Game</em></strong> problem.</p>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p>Look up the details in the above section.</p>\n<h6 id=\"1-Recursion-1\"><a href=\"#1-Recursion-1\" class=\"headerlink\" title=\"1. Recursion\"></a>1. Recursion</h6><p><strong>Time Complexity:</strong>  O(2^n)</p>\n<p><strong>Space Complexity:</strong>  O(n)</p>\n<h6 id=\"2-Memoization-1\"><a href=\"#2-Memoization-1\" class=\"headerlink\" title=\"2. Memoization\"></a>2. Memoization</h6><p><strong>Time Complexity:</strong>  O(n^2)</p>\n<p><strong>Space Complexity:</strong>  O(n)</p>\n<h6 id=\"3-Bottom-up-1\"><a href=\"#3-Bottom-up-1\" class=\"headerlink\" title=\"3. Bottom-up\"></a>3. Bottom-up</h6><p><strong>Time Complexity:</strong>  O(n^2)</p>\n<p><strong>Space Complexity:</strong>  O(n)</p>\n<h6 id=\"4-Greedy-Best-1\"><a href=\"#4-Greedy-Best-1\" class=\"headerlink\" title=\"4. Greedy(Best)\"></a>4. Greedy(Best)</h6><p><strong>Time Complexity:</strong>  O(n)</p>\n<p><strong>Space Complexity:</strong>  O(1)</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><h6 id=\"1-Recursion-2\"><a href=\"#1-Recursion-2\" class=\"headerlink\" title=\"1. Recursion\"></a>1. Recursion</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Solution &#123;</span><br><span class=\"line\">    public boolean canJumpFromPosition(int position, int[] nums) &#123;</span><br><span class=\"line\">        if (position == nums.length - 1) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        int furthestJump = Math.min(position + nums[position], nums.length - 1);</span><br><span class=\"line\">        for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) &#123;</span><br><span class=\"line\">            if (canJumpFromPosition(nextPosition, nums)) &#123;</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean canJump(int[] nums) &#123;</span><br><span class=\"line\">        return canJumpFromPosition(0, nums);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"2-Memoization-2\"><a href=\"#2-Memoization-2\" class=\"headerlink\" title=\"2. Memoization\"></a>2. Memoization</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* Official Solution: GOOD denotes jumpable position, BAD is not jumpable</span><br><span class=\"line\">*/</span><br><span class=\"line\">enum Index &#123;</span><br><span class=\"line\">    GOOD, BAD, UNKNOWN</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Solution &#123;</span><br><span class=\"line\">    Index[] memo;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean canJumpFromPosition(int position, int[] nums) &#123;</span><br><span class=\"line\">        if (memo[position] != Index.UNKNOWN) &#123;</span><br><span class=\"line\">            return memo[position] == Index.GOOD ? true : false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        int furthestJump = Math.min(position + nums[position], nums.length - 1);</span><br><span class=\"line\">        for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) &#123;</span><br><span class=\"line\">            if (canJumpFromPosition(nextPosition, nums)) &#123;</span><br><span class=\"line\">                memo[position] = Index.GOOD;</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        memo[position] = Index.BAD;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean canJump(int[] nums) &#123;</span><br><span class=\"line\">        memo = new Index[nums.length];</span><br><span class=\"line\">        for (int i = 0; i &lt; memo.length; i++) &#123;</span><br><span class=\"line\">            memo[i] = Index.UNKNOWN;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        memo[memo.length - 1] = Index.GOOD;</span><br><span class=\"line\">        return canJumpFromPosition(0, nums);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"3-Bottom-up-2\"><a href=\"#3-Bottom-up-2\" class=\"headerlink\" title=\"3. Bottom-up\"></a>3. Bottom-up</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean canJump(int[] nums) &#123;</span><br><span class=\"line\">        boolean[] dp = new boolean[nums.length];</span><br><span class=\"line\">        dp[nums.length - 1] = true;</span><br><span class=\"line\">        for(int i = nums.length - 2; i &gt;= 0; i--)&#123;</span><br><span class=\"line\">            int k = nums[i];</span><br><span class=\"line\">            dp[i] = false;</span><br><span class=\"line\">            int mb = Math.min(k, nums.length-i-1);</span><br><span class=\"line\">            for(int j = 1 ; j &lt;= mb; j++)&#123;</span><br><span class=\"line\">                if(dp[i+j])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    dp[i] = true;break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"4-Greedy-Best-2\"><a href=\"#4-Greedy-Best-2\" class=\"headerlink\" title=\"4. Greedy(Best)\"></a>4. Greedy(Best)</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean canJump(int[] nums) &#123;</span><br><span class=\"line\">        int njp = nums.length -1;</span><br><span class=\"line\">        for(int i = nums.length -2 ;  i &gt;=0; i--)&#123;</span><br><span class=\"line\">            if(nums[i] + i &gt;= njp)&#123;</span><br><span class=\"line\">                njp = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return njp == 0; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p><a href=\"https://www.youtube.com/watch?v=vYquumk4nWw&amp;feature=youtu.be\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">What Is Dynamic Programming and How To Use It</a></p>\n<p><a href=\"https://leetcode.com/problems/jump-game/solution/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Official Solution</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>It’s a typical dynamic programming problem, so we can find three kinds of solution.</p>\n<ul>\n<li>Recursion</li>\n<li>Memoization (Optimization of Recursion)</li>\n<li>Bottom-up (Iteration)</li>\n</ul>\n<p>Each element in the array represents the maximum length we can jump and we need to find out if we can reach the last element starting from the first element.</p>\n<h6 id=\"1-Recursion\"><a href=\"#1-Recursion\" class=\"headerlink\" title=\"1. Recursion\"></a>1. Recursion</h6><p>The broute-force solution is  recursion and backtracking. Let’s assum the length of the given array <code>nums[i]</code> is <code>n</code>, and we want to check if we can jump to the last element from position <code>i</code>, this process can be represent as following equation:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S(i) = S(i+1) || ... || S(m), m = min(i+k, n), k=nums[i]</span><br></pre></td></tr></table></figure>\n<p>So the problem is seperated into several sub-problems and the terminated case is <code>S(n-1)=true</code> since we just stand on the last element. </p>\n<p><strong><em>Time complexity</em></strong> is O(2^n) because we can choose skip each position or not in each possible solution. <strong><em>Space comlexcity</em></strong> is O(n) consumed by function stack frame.</p>\n<h6 id=\"2-Memoization\"><a href=\"#2-Memoization\" class=\"headerlink\" title=\"2. Memoization\"></a>2. Memoization</h6><p>The problem of recursion is the solution of each subproblem is imutable, but we calculate it multiple times. Say, <code>S(i) = S(i+1) || S(i+2) || S(i+3)</code> and <code>S(i-1) = S(i+1) || S(i+2)</code>， <code>S(i+2)</code> is repeatedly calculated. So we can store each solution <code>S(i)</code>, when we need it just return it. For each <code>i</code>, we solved <code>nums[i]</code> problems, and <code>nums[i]</code> is at most <code>n</code>, so time complexity is <code>O(n^2)</code>. Space comlexity is O(2n) since we need O(n) for stack frame and O(n) for memo table.</p>\n<h6 id=\"3-Bottom-up\"><a href=\"#3-Bottom-up\" class=\"headerlink\" title=\"3. Bottom-up\"></a>3. Bottom-up</h6><p>The top-down recusion process of above solution is redundant. We can first get <code>S(n-2)</code> with the precondition <code>S(n-1) = true</code> and then get <code>S(n-3)</code>, <code>S(n-2)</code>…until <code>S(0)</code>. This saves the space consumption for stack frame in recursion. Even more, the scale of this problem is not limited by recusion. For instance, the length of the array is 100000, so we need 100000 stack frame in the worst case. Operating system has limited the size of stack frame. Recursion will cause the <code>stack overflow</code> error. </p>\n<p>The implementation of bottom-up solution is quite easy too , we can use an array to store the result of the subproblems and update the element from the last to the first. S(0) is the final answer. Time complexity is still O(n^2) and space complexity is O(n).</p>\n<h6 id=\"4-Greedy-Best\"><a href=\"#4-Greedy-Best\" class=\"headerlink\" title=\"4. Greedy(Best)\"></a>4. Greedy(Best)</h6><p>In the above solution, we are finding the nearst position that can jump to the last. An clear illustration can be got from the above equation:<br><code>S(i) = S(i+1) || ... || S(m)</code> Logic operation <code>||</code> will terminated when an operand is true from left to right, that’s exactly the <strong>nearst</strong> jumpable position. The neast jumpable position <code>njp</code> is <code>n-1</code>, we update it as searching from <code>n-2</code> to <code>0</code>. While at position <code>i</code>, if <code>i+nums[i] &lt; njp</code>, we can’t jump to the nearst jumpable position so we can’t jump to the end, otherwise we set position <code>i</code> to jumpable and <code>njp</code> to <code>i</code>.<br>Time complexity is O(n) and Space complexity is O(1). This is the best solution for <strong><em>Jump Game</em></strong> problem.</p>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p>Look up the details in the above section.</p>\n<h6 id=\"1-Recursion-1\"><a href=\"#1-Recursion-1\" class=\"headerlink\" title=\"1. Recursion\"></a>1. Recursion</h6><p><strong>Time Complexity:</strong>  O(2^n)</p>\n<p><strong>Space Complexity:</strong>  O(n)</p>\n<h6 id=\"2-Memoization-1\"><a href=\"#2-Memoization-1\" class=\"headerlink\" title=\"2. Memoization\"></a>2. Memoization</h6><p><strong>Time Complexity:</strong>  O(n^2)</p>\n<p><strong>Space Complexity:</strong>  O(n)</p>\n<h6 id=\"3-Bottom-up-1\"><a href=\"#3-Bottom-up-1\" class=\"headerlink\" title=\"3. Bottom-up\"></a>3. Bottom-up</h6><p><strong>Time Complexity:</strong>  O(n^2)</p>\n<p><strong>Space Complexity:</strong>  O(n)</p>\n<h6 id=\"4-Greedy-Best-1\"><a href=\"#4-Greedy-Best-1\" class=\"headerlink\" title=\"4. Greedy(Best)\"></a>4. Greedy(Best)</h6><p><strong>Time Complexity:</strong>  O(n)</p>\n<p><strong>Space Complexity:</strong>  O(1)</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><h6 id=\"1-Recursion-2\"><a href=\"#1-Recursion-2\" class=\"headerlink\" title=\"1. Recursion\"></a>1. Recursion</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Solution &#123;</span><br><span class=\"line\">    public boolean canJumpFromPosition(int position, int[] nums) &#123;</span><br><span class=\"line\">        if (position == nums.length - 1) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        int furthestJump = Math.min(position + nums[position], nums.length - 1);</span><br><span class=\"line\">        for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) &#123;</span><br><span class=\"line\">            if (canJumpFromPosition(nextPosition, nums)) &#123;</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean canJump(int[] nums) &#123;</span><br><span class=\"line\">        return canJumpFromPosition(0, nums);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"2-Memoization-2\"><a href=\"#2-Memoization-2\" class=\"headerlink\" title=\"2. Memoization\"></a>2. Memoization</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* Official Solution: GOOD denotes jumpable position, BAD is not jumpable</span><br><span class=\"line\">*/</span><br><span class=\"line\">enum Index &#123;</span><br><span class=\"line\">    GOOD, BAD, UNKNOWN</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Solution &#123;</span><br><span class=\"line\">    Index[] memo;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean canJumpFromPosition(int position, int[] nums) &#123;</span><br><span class=\"line\">        if (memo[position] != Index.UNKNOWN) &#123;</span><br><span class=\"line\">            return memo[position] == Index.GOOD ? true : false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        int furthestJump = Math.min(position + nums[position], nums.length - 1);</span><br><span class=\"line\">        for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) &#123;</span><br><span class=\"line\">            if (canJumpFromPosition(nextPosition, nums)) &#123;</span><br><span class=\"line\">                memo[position] = Index.GOOD;</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        memo[position] = Index.BAD;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean canJump(int[] nums) &#123;</span><br><span class=\"line\">        memo = new Index[nums.length];</span><br><span class=\"line\">        for (int i = 0; i &lt; memo.length; i++) &#123;</span><br><span class=\"line\">            memo[i] = Index.UNKNOWN;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        memo[memo.length - 1] = Index.GOOD;</span><br><span class=\"line\">        return canJumpFromPosition(0, nums);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"3-Bottom-up-2\"><a href=\"#3-Bottom-up-2\" class=\"headerlink\" title=\"3. Bottom-up\"></a>3. Bottom-up</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean canJump(int[] nums) &#123;</span><br><span class=\"line\">        boolean[] dp = new boolean[nums.length];</span><br><span class=\"line\">        dp[nums.length - 1] = true;</span><br><span class=\"line\">        for(int i = nums.length - 2; i &gt;= 0; i--)&#123;</span><br><span class=\"line\">            int k = nums[i];</span><br><span class=\"line\">            dp[i] = false;</span><br><span class=\"line\">            int mb = Math.min(k, nums.length-i-1);</span><br><span class=\"line\">            for(int j = 1 ; j &lt;= mb; j++)&#123;</span><br><span class=\"line\">                if(dp[i+j])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    dp[i] = true;break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"4-Greedy-Best-2\"><a href=\"#4-Greedy-Best-2\" class=\"headerlink\" title=\"4. Greedy(Best)\"></a>4. Greedy(Best)</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean canJump(int[] nums) &#123;</span><br><span class=\"line\">        int njp = nums.length -1;</span><br><span class=\"line\">        for(int i = nums.length -2 ;  i &gt;=0; i--)&#123;</span><br><span class=\"line\">            if(nums[i] + i &gt;= njp)&#123;</span><br><span class=\"line\">                njp = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return njp == 0; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p><a href=\"https://www.youtube.com/watch?v=vYquumk4nWw&amp;feature=youtu.be\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">What Is Dynamic Programming and How To Use It</a></p>\n<p><a href=\"https://leetcode.com/problems/jump-game/solution/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Official Solution</a></p>\n"},{"title":"86 Partition List","date":"2019-11-27T06:36:36.000Z","_content":"# Intuition\nThis question is one step of quick sort: split the list into two parts by a sentinal. We need three pointers to deal with the classifying process:\n1. One pointer denotes the right border of the smaller part, at first it's at the dummy node before head node;\n2. The other two pointers are for one goal: iterate over the entire list, move node into the smaller part or remain at its original place up to the given sentinal `x`.\n> Keep in mind we need two pointers to remove a node. The critial idea of this algorithm is to  remove a node from the list and then insert it the the right border of the smaller part(after the slow pointer).\n\n# Algorithm\nLet's look at an example below:\n> Input: head = 1->4->3->2->5->2, x = 3 <br/>\nOutput: 1->2->2->4->3->5\n\nThe three pointers stated above are denoted by`s`(slow), `f`(fast), `p`(pre, node before fast pointer).\n\n1. Initial State\n\n> -1(s,p)->1(f)->4->3->2->5->2 <br/>\n\n2. Check the first node\n\nSince `1 < 3`, we should remove fast node into smaller part, and then move fast node to next node. Here is a corner case, when fast node is right the next node of slow node, we don't need to remove it from the list.\n> -1->1(s,p)->4(f)->3->2->5->2 <br/>\n\n3. Check the second node\n\n`4>3`, so we don't move any node, just move fast pointer and pre pointer to its next place\n> -1->1(s)->4(p)->3(f)->2->5->2 <br/>\n\n4. Check the third node\n\nThe same case as the second one\n> -1->1(s)->4->3(p)->2(f)->5->2 <br/>\n\n5. Check the fourth node\n\n`2<3`, we need to remove it from the list and insert it after slow pointer and then move two pointers to its next node. Take care that we don't need to move pre pointer in this case.\n> -1->1->2(s)->4->3(p)->5(f)->2 <br/>\n\n6. Check the nodes left\n\nWe will get the list finally(`null` node after the tail node is ignored in previous diagram):\n> -1->1->2->2(s)->4->3->5(p)->null(f) <br/>\n\n# Code\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode partition(ListNode head, int x) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode fast = head, slow = dummy, pre = dummy;\n        while(fast != null){\n            if(fast.val < x){\n                ListNode next = fast.next;\n                if(fast != slow.next){\n                    fast.next = slow.next;\n                    pre.next = next;\n                }\n                slow.next = fast;\n                slow = fast;\n                fast = next;\n            }\n            else{\n                pre = fast;\n                fast = fast.next;\n            }\n        }\n        return dummy.next;\n    }\n}\n```\n\n# Complexity\n**Time Complexity:** $O(n)$ It's the cost of iterating over a list.\n\n**Space Complexity:** $O(1)$ Constant pointers are used.\n","source":"_posts/86-Partition-List.md","raw":"---\ntitle: 86 Partition List\ndate: 2019-11-27 14:36:36\ntags:\n- list\ncategories:\n- LeetCode\n---\n# Intuition\nThis question is one step of quick sort: split the list into two parts by a sentinal. We need three pointers to deal with the classifying process:\n1. One pointer denotes the right border of the smaller part, at first it's at the dummy node before head node;\n2. The other two pointers are for one goal: iterate over the entire list, move node into the smaller part or remain at its original place up to the given sentinal `x`.\n> Keep in mind we need two pointers to remove a node. The critial idea of this algorithm is to  remove a node from the list and then insert it the the right border of the smaller part(after the slow pointer).\n\n# Algorithm\nLet's look at an example below:\n> Input: head = 1->4->3->2->5->2, x = 3 <br/>\nOutput: 1->2->2->4->3->5\n\nThe three pointers stated above are denoted by`s`(slow), `f`(fast), `p`(pre, node before fast pointer).\n\n1. Initial State\n\n> -1(s,p)->1(f)->4->3->2->5->2 <br/>\n\n2. Check the first node\n\nSince `1 < 3`, we should remove fast node into smaller part, and then move fast node to next node. Here is a corner case, when fast node is right the next node of slow node, we don't need to remove it from the list.\n> -1->1(s,p)->4(f)->3->2->5->2 <br/>\n\n3. Check the second node\n\n`4>3`, so we don't move any node, just move fast pointer and pre pointer to its next place\n> -1->1(s)->4(p)->3(f)->2->5->2 <br/>\n\n4. Check the third node\n\nThe same case as the second one\n> -1->1(s)->4->3(p)->2(f)->5->2 <br/>\n\n5. Check the fourth node\n\n`2<3`, we need to remove it from the list and insert it after slow pointer and then move two pointers to its next node. Take care that we don't need to move pre pointer in this case.\n> -1->1->2(s)->4->3(p)->5(f)->2 <br/>\n\n6. Check the nodes left\n\nWe will get the list finally(`null` node after the tail node is ignored in previous diagram):\n> -1->1->2->2(s)->4->3->5(p)->null(f) <br/>\n\n# Code\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode partition(ListNode head, int x) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode fast = head, slow = dummy, pre = dummy;\n        while(fast != null){\n            if(fast.val < x){\n                ListNode next = fast.next;\n                if(fast != slow.next){\n                    fast.next = slow.next;\n                    pre.next = next;\n                }\n                slow.next = fast;\n                slow = fast;\n                fast = next;\n            }\n            else{\n                pre = fast;\n                fast = fast.next;\n            }\n        }\n        return dummy.next;\n    }\n}\n```\n\n# Complexity\n**Time Complexity:** $O(n)$ It's the cost of iterating over a list.\n\n**Space Complexity:** $O(1)$ Constant pointers are used.\n","slug":"86-Partition-List","published":1,"updated":"2020-05-03T06:14:50.677Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixrm000ok4r3eqsohxu0","content":"<h1 id=\"Intuition\"><a href=\"#Intuition\" class=\"headerlink\" title=\"Intuition\"></a>Intuition</h1><p>This question is one step of quick sort: split the list into two parts by a sentinal. We need three pointers to deal with the classifying process:</p>\n<ol>\n<li>One pointer denotes the right border of the smaller part, at first it’s at the dummy node before head node;</li>\n<li>The other two pointers are for one goal: iterate over the entire list, move node into the smaller part or remain at its original place up to the given sentinal <code>x</code>.<blockquote>\n<p>Keep in mind we need two pointers to remove a node. The critial idea of this algorithm is to  remove a node from the list and then insert it the the right border of the smaller part(after the slow pointer).</p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"Algorithm\"><a href=\"#Algorithm\" class=\"headerlink\" title=\"Algorithm\"></a>Algorithm</h1><p>Let’s look at an example below:</p>\n<blockquote>\n<p>Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3 <br><br>Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p>\n</blockquote>\n<p>The three pointers stated above are denoted by<code>s</code>(slow), <code>f</code>(fast), <code>p</code>(pre, node before fast pointer).</p>\n<ol>\n<li>Initial State</li>\n</ol>\n<blockquote>\n<p>-1(s,p)-&gt;1(f)-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 <br></p>\n</blockquote>\n<ol>\n<li>Check the first node</li>\n</ol>\n<p>Since <code>1 &lt; 3</code>, we should remove fast node into smaller part, and then move fast node to next node. Here is a corner case, when fast node is right the next node of slow node, we don’t need to remove it from the list.</p>\n<blockquote>\n<p>-1-&gt;1(s,p)-&gt;4(f)-&gt;3-&gt;2-&gt;5-&gt;2 <br></p>\n</blockquote>\n<ol>\n<li>Check the second node</li>\n</ol>\n<p><code>4&gt;3</code>, so we don’t move any node, just move fast pointer and pre pointer to its next place</p>\n<blockquote>\n<p>-1-&gt;1(s)-&gt;4(p)-&gt;3(f)-&gt;2-&gt;5-&gt;2 <br></p>\n</blockquote>\n<ol>\n<li>Check the third node</li>\n</ol>\n<p>The same case as the second one</p>\n<blockquote>\n<p>-1-&gt;1(s)-&gt;4-&gt;3(p)-&gt;2(f)-&gt;5-&gt;2 <br></p>\n</blockquote>\n<ol>\n<li>Check the fourth node</li>\n</ol>\n<p><code>2&lt;3</code>, we need to remove it from the list and insert it after slow pointer and then move two pointers to its next node. Take care that we don’t need to move pre pointer in this case.</p>\n<blockquote>\n<p>-1-&gt;1-&gt;2(s)-&gt;4-&gt;3(p)-&gt;5(f)-&gt;2 <br></p>\n</blockquote>\n<ol>\n<li>Check the nodes left</li>\n</ol>\n<p>We will get the list finally(<code>null</code> node after the tail node is ignored in previous diagram):</p>\n<blockquote>\n<p>-1-&gt;1-&gt;2-&gt;2(s)-&gt;4-&gt;3-&gt;5(p)-&gt;null(f) <br></p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode partition(ListNode head, int x) &#123;</span><br><span class=\"line\">        ListNode dummy = new ListNode(0);</span><br><span class=\"line\">        dummy.next = head;</span><br><span class=\"line\">        ListNode fast = head, slow = dummy, pre = dummy;</span><br><span class=\"line\">        while(fast != null)&#123;</span><br><span class=\"line\">            if(fast.val &lt; x)&#123;</span><br><span class=\"line\">                ListNode next = fast.next;</span><br><span class=\"line\">                if(fast != slow.next)&#123;</span><br><span class=\"line\">                    fast.next = slow.next;</span><br><span class=\"line\">                    pre.next = next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                slow.next = fast;</span><br><span class=\"line\">                slow = fast;</span><br><span class=\"line\">                fast = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else&#123;</span><br><span class=\"line\">                pre = fast;</span><br><span class=\"line\">                fast = fast.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(n)$ It’s the cost of iterating over a list.</p>\n<p><strong>Space Complexity:</strong> $O(1)$ Constant pointers are used.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition\"><a href=\"#Intuition\" class=\"headerlink\" title=\"Intuition\"></a>Intuition</h1><p>This question is one step of quick sort: split the list into two parts by a sentinal. We need three pointers to deal with the classifying process:</p>\n<ol>\n<li>One pointer denotes the right border of the smaller part, at first it’s at the dummy node before head node;</li>\n<li>The other two pointers are for one goal: iterate over the entire list, move node into the smaller part or remain at its original place up to the given sentinal <code>x</code>.<blockquote>\n<p>Keep in mind we need two pointers to remove a node. The critial idea of this algorithm is to  remove a node from the list and then insert it the the right border of the smaller part(after the slow pointer).</p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"Algorithm\"><a href=\"#Algorithm\" class=\"headerlink\" title=\"Algorithm\"></a>Algorithm</h1><p>Let’s look at an example below:</p>\n<blockquote>\n<p>Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3 <br><br>Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p>\n</blockquote>\n<p>The three pointers stated above are denoted by<code>s</code>(slow), <code>f</code>(fast), <code>p</code>(pre, node before fast pointer).</p>\n<ol>\n<li>Initial State</li>\n</ol>\n<blockquote>\n<p>-1(s,p)-&gt;1(f)-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 <br></p>\n</blockquote>\n<ol>\n<li>Check the first node</li>\n</ol>\n<p>Since <code>1 &lt; 3</code>, we should remove fast node into smaller part, and then move fast node to next node. Here is a corner case, when fast node is right the next node of slow node, we don’t need to remove it from the list.</p>\n<blockquote>\n<p>-1-&gt;1(s,p)-&gt;4(f)-&gt;3-&gt;2-&gt;5-&gt;2 <br></p>\n</blockquote>\n<ol>\n<li>Check the second node</li>\n</ol>\n<p><code>4&gt;3</code>, so we don’t move any node, just move fast pointer and pre pointer to its next place</p>\n<blockquote>\n<p>-1-&gt;1(s)-&gt;4(p)-&gt;3(f)-&gt;2-&gt;5-&gt;2 <br></p>\n</blockquote>\n<ol>\n<li>Check the third node</li>\n</ol>\n<p>The same case as the second one</p>\n<blockquote>\n<p>-1-&gt;1(s)-&gt;4-&gt;3(p)-&gt;2(f)-&gt;5-&gt;2 <br></p>\n</blockquote>\n<ol>\n<li>Check the fourth node</li>\n</ol>\n<p><code>2&lt;3</code>, we need to remove it from the list and insert it after slow pointer and then move two pointers to its next node. Take care that we don’t need to move pre pointer in this case.</p>\n<blockquote>\n<p>-1-&gt;1-&gt;2(s)-&gt;4-&gt;3(p)-&gt;5(f)-&gt;2 <br></p>\n</blockquote>\n<ol>\n<li>Check the nodes left</li>\n</ol>\n<p>We will get the list finally(<code>null</code> node after the tail node is ignored in previous diagram):</p>\n<blockquote>\n<p>-1-&gt;1-&gt;2-&gt;2(s)-&gt;4-&gt;3-&gt;5(p)-&gt;null(f) <br></p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode partition(ListNode head, int x) &#123;</span><br><span class=\"line\">        ListNode dummy = new ListNode(0);</span><br><span class=\"line\">        dummy.next = head;</span><br><span class=\"line\">        ListNode fast = head, slow = dummy, pre = dummy;</span><br><span class=\"line\">        while(fast != null)&#123;</span><br><span class=\"line\">            if(fast.val &lt; x)&#123;</span><br><span class=\"line\">                ListNode next = fast.next;</span><br><span class=\"line\">                if(fast != slow.next)&#123;</span><br><span class=\"line\">                    fast.next = slow.next;</span><br><span class=\"line\">                    pre.next = next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                slow.next = fast;</span><br><span class=\"line\">                slow = fast;</span><br><span class=\"line\">                fast = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else&#123;</span><br><span class=\"line\">                pre = fast;</span><br><span class=\"line\">                fast = fast.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(n)$ It’s the cost of iterating over a list.</p>\n<p><strong>Space Complexity:</strong> $O(1)$ Constant pointers are used.</p>\n"},{"title":"61 Rotate List","date":"2019-11-23T13:25:36.000Z","_content":"# Intuition & Algorithm\nRemove the last k nodes before the head node.\n# Code\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head ==null)return head;\n        int n = 0;\n        ListNode tail = null;\n        for(ListNode i = head; i!=null;n++,tail=i,i=i.next);\n        k=k%n;\n        if(k==0)return head;\n        ListNode pre=null;\n        ListNode c=head;\n        for(int i = 0 ; i < n-k; i++,pre=c,c=c.next);\n        tail.next = head;\n        head = pre.next;\n        pre.next=null;\n        return head;\n    }\n}\n```\n\n# Complexity\n**Time Complexity:** There are two for loop here, cost $O(n)$ time to traverse the lsit.\n**Space Complexity:** $O(1)$\n","source":"_posts/61-Rotate-List.md","raw":"---\ntitle: 61 Rotate List\ndate: 2019-11-23 21:25:36\ntags:\n- list\ncategories:\n- LeetCode\n---\n# Intuition & Algorithm\nRemove the last k nodes before the head node.\n# Code\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head ==null)return head;\n        int n = 0;\n        ListNode tail = null;\n        for(ListNode i = head; i!=null;n++,tail=i,i=i.next);\n        k=k%n;\n        if(k==0)return head;\n        ListNode pre=null;\n        ListNode c=head;\n        for(int i = 0 ; i < n-k; i++,pre=c,c=c.next);\n        tail.next = head;\n        head = pre.next;\n        pre.next=null;\n        return head;\n    }\n}\n```\n\n# Complexity\n**Time Complexity:** There are two for loop here, cost $O(n)$ time to traverse the lsit.\n**Space Complexity:** $O(1)$\n","slug":"61-Rotate-List","published":1,"updated":"2020-05-03T06:14:50.676Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixrn000pk4r3db3f0ktt","content":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>Remove the last k nodes before the head node.</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode rotateRight(ListNode head, int k) &#123;</span><br><span class=\"line\">        if(head ==null)return head;</span><br><span class=\"line\">        int n = 0;</span><br><span class=\"line\">        ListNode tail = null;</span><br><span class=\"line\">        for(ListNode i = head; i!=null;n++,tail=i,i=i.next);</span><br><span class=\"line\">        k=k%n;</span><br><span class=\"line\">        if(k==0)return head;</span><br><span class=\"line\">        ListNode pre=null;</span><br><span class=\"line\">        ListNode c=head;</span><br><span class=\"line\">        for(int i = 0 ; i &lt; n-k; i++,pre=c,c=c.next);</span><br><span class=\"line\">        tail.next = head;</span><br><span class=\"line\">        head = pre.next;</span><br><span class=\"line\">        pre.next=null;</span><br><span class=\"line\">        return head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> There are two for loop here, cost $O(n)$ time to traverse the lsit.<br><strong>Space Complexity:</strong> $O(1)$</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h1><p>Remove the last k nodes before the head node.</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode rotateRight(ListNode head, int k) &#123;</span><br><span class=\"line\">        if(head ==null)return head;</span><br><span class=\"line\">        int n = 0;</span><br><span class=\"line\">        ListNode tail = null;</span><br><span class=\"line\">        for(ListNode i = head; i!=null;n++,tail=i,i=i.next);</span><br><span class=\"line\">        k=k%n;</span><br><span class=\"line\">        if(k==0)return head;</span><br><span class=\"line\">        ListNode pre=null;</span><br><span class=\"line\">        ListNode c=head;</span><br><span class=\"line\">        for(int i = 0 ; i &lt; n-k; i++,pre=c,c=c.next);</span><br><span class=\"line\">        tail.next = head;</span><br><span class=\"line\">        head = pre.next;</span><br><span class=\"line\">        pre.next=null;</span><br><span class=\"line\">        return head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> There are two for loop here, cost $O(n)$ time to traverse the lsit.<br><strong>Space Complexity:</strong> $O(1)$</p>\n"},{"title":"82 Remove Duplicates from Sorted List II","date":"2019-11-27T06:36:08.000Z","_content":"# Intuition\nThere are several stuff to notice:\n1. Remove the duplicates, keep no one of them\n2. Find the duplicates by three pointers: pre,cur and next, indicating previous node current node and next node. When the value of next node and cur node are equal, move next node to the one that not equal to cur node, and connect it to pre node, so the duplicates are removed.\n\n# Code\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode cur = head;\n        ListNode dummy = new ListNode(0), pre = dummy;\n        dummy.next = head;\n        while(cur != null){\n            ListNode next = cur.next;\n            while(next!=null && next.val == cur.val){\n                next = next.next;\n            }\n            if(cur.next == next){\n                pre.next = cur;\n                cur = cur.next;\n                pre = pre.next;\n            }\n            else\n            {\n                pre.next = next;\n                cur = next;\n            }\n            \n        }\n        return dummy.next;\n    }\n}\n```\n# Complexity\n**Time Complexity:** $O(N)$ We use three pointers to iterate over the list.\n\n**Space Complexity:** $O(1)$\n","source":"_posts/82-Remove-Duplicates-from-Sorted-List-II.md","raw":"---\ntitle: 82 Remove Duplicates from Sorted List II\ndate: 2019-11-27 14:36:08\ntags:\n- list\ncategories:\n- LeetCode\n---\n# Intuition\nThere are several stuff to notice:\n1. Remove the duplicates, keep no one of them\n2. Find the duplicates by three pointers: pre,cur and next, indicating previous node current node and next node. When the value of next node and cur node are equal, move next node to the one that not equal to cur node, and connect it to pre node, so the duplicates are removed.\n\n# Code\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode cur = head;\n        ListNode dummy = new ListNode(0), pre = dummy;\n        dummy.next = head;\n        while(cur != null){\n            ListNode next = cur.next;\n            while(next!=null && next.val == cur.val){\n                next = next.next;\n            }\n            if(cur.next == next){\n                pre.next = cur;\n                cur = cur.next;\n                pre = pre.next;\n            }\n            else\n            {\n                pre.next = next;\n                cur = next;\n            }\n            \n        }\n        return dummy.next;\n    }\n}\n```\n# Complexity\n**Time Complexity:** $O(N)$ We use three pointers to iterate over the list.\n\n**Space Complexity:** $O(1)$\n","slug":"82-Remove-Duplicates-from-Sorted-List-II","published":1,"updated":"2020-05-03T06:14:50.677Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixrq000qk4r31b3znfng","content":"<h1 id=\"Intuition\"><a href=\"#Intuition\" class=\"headerlink\" title=\"Intuition\"></a>Intuition</h1><p>There are several stuff to notice:</p>\n<ol>\n<li>Remove the duplicates, keep no one of them</li>\n<li>Find the duplicates by three pointers: pre,cur and next, indicating previous node current node and next node. When the value of next node and cur node are equal, move next node to the one that not equal to cur node, and connect it to pre node, so the duplicates are removed.</li>\n</ol>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class=\"line\">        ListNode cur = head;</span><br><span class=\"line\">        ListNode dummy = new ListNode(0), pre = dummy;</span><br><span class=\"line\">        dummy.next = head;</span><br><span class=\"line\">        while(cur != null)&#123;</span><br><span class=\"line\">            ListNode next = cur.next;</span><br><span class=\"line\">            while(next!=null &amp;&amp; next.val == cur.val)&#123;</span><br><span class=\"line\">                next = next.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(cur.next == next)&#123;</span><br><span class=\"line\">                pre.next = cur;</span><br><span class=\"line\">                cur = cur.next;</span><br><span class=\"line\">                pre = pre.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                pre.next = next;</span><br><span class=\"line\">                cur = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(N)$ We use three pointers to iterate over the list.</p>\n<p><strong>Space Complexity:</strong> $O(1)$</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition\"><a href=\"#Intuition\" class=\"headerlink\" title=\"Intuition\"></a>Intuition</h1><p>There are several stuff to notice:</p>\n<ol>\n<li>Remove the duplicates, keep no one of them</li>\n<li>Find the duplicates by three pointers: pre,cur and next, indicating previous node current node and next node. When the value of next node and cur node are equal, move next node to the one that not equal to cur node, and connect it to pre node, so the duplicates are removed.</li>\n</ol>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class=\"line\">        ListNode cur = head;</span><br><span class=\"line\">        ListNode dummy = new ListNode(0), pre = dummy;</span><br><span class=\"line\">        dummy.next = head;</span><br><span class=\"line\">        while(cur != null)&#123;</span><br><span class=\"line\">            ListNode next = cur.next;</span><br><span class=\"line\">            while(next!=null &amp;&amp; next.val == cur.val)&#123;</span><br><span class=\"line\">                next = next.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(cur.next == next)&#123;</span><br><span class=\"line\">                pre.next = cur;</span><br><span class=\"line\">                cur = cur.next;</span><br><span class=\"line\">                pre = pre.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                pre.next = next;</span><br><span class=\"line\">                cur = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time Complexity:</strong> $O(N)$ We use three pointers to iterate over the list.</p>\n<p><strong>Space Complexity:</strong> $O(1)$</p>\n"},{"title":"Java","date":"2019-09-28T13:11:59.000Z","_content":"# Java基础\n## 编译和解释 (待补充)\n![Java程序运行过程](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png)\n\nC/C++ 编译器将源代码最终编译为机器指令，因此如果要在不同机器上运行程序需要重新编译源码。Java使用另一种方式实现跨平台，即Java虚拟机(JVM)。首先Java编译器(javac, java compiler)将源代码编译为.class文件，当我们需要将程序运行到其他机器上只需要拷贝.class文件运行即可(假设机器都已经安装JVM), JVM会根据具体的CPU指令集架构规范将.class翻译为机器指令。\n\n> 常见的.jar(Java ARchive)是 .class文件的压缩包\n\n## 术语\n- JDK, Java Development Kit, Oracla公司针对Solaris, Linux, Windows, macOS等系统发布的Java软件开发包，包括常用的java开发组件：\n  - javac: 编译器，将后缀名为.java的源码编译成后缀名为\".class\"的字节码\n  - java: 运行工具，运行.class字节码\n  - jar: 打包工具，将相关的类文件打包成一个文件\n  - javadoc: 文档生成器，从源码注释中提取文档，注释需匹配规范\n  - **jdb debugger: 调试工具**\n  - jps: 显示当前java程序运行的进程状态\n  - javap: 反编译程序\n  - javah: 从Java类生成C头文件和源文件。\n  - ***JRE:***  包括一个Java虚拟机（Java Virtual Machine，JVM）以及一些标准的类别函数库（Class Library）\n \n - **Java SE = Standard Edition** 最主要的Java编程平台，包括所有的Java库和API(java.lang, java.io, java.math, java.net, java.util, etc...).\n - **Java EE = Enterprise Edition** 企业版本，添加了容错，分布式等功能\n - **Java ME = Micro Edition** 针对移动设备和嵌入式设备推出的版本，从Java SE中削减了一些功能，并且添加了一些针对移动设备的库\n \n ## JVM 架构\n ![jvm](https://static.javatpoint.com/images/jvm-architecture.png)\n - Class Loader: 类加载器，加载`.class`文件，包括库文件和源码文件，主要由三个内置的加载器构成:\n  - Bootstrap Loader 加载`rt.jar`文件，该文件包含了Java SE 中所有的`.class`文件，如java.lang package classes, java.net package classes, java.util package classes, java.io package classes, java.sql package classes.\n  - Extension ClassLoader: 加载 `$JAVA_HOME/jre/lib/ext`目录中的扩展文件.\n  - System/Application ClassLoader: 加载环境变量`classpath`中的文件，默认为当前工作目录. 可以使用\"-cp\"或者\"-classpath\"改变此路径. \n ```\n public class ClassLoaderExample  \n{  \n    public static void main(String[] args)  \n    {  \n        Class c=ClassLoaderExample.class; \n        // \n        System.out.println(c.getClassLoader());\n        // String在内置库中，因此有Bootstrap Loader加载，返回null\n        System.out.println(String.class.getClassLoader());  \n    }  \n}\n/*\njdk.internal.loader.ClassLoaders$AppClassLoader@1de0aca6\nnull\n*/\n\n- Class(Method) Area   存储运行时常量池，属性，方法数据，方法代码\n- Heap 堆，运行时分配的内存\n- Stack 栈，\n  \n ```\n ## 参考链接\n - [编译模型](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java基础知识.md#jvm)\n - [Java Edition](https://stackoverflow.com/a/33908729)\n - [Java 简介](https://www.javatpoint.com/internal-details-of-jvm)\n\n","source":"_posts/Java.md","raw":"---\ntitle: Java\ndate: 2019-09-28 21:11:59\ntags:\n- Java\n- Java基础\ncategories:\n- 中文\n- Java\n---\n# Java基础\n## 编译和解释 (待补充)\n![Java程序运行过程](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png)\n\nC/C++ 编译器将源代码最终编译为机器指令，因此如果要在不同机器上运行程序需要重新编译源码。Java使用另一种方式实现跨平台，即Java虚拟机(JVM)。首先Java编译器(javac, java compiler)将源代码编译为.class文件，当我们需要将程序运行到其他机器上只需要拷贝.class文件运行即可(假设机器都已经安装JVM), JVM会根据具体的CPU指令集架构规范将.class翻译为机器指令。\n\n> 常见的.jar(Java ARchive)是 .class文件的压缩包\n\n## 术语\n- JDK, Java Development Kit, Oracla公司针对Solaris, Linux, Windows, macOS等系统发布的Java软件开发包，包括常用的java开发组件：\n  - javac: 编译器，将后缀名为.java的源码编译成后缀名为\".class\"的字节码\n  - java: 运行工具，运行.class字节码\n  - jar: 打包工具，将相关的类文件打包成一个文件\n  - javadoc: 文档生成器，从源码注释中提取文档，注释需匹配规范\n  - **jdb debugger: 调试工具**\n  - jps: 显示当前java程序运行的进程状态\n  - javap: 反编译程序\n  - javah: 从Java类生成C头文件和源文件。\n  - ***JRE:***  包括一个Java虚拟机（Java Virtual Machine，JVM）以及一些标准的类别函数库（Class Library）\n \n - **Java SE = Standard Edition** 最主要的Java编程平台，包括所有的Java库和API(java.lang, java.io, java.math, java.net, java.util, etc...).\n - **Java EE = Enterprise Edition** 企业版本，添加了容错，分布式等功能\n - **Java ME = Micro Edition** 针对移动设备和嵌入式设备推出的版本，从Java SE中削减了一些功能，并且添加了一些针对移动设备的库\n \n ## JVM 架构\n ![jvm](https://static.javatpoint.com/images/jvm-architecture.png)\n - Class Loader: 类加载器，加载`.class`文件，包括库文件和源码文件，主要由三个内置的加载器构成:\n  - Bootstrap Loader 加载`rt.jar`文件，该文件包含了Java SE 中所有的`.class`文件，如java.lang package classes, java.net package classes, java.util package classes, java.io package classes, java.sql package classes.\n  - Extension ClassLoader: 加载 `$JAVA_HOME/jre/lib/ext`目录中的扩展文件.\n  - System/Application ClassLoader: 加载环境变量`classpath`中的文件，默认为当前工作目录. 可以使用\"-cp\"或者\"-classpath\"改变此路径. \n ```\n public class ClassLoaderExample  \n{  \n    public static void main(String[] args)  \n    {  \n        Class c=ClassLoaderExample.class; \n        // \n        System.out.println(c.getClassLoader());\n        // String在内置库中，因此有Bootstrap Loader加载，返回null\n        System.out.println(String.class.getClassLoader());  \n    }  \n}\n/*\njdk.internal.loader.ClassLoaders$AppClassLoader@1de0aca6\nnull\n*/\n\n- Class(Method) Area   存储运行时常量池，属性，方法数据，方法代码\n- Heap 堆，运行时分配的内存\n- Stack 栈，\n  \n ```\n ## 参考链接\n - [编译模型](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java基础知识.md#jvm)\n - [Java Edition](https://stackoverflow.com/a/33908729)\n - [Java 简介](https://www.javatpoint.com/internal-details-of-jvm)\n\n","slug":"Java","published":1,"updated":"2020-05-03T06:14:50.679Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixrs000rk4r3ud7hjoh0","content":"<h1 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h1><h2 id=\"编译和解释-待补充\"><a href=\"#编译和解释-待补充\" class=\"headerlink\" title=\"编译和解释 (待补充)\"></a>编译和解释 (待补充)</h2><p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png\" alt=\"Java程序运行过程\"></p>\n<p>C/C++ 编译器将源代码最终编译为机器指令，因此如果要在不同机器上运行程序需要重新编译源码。Java使用另一种方式实现跨平台，即Java虚拟机(JVM)。首先Java编译器(javac, java compiler)将源代码编译为.class文件，当我们需要将程序运行到其他机器上只需要拷贝.class文件运行即可(假设机器都已经安装JVM), JVM会根据具体的CPU指令集架构规范将.class翻译为机器指令。</p>\n<blockquote>\n<p>常见的.jar(Java ARchive)是 .class文件的压缩包</p>\n</blockquote>\n<h2 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h2><ul>\n<li><p>JDK, Java Development Kit, Oracla公司针对Solaris, Linux, Windows, macOS等系统发布的Java软件开发包，包括常用的java开发组件：</p>\n<ul>\n<li>javac: 编译器，将后缀名为.java的源码编译成后缀名为”.class”的字节码</li>\n<li>java: 运行工具，运行.class字节码</li>\n<li>jar: 打包工具，将相关的类文件打包成一个文件</li>\n<li>javadoc: 文档生成器，从源码注释中提取文档，注释需匹配规范</li>\n<li><strong>jdb debugger: 调试工具</strong></li>\n<li>jps: 显示当前java程序运行的进程状态</li>\n<li>javap: 反编译程序</li>\n<li>javah: 从Java类生成C头文件和源文件。</li>\n<li><p><strong><em>JRE:</em></strong>  包括一个Java虚拟机（Java Virtual Machine，JVM）以及一些标准的类别函数库（Class Library）</p>\n</li>\n<li><p><strong>Java SE = Standard Edition</strong> 最主要的Java编程平台，包括所有的Java库和API(java.lang, java.io, java.math, java.net, java.util, etc…).</p>\n</li>\n<li><strong>Java EE = Enterprise Edition</strong> 企业版本，添加了容错，分布式等功能</li>\n<li><strong>Java ME = Micro Edition</strong> 针对移动设备和嵌入式设备推出的版本，从Java SE中削减了一些功能，并且添加了一些针对移动设备的库</li>\n</ul>\n<h2 id=\"JVM-架构\"><a href=\"#JVM-架构\" class=\"headerlink\" title=\"JVM 架构\"></a>JVM 架构</h2><p><img src=\"https://static.javatpoint.com/images/jvm-architecture.png\" alt=\"jvm\"></p>\n<ul>\n<li>Class Loader: 类加载器，加载<code>.class</code>文件，包括库文件和源码文件，主要由三个内置的加载器构成:</li>\n<li>Bootstrap Loader 加载<code>rt.jar</code>文件，该文件包含了Java SE 中所有的<code>.class</code>文件，如java.lang package classes, java.net package classes, java.util package classes, java.io package classes, java.sql package classes.</li>\n<li>Extension ClassLoader: 加载 <code>$JAVA_HOME/jre/lib/ext</code>目录中的扩展文件.</li>\n<li>System/Application ClassLoader: 加载环境变量<code>classpath</code>中的文件，默认为当前工作目录. 可以使用”-cp”或者”-classpath”改变此路径. <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public class ClassLoaderExample  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    public static void main(String[] args)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        Class c=ClassLoaderExample.class; </span><br><span class=\"line\">        // </span><br><span class=\"line\">        System.out.println(c.getClassLoader());</span><br><span class=\"line\">        // String在内置库中，因此有Bootstrap Loader加载，返回null</span><br><span class=\"line\">        System.out.println(String.class.getClassLoader());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*</span><br><span class=\"line\">jdk.internal.loader.ClassLoaders$AppClassLoader@1de0aca6</span><br><span class=\"line\">null</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">- Class(Method) Area   存储运行时常量池，属性，方法数据，方法代码</span><br><span class=\"line\">- Heap 堆，运行时分配的内存</span><br><span class=\"line\">- Stack 栈，</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java基础知识.md#jvm\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">编译模型</a></li>\n<li><a href=\"https://stackoverflow.com/a/33908729\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Java Edition</a></li>\n<li><a href=\"https://www.javatpoint.com/internal-details-of-jvm\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Java 简介</a></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h1><h2 id=\"编译和解释-待补充\"><a href=\"#编译和解释-待补充\" class=\"headerlink\" title=\"编译和解释 (待补充)\"></a>编译和解释 (待补充)</h2><p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png\" alt=\"Java程序运行过程\"></p>\n<p>C/C++ 编译器将源代码最终编译为机器指令，因此如果要在不同机器上运行程序需要重新编译源码。Java使用另一种方式实现跨平台，即Java虚拟机(JVM)。首先Java编译器(javac, java compiler)将源代码编译为.class文件，当我们需要将程序运行到其他机器上只需要拷贝.class文件运行即可(假设机器都已经安装JVM), JVM会根据具体的CPU指令集架构规范将.class翻译为机器指令。</p>\n<blockquote>\n<p>常见的.jar(Java ARchive)是 .class文件的压缩包</p>\n</blockquote>\n<h2 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h2><ul>\n<li><p>JDK, Java Development Kit, Oracla公司针对Solaris, Linux, Windows, macOS等系统发布的Java软件开发包，包括常用的java开发组件：</p>\n<ul>\n<li>javac: 编译器，将后缀名为.java的源码编译成后缀名为”.class”的字节码</li>\n<li>java: 运行工具，运行.class字节码</li>\n<li>jar: 打包工具，将相关的类文件打包成一个文件</li>\n<li>javadoc: 文档生成器，从源码注释中提取文档，注释需匹配规范</li>\n<li><strong>jdb debugger: 调试工具</strong></li>\n<li>jps: 显示当前java程序运行的进程状态</li>\n<li>javap: 反编译程序</li>\n<li>javah: 从Java类生成C头文件和源文件。</li>\n<li><p><strong><em>JRE:</em></strong>  包括一个Java虚拟机（Java Virtual Machine，JVM）以及一些标准的类别函数库（Class Library）</p>\n</li>\n<li><p><strong>Java SE = Standard Edition</strong> 最主要的Java编程平台，包括所有的Java库和API(java.lang, java.io, java.math, java.net, java.util, etc…).</p>\n</li>\n<li><strong>Java EE = Enterprise Edition</strong> 企业版本，添加了容错，分布式等功能</li>\n<li><strong>Java ME = Micro Edition</strong> 针对移动设备和嵌入式设备推出的版本，从Java SE中削减了一些功能，并且添加了一些针对移动设备的库</li>\n</ul>\n<h2 id=\"JVM-架构\"><a href=\"#JVM-架构\" class=\"headerlink\" title=\"JVM 架构\"></a>JVM 架构</h2><p><img src=\"https://static.javatpoint.com/images/jvm-architecture.png\" alt=\"jvm\"></p>\n<ul>\n<li>Class Loader: 类加载器，加载<code>.class</code>文件，包括库文件和源码文件，主要由三个内置的加载器构成:</li>\n<li>Bootstrap Loader 加载<code>rt.jar</code>文件，该文件包含了Java SE 中所有的<code>.class</code>文件，如java.lang package classes, java.net package classes, java.util package classes, java.io package classes, java.sql package classes.</li>\n<li>Extension ClassLoader: 加载 <code>$JAVA_HOME/jre/lib/ext</code>目录中的扩展文件.</li>\n<li>System/Application ClassLoader: 加载环境变量<code>classpath</code>中的文件，默认为当前工作目录. 可以使用”-cp”或者”-classpath”改变此路径. <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public class ClassLoaderExample  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    public static void main(String[] args)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        Class c=ClassLoaderExample.class; </span><br><span class=\"line\">        // </span><br><span class=\"line\">        System.out.println(c.getClassLoader());</span><br><span class=\"line\">        // String在内置库中，因此有Bootstrap Loader加载，返回null</span><br><span class=\"line\">        System.out.println(String.class.getClassLoader());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*</span><br><span class=\"line\">jdk.internal.loader.ClassLoaders$AppClassLoader@1de0aca6</span><br><span class=\"line\">null</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">- Class(Method) Area   存储运行时常量池，属性，方法数据，方法代码</span><br><span class=\"line\">- Heap 堆，运行时分配的内存</span><br><span class=\"line\">- Stack 栈，</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java基础知识.md#jvm\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">编译模型</a></li>\n<li><a href=\"https://stackoverflow.com/a/33908729\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Java Edition</a></li>\n<li><a href=\"https://www.javatpoint.com/internal-details-of-jvm\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Java 简介</a></li>\n</ul>\n</li>\n</ul>\n"},{"title":"92 Reverse Linked List II","date":"2019-11-27T06:36:54.000Z","_content":"","source":"_posts/92-Reverse-Linked-List-II.md","raw":"---\ntitle: 92 Reverse Linked List II\ndate: 2019-11-27 14:36:54\ntags:\n---\n","slug":"92-Reverse-Linked-List-II","published":1,"updated":"2020-05-03T06:14:50.678Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixru000sk4r3irte19f8","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"87 Scramble String","date":"2019-11-06T10:34:07.000Z","comments":1,"_content":"# Intuition\nThis is a ***dynamic programming*** problem. Given two string `S1(1,2,3,...,n)` and `S2(1,2,3,...,n)`, they are scramble if and only if:\n1. `S1(1,2,3,...,i) and S2(1,2,3,...,i) are scramble` and `S1( i+1,...,n) and S2(i+1,...,n) are scramble`\n> For `abb` and `bab`, they can be seperated into two parts: `ab` and `ba` are scramble , `b` and `b`\nare scramble.\n2. `S1(1,2,3,...,i) and S2(n-i+1,n-i+2,...,n) are scramble` and `S1( i+1,...,n) and S2(1,2,...,n-i) are scamble`\n> In the above cases, `ab` and `ba` are scramble because they can be seperated into two parts, `a` and `b`, `b` and `a`, the left part of the first string equals the right part of the second string, the right part of the left equals the left part of the second, they are symmetric.\n\nThe termination condition for this recursion solution is two strings are equal.\n\n# Algorithm\n###### Recusion\n\n*Termination Condition:* If two strings are equal, then they are also scramble.\n\n*Recursion Process:* For `S1(1,2,3,...,n)`,  `S2(1,2,3,...,n)` and a specified substring size `i` ranging from 1 to n, we need to split the strings into two parts, and check if the substrings are scramble according to the illustration stated before.\n\n*Trick:* We can do a precheck before recusion process, it's much less time consumping than recusion. We can store how many times each character appears in both strings, if they are not equal, these two strings can never be scamble. Say `afbihuifafaf` and `ghuiigafsafh`, if we donot have this precheck process, we have to compare:\n\n> `a` and `g`, `fbihuifafaf` and `huiigafsafh` <br/>\n> `a` and `h`, `fbihuifafaf` and `ghuiigafsaf`<br/>\n>`af` and `gh`, `bihuifafaf` and `uiigafsafh` <br/>\n> ...\n\nThat's a huge workload!\n###### Iteration\n\n*State Transition:* dp[n][n][n+1] is state matrix, dp[i][j][k] denotes if substring `S1(i, i+1, ..., i+k-1)` and `S2(j, j+1, ..., j+k-1)` are scramble. So dp[0][0][n] is our final answer. According to above analysis, state transition equation should be:\n```\ndp[i][j][k] = (dp[i][j][p] && dp[i+p][j+p][k-p])||(dp[i][j+k-p][p] && dp[i+p][j][k-p]) p={1,2,...,k-1}\n```\n\n# Code\n###### Recusion\n```\nclass Solution {\n    public boolean isScramble(String s1, String s2) {\n        if(s1.equals(s2))\n            return true;\n        if(s1.length() == 1 && !s1.equals(s2))\n            return false;\n        int[] letters = new int[26];\n        for (int i=0; i<s1.length(); i++) {\n            letters[s1.charAt(i)-'a']++;\n            letters[s2.charAt(i)-'a']--;\n        }\n        for (int i=0; i<26; i++) if (letters[i]!=0) return false;\n        \n        for(int i = 1; i < s1.length(); i++){\n            String s1_left = s1.substring(0, i);\n            String s2_left = s2.substring(0, i);\n            String s1_right = s1.substring(i);\n            String s2_right = s2.substring(i);\n            if(isScramble(s1_left, s2_left) && \n                isScramble(s1_right, s2_right))return true;\n            if(isScramble(s1.substring(0, i), s2.substring(s2.length()-i, s2.length())) && \n                isScramble(s1.substring(i, s1.length()), s2.substring(0, s1.length()-i)))return true;\n        }\n        return false;\n    }\n}\n```\n\n###### Iteration\n```\nclass Solution {\n    public boolean isScramble(String s1, String s2) {\n        if(s1.equals(s2))return true; //include corner case:  \"\" and \"\" \n        int n = s1.length(); // the question statement has clarified s1.length() == s2.length()\n        boolean[][][] dp = new boolean[n][n][n+1];\n        for(int k = 1; k <= n; k++){\n            for(int i = 0; i <= n-k; i++){\n                for(int j = 0; j <= n - k; j++){\n                    if(k == 1){\n                        dp[i][j][k] = s1.substring(i, i+1).equals(s2.substring(j, j+1));\n                    }\n                    else{\n                        dp[i][j][k] = false;\n                        for(int p = 1 ; p < k; p++){\n                            if( (dp[i][j][p]&&dp[i+p][j+p][k-p]) || (dp[i][j+k-p][p]&&dp[i+p][j][k-p]))\n                            {\n                                dp[i][j][k] = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dp[0][0][n];\n    }\n}\n```\n# Complexity\n\n###### Recursion\n\n***Time Complexity:*** O(2^n)\n\n***Space Complexity:** *O(2^n), See the blog [here](http://n00tc0d3r.blogspot.com/2013/05/scramble-string.html)\n\n###### Iteration\n***Time Comlexity:*** For the iteration solution, it's easy to figure out the approximate time complexity, since we have four for loop, it costs O(n^4). The accurate analysis is more complicated, you can refer to discussions [here](https://leetcode.com/problems/scramble-string/discuss/29387/Accepted-Java-solution) or the [blog](http://n00tc0d3r.blogspot.com/2013/05/scramble-string.html).\n\n***Space Complexity:*** O(n^3), costs for the array`dp[n][n][n+1]`\n","source":"_posts/87-Scramble-String.md","raw":"---\ntitle: 87 Scramble String\ndate: 2019-11-06 18:34:07\ncategories:\n- LeetCode\ncomments: true\ntags:\n- dynamic programming\n---\n# Intuition\nThis is a ***dynamic programming*** problem. Given two string `S1(1,2,3,...,n)` and `S2(1,2,3,...,n)`, they are scramble if and only if:\n1. `S1(1,2,3,...,i) and S2(1,2,3,...,i) are scramble` and `S1( i+1,...,n) and S2(i+1,...,n) are scramble`\n> For `abb` and `bab`, they can be seperated into two parts: `ab` and `ba` are scramble , `b` and `b`\nare scramble.\n2. `S1(1,2,3,...,i) and S2(n-i+1,n-i+2,...,n) are scramble` and `S1( i+1,...,n) and S2(1,2,...,n-i) are scamble`\n> In the above cases, `ab` and `ba` are scramble because they can be seperated into two parts, `a` and `b`, `b` and `a`, the left part of the first string equals the right part of the second string, the right part of the left equals the left part of the second, they are symmetric.\n\nThe termination condition for this recursion solution is two strings are equal.\n\n# Algorithm\n###### Recusion\n\n*Termination Condition:* If two strings are equal, then they are also scramble.\n\n*Recursion Process:* For `S1(1,2,3,...,n)`,  `S2(1,2,3,...,n)` and a specified substring size `i` ranging from 1 to n, we need to split the strings into two parts, and check if the substrings are scramble according to the illustration stated before.\n\n*Trick:* We can do a precheck before recusion process, it's much less time consumping than recusion. We can store how many times each character appears in both strings, if they are not equal, these two strings can never be scamble. Say `afbihuifafaf` and `ghuiigafsafh`, if we donot have this precheck process, we have to compare:\n\n> `a` and `g`, `fbihuifafaf` and `huiigafsafh` <br/>\n> `a` and `h`, `fbihuifafaf` and `ghuiigafsaf`<br/>\n>`af` and `gh`, `bihuifafaf` and `uiigafsafh` <br/>\n> ...\n\nThat's a huge workload!\n###### Iteration\n\n*State Transition:* dp[n][n][n+1] is state matrix, dp[i][j][k] denotes if substring `S1(i, i+1, ..., i+k-1)` and `S2(j, j+1, ..., j+k-1)` are scramble. So dp[0][0][n] is our final answer. According to above analysis, state transition equation should be:\n```\ndp[i][j][k] = (dp[i][j][p] && dp[i+p][j+p][k-p])||(dp[i][j+k-p][p] && dp[i+p][j][k-p]) p={1,2,...,k-1}\n```\n\n# Code\n###### Recusion\n```\nclass Solution {\n    public boolean isScramble(String s1, String s2) {\n        if(s1.equals(s2))\n            return true;\n        if(s1.length() == 1 && !s1.equals(s2))\n            return false;\n        int[] letters = new int[26];\n        for (int i=0; i<s1.length(); i++) {\n            letters[s1.charAt(i)-'a']++;\n            letters[s2.charAt(i)-'a']--;\n        }\n        for (int i=0; i<26; i++) if (letters[i]!=0) return false;\n        \n        for(int i = 1; i < s1.length(); i++){\n            String s1_left = s1.substring(0, i);\n            String s2_left = s2.substring(0, i);\n            String s1_right = s1.substring(i);\n            String s2_right = s2.substring(i);\n            if(isScramble(s1_left, s2_left) && \n                isScramble(s1_right, s2_right))return true;\n            if(isScramble(s1.substring(0, i), s2.substring(s2.length()-i, s2.length())) && \n                isScramble(s1.substring(i, s1.length()), s2.substring(0, s1.length()-i)))return true;\n        }\n        return false;\n    }\n}\n```\n\n###### Iteration\n```\nclass Solution {\n    public boolean isScramble(String s1, String s2) {\n        if(s1.equals(s2))return true; //include corner case:  \"\" and \"\" \n        int n = s1.length(); // the question statement has clarified s1.length() == s2.length()\n        boolean[][][] dp = new boolean[n][n][n+1];\n        for(int k = 1; k <= n; k++){\n            for(int i = 0; i <= n-k; i++){\n                for(int j = 0; j <= n - k; j++){\n                    if(k == 1){\n                        dp[i][j][k] = s1.substring(i, i+1).equals(s2.substring(j, j+1));\n                    }\n                    else{\n                        dp[i][j][k] = false;\n                        for(int p = 1 ; p < k; p++){\n                            if( (dp[i][j][p]&&dp[i+p][j+p][k-p]) || (dp[i][j+k-p][p]&&dp[i+p][j][k-p]))\n                            {\n                                dp[i][j][k] = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dp[0][0][n];\n    }\n}\n```\n# Complexity\n\n###### Recursion\n\n***Time Complexity:*** O(2^n)\n\n***Space Complexity:** *O(2^n), See the blog [here](http://n00tc0d3r.blogspot.com/2013/05/scramble-string.html)\n\n###### Iteration\n***Time Comlexity:*** For the iteration solution, it's easy to figure out the approximate time complexity, since we have four for loop, it costs O(n^4). The accurate analysis is more complicated, you can refer to discussions [here](https://leetcode.com/problems/scramble-string/discuss/29387/Accepted-Java-solution) or the [blog](http://n00tc0d3r.blogspot.com/2013/05/scramble-string.html).\n\n***Space Complexity:*** O(n^3), costs for the array`dp[n][n][n+1]`\n","slug":"87-Scramble-String","published":1,"updated":"2020-05-03T06:14:50.677Z","layout":"post","photos":[],"link":"","_id":"cka27ixrv000tk4r38g29ulyl","content":"<h1 id=\"Intuition\"><a href=\"#Intuition\" class=\"headerlink\" title=\"Intuition\"></a>Intuition</h1><p>This is a <strong><em>dynamic programming</em></strong> problem. Given two string <code>S1(1,2,3,...,n)</code> and <code>S2(1,2,3,...,n)</code>, they are scramble if and only if:</p>\n<ol>\n<li><code>S1(1,2,3,...,i) and S2(1,2,3,...,i) are scramble</code> and <code>S1( i+1,...,n) and S2(i+1,...,n) are scramble</code><blockquote>\n<p>For <code>abb</code> and <code>bab</code>, they can be seperated into two parts: <code>ab</code> and <code>ba</code> are scramble , <code>b</code> and <code>b</code><br>are scramble.</p>\n</blockquote>\n</li>\n<li><code>S1(1,2,3,...,i) and S2(n-i+1,n-i+2,...,n) are scramble</code> and <code>S1( i+1,...,n) and S2(1,2,...,n-i) are scamble</code><blockquote>\n<p>In the above cases, <code>ab</code> and <code>ba</code> are scramble because they can be seperated into two parts, <code>a</code> and <code>b</code>, <code>b</code> and <code>a</code>, the left part of the first string equals the right part of the second string, the right part of the left equals the left part of the second, they are symmetric.</p>\n</blockquote>\n</li>\n</ol>\n<p>The termination condition for this recursion solution is two strings are equal.</p>\n<h1 id=\"Algorithm\"><a href=\"#Algorithm\" class=\"headerlink\" title=\"Algorithm\"></a>Algorithm</h1><h6 id=\"Recusion\"><a href=\"#Recusion\" class=\"headerlink\" title=\"Recusion\"></a>Recusion</h6><p><em>Termination Condition:</em> If two strings are equal, then they are also scramble.</p>\n<p><em>Recursion Process:</em> For <code>S1(1,2,3,...,n)</code>,  <code>S2(1,2,3,...,n)</code> and a specified substring size <code>i</code> ranging from 1 to n, we need to split the strings into two parts, and check if the substrings are scramble according to the illustration stated before.</p>\n<p><em>Trick:</em> We can do a precheck before recusion process, it’s much less time consumping than recusion. We can store how many times each character appears in both strings, if they are not equal, these two strings can never be scamble. Say <code>afbihuifafaf</code> and <code>ghuiigafsafh</code>, if we donot have this precheck process, we have to compare:</p>\n<blockquote>\n<p><code>a</code> and <code>g</code>, <code>fbihuifafaf</code> and <code>huiigafsafh</code> <br><br><code>a</code> and <code>h</code>, <code>fbihuifafaf</code> and <code>ghuiigafsaf</code><br><br><code>af</code> and <code>gh</code>, <code>bihuifafaf</code> and <code>uiigafsafh</code> <br><br>…</p>\n</blockquote>\n<p>That’s a huge workload!</p>\n<h6 id=\"Iteration\"><a href=\"#Iteration\" class=\"headerlink\" title=\"Iteration\"></a>Iteration</h6><p><em>State Transition:</em> dp[n][n][n+1] is state matrix, dp[i][j][k] denotes if substring <code>S1(i, i+1, ..., i+k-1)</code> and <code>S2(j, j+1, ..., j+k-1)</code> are scramble. So dp[0][0][n] is our final answer. According to above analysis, state transition equation should be:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp[i][j][k] = (dp[i][j][p] &amp;&amp; dp[i+p][j+p][k-p])||(dp[i][j+k-p][p] &amp;&amp; dp[i+p][j][k-p]) p=&#123;1,2,...,k-1&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><h6 id=\"Recusion-1\"><a href=\"#Recusion-1\" class=\"headerlink\" title=\"Recusion\"></a>Recusion</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean isScramble(String s1, String s2) &#123;</span><br><span class=\"line\">        if(s1.equals(s2))</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        if(s1.length() == 1 &amp;&amp; !s1.equals(s2))</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        int[] letters = new int[26];</span><br><span class=\"line\">        for (int i=0; i&lt;s1.length(); i++) &#123;</span><br><span class=\"line\">            letters[s1.charAt(i)-&apos;a&apos;]++;</span><br><span class=\"line\">            letters[s2.charAt(i)-&apos;a&apos;]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for (int i=0; i&lt;26; i++) if (letters[i]!=0) return false;</span><br><span class=\"line\">        </span><br><span class=\"line\">        for(int i = 1; i &lt; s1.length(); i++)&#123;</span><br><span class=\"line\">            String s1_left = s1.substring(0, i);</span><br><span class=\"line\">            String s2_left = s2.substring(0, i);</span><br><span class=\"line\">            String s1_right = s1.substring(i);</span><br><span class=\"line\">            String s2_right = s2.substring(i);</span><br><span class=\"line\">            if(isScramble(s1_left, s2_left) &amp;&amp; </span><br><span class=\"line\">                isScramble(s1_right, s2_right))return true;</span><br><span class=\"line\">            if(isScramble(s1.substring(0, i), s2.substring(s2.length()-i, s2.length())) &amp;&amp; </span><br><span class=\"line\">                isScramble(s1.substring(i, s1.length()), s2.substring(0, s1.length()-i)))return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"Iteration-1\"><a href=\"#Iteration-1\" class=\"headerlink\" title=\"Iteration\"></a>Iteration</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean isScramble(String s1, String s2) &#123;</span><br><span class=\"line\">        if(s1.equals(s2))return true; //include corner case:  &quot;&quot; and &quot;&quot; </span><br><span class=\"line\">        int n = s1.length(); // the question statement has clarified s1.length() == s2.length()</span><br><span class=\"line\">        boolean[][][] dp = new boolean[n][n][n+1];</span><br><span class=\"line\">        for(int k = 1; k &lt;= n; k++)&#123;</span><br><span class=\"line\">            for(int i = 0; i &lt;= n-k; i++)&#123;</span><br><span class=\"line\">                for(int j = 0; j &lt;= n - k; j++)&#123;</span><br><span class=\"line\">                    if(k == 1)&#123;</span><br><span class=\"line\">                        dp[i][j][k] = s1.substring(i, i+1).equals(s2.substring(j, j+1));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    else&#123;</span><br><span class=\"line\">                        dp[i][j][k] = false;</span><br><span class=\"line\">                        for(int p = 1 ; p &lt; k; p++)&#123;</span><br><span class=\"line\">                            if( (dp[i][j][p]&amp;&amp;dp[i+p][j+p][k-p]) || (dp[i][j+k-p][p]&amp;&amp;dp[i+p][j][k-p]))</span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                dp[i][j][k] = true;</span><br><span class=\"line\">                                break;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[0][0][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><h6 id=\"Recursion\"><a href=\"#Recursion\" class=\"headerlink\" title=\"Recursion\"></a>Recursion</h6><p><strong><em>Time Complexity:</em></strong> O(2^n)</p>\n<p><strong>*Space Complexity:</strong> *O(2^n), See the blog <a href=\"http://n00tc0d3r.blogspot.com/2013/05/scramble-string.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">here</a></p>\n<h6 id=\"Iteration-2\"><a href=\"#Iteration-2\" class=\"headerlink\" title=\"Iteration\"></a>Iteration</h6><p><strong><em>Time Comlexity:</em></strong> For the iteration solution, it’s easy to figure out the approximate time complexity, since we have four for loop, it costs O(n^4). The accurate analysis is more complicated, you can refer to discussions <a href=\"https://leetcode.com/problems/scramble-string/discuss/29387/Accepted-Java-solution\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">here</a> or the <a href=\"http://n00tc0d3r.blogspot.com/2013/05/scramble-string.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">blog</a>.</p>\n<p><strong><em>Space Complexity:</em></strong> O(n^3), costs for the array<code>dp[n][n][n+1]</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Intuition\"><a href=\"#Intuition\" class=\"headerlink\" title=\"Intuition\"></a>Intuition</h1><p>This is a <strong><em>dynamic programming</em></strong> problem. Given two string <code>S1(1,2,3,...,n)</code> and <code>S2(1,2,3,...,n)</code>, they are scramble if and only if:</p>\n<ol>\n<li><code>S1(1,2,3,...,i) and S2(1,2,3,...,i) are scramble</code> and <code>S1( i+1,...,n) and S2(i+1,...,n) are scramble</code><blockquote>\n<p>For <code>abb</code> and <code>bab</code>, they can be seperated into two parts: <code>ab</code> and <code>ba</code> are scramble , <code>b</code> and <code>b</code><br>are scramble.</p>\n</blockquote>\n</li>\n<li><code>S1(1,2,3,...,i) and S2(n-i+1,n-i+2,...,n) are scramble</code> and <code>S1( i+1,...,n) and S2(1,2,...,n-i) are scamble</code><blockquote>\n<p>In the above cases, <code>ab</code> and <code>ba</code> are scramble because they can be seperated into two parts, <code>a</code> and <code>b</code>, <code>b</code> and <code>a</code>, the left part of the first string equals the right part of the second string, the right part of the left equals the left part of the second, they are symmetric.</p>\n</blockquote>\n</li>\n</ol>\n<p>The termination condition for this recursion solution is two strings are equal.</p>\n<h1 id=\"Algorithm\"><a href=\"#Algorithm\" class=\"headerlink\" title=\"Algorithm\"></a>Algorithm</h1><h6 id=\"Recusion\"><a href=\"#Recusion\" class=\"headerlink\" title=\"Recusion\"></a>Recusion</h6><p><em>Termination Condition:</em> If two strings are equal, then they are also scramble.</p>\n<p><em>Recursion Process:</em> For <code>S1(1,2,3,...,n)</code>,  <code>S2(1,2,3,...,n)</code> and a specified substring size <code>i</code> ranging from 1 to n, we need to split the strings into two parts, and check if the substrings are scramble according to the illustration stated before.</p>\n<p><em>Trick:</em> We can do a precheck before recusion process, it’s much less time consumping than recusion. We can store how many times each character appears in both strings, if they are not equal, these two strings can never be scamble. Say <code>afbihuifafaf</code> and <code>ghuiigafsafh</code>, if we donot have this precheck process, we have to compare:</p>\n<blockquote>\n<p><code>a</code> and <code>g</code>, <code>fbihuifafaf</code> and <code>huiigafsafh</code> <br><br><code>a</code> and <code>h</code>, <code>fbihuifafaf</code> and <code>ghuiigafsaf</code><br><br><code>af</code> and <code>gh</code>, <code>bihuifafaf</code> and <code>uiigafsafh</code> <br><br>…</p>\n</blockquote>\n<p>That’s a huge workload!</p>\n<h6 id=\"Iteration\"><a href=\"#Iteration\" class=\"headerlink\" title=\"Iteration\"></a>Iteration</h6><p><em>State Transition:</em> dp[n][n][n+1] is state matrix, dp[i][j][k] denotes if substring <code>S1(i, i+1, ..., i+k-1)</code> and <code>S2(j, j+1, ..., j+k-1)</code> are scramble. So dp[0][0][n] is our final answer. According to above analysis, state transition equation should be:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp[i][j][k] = (dp[i][j][p] &amp;&amp; dp[i+p][j+p][k-p])||(dp[i][j+k-p][p] &amp;&amp; dp[i+p][j][k-p]) p=&#123;1,2,...,k-1&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><h6 id=\"Recusion-1\"><a href=\"#Recusion-1\" class=\"headerlink\" title=\"Recusion\"></a>Recusion</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean isScramble(String s1, String s2) &#123;</span><br><span class=\"line\">        if(s1.equals(s2))</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        if(s1.length() == 1 &amp;&amp; !s1.equals(s2))</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        int[] letters = new int[26];</span><br><span class=\"line\">        for (int i=0; i&lt;s1.length(); i++) &#123;</span><br><span class=\"line\">            letters[s1.charAt(i)-&apos;a&apos;]++;</span><br><span class=\"line\">            letters[s2.charAt(i)-&apos;a&apos;]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for (int i=0; i&lt;26; i++) if (letters[i]!=0) return false;</span><br><span class=\"line\">        </span><br><span class=\"line\">        for(int i = 1; i &lt; s1.length(); i++)&#123;</span><br><span class=\"line\">            String s1_left = s1.substring(0, i);</span><br><span class=\"line\">            String s2_left = s2.substring(0, i);</span><br><span class=\"line\">            String s1_right = s1.substring(i);</span><br><span class=\"line\">            String s2_right = s2.substring(i);</span><br><span class=\"line\">            if(isScramble(s1_left, s2_left) &amp;&amp; </span><br><span class=\"line\">                isScramble(s1_right, s2_right))return true;</span><br><span class=\"line\">            if(isScramble(s1.substring(0, i), s2.substring(s2.length()-i, s2.length())) &amp;&amp; </span><br><span class=\"line\">                isScramble(s1.substring(i, s1.length()), s2.substring(0, s1.length()-i)))return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"Iteration-1\"><a href=\"#Iteration-1\" class=\"headerlink\" title=\"Iteration\"></a>Iteration</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean isScramble(String s1, String s2) &#123;</span><br><span class=\"line\">        if(s1.equals(s2))return true; //include corner case:  &quot;&quot; and &quot;&quot; </span><br><span class=\"line\">        int n = s1.length(); // the question statement has clarified s1.length() == s2.length()</span><br><span class=\"line\">        boolean[][][] dp = new boolean[n][n][n+1];</span><br><span class=\"line\">        for(int k = 1; k &lt;= n; k++)&#123;</span><br><span class=\"line\">            for(int i = 0; i &lt;= n-k; i++)&#123;</span><br><span class=\"line\">                for(int j = 0; j &lt;= n - k; j++)&#123;</span><br><span class=\"line\">                    if(k == 1)&#123;</span><br><span class=\"line\">                        dp[i][j][k] = s1.substring(i, i+1).equals(s2.substring(j, j+1));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    else&#123;</span><br><span class=\"line\">                        dp[i][j][k] = false;</span><br><span class=\"line\">                        for(int p = 1 ; p &lt; k; p++)&#123;</span><br><span class=\"line\">                            if( (dp[i][j][p]&amp;&amp;dp[i+p][j+p][k-p]) || (dp[i][j+k-p][p]&amp;&amp;dp[i+p][j][k-p]))</span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                dp[i][j][k] = true;</span><br><span class=\"line\">                                break;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[0][0][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><h6 id=\"Recursion\"><a href=\"#Recursion\" class=\"headerlink\" title=\"Recursion\"></a>Recursion</h6><p><strong><em>Time Complexity:</em></strong> O(2^n)</p>\n<p><strong>*Space Complexity:</strong> *O(2^n), See the blog <a href=\"http://n00tc0d3r.blogspot.com/2013/05/scramble-string.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">here</a></p>\n<h6 id=\"Iteration-2\"><a href=\"#Iteration-2\" class=\"headerlink\" title=\"Iteration\"></a>Iteration</h6><p><strong><em>Time Comlexity:</em></strong> For the iteration solution, it’s easy to figure out the approximate time complexity, since we have four for loop, it costs O(n^4). The accurate analysis is more complicated, you can refer to discussions <a href=\"https://leetcode.com/problems/scramble-string/discuss/29387/Accepted-Java-solution\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">here</a> or the <a href=\"http://n00tc0d3r.blogspot.com/2013/05/scramble-string.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">blog</a>.</p>\n<p><strong><em>Space Complexity:</em></strong> O(n^3), costs for the array<code>dp[n][n][n+1]</code></p>\n"},{"title":"99 Recover Binary Search Tree","date":"2019-11-04T16:08:35.000Z","comments":1,"_content":"## Intuition & Algorithm\nAccording to the location of the two nodes being exchanged, it can be divided into five cases, assuming that the original sequence is 1，2，3，4，5，6，7，the two node locations exchanged arei, j\n\n1. The two elements of the exchange are in the middle of the sequence, without the situation on both sides, say 2,6,  then\n    * Before Exchange   `a[i-1] < a[i] < a[i+1]` `a[j-1] < a[j] < a[j+1]`\n    * After Exchange  &nbsp; `a[i-1] < a[i] > a[i+1]` `a[j-1] > a[j] < a[j+1]`\n    * Different Part &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;` a[i] > a[i+1]` `a[j-1] > a[j]`\n2. The smaller element is in the first place, the larger element is in the middle of the sequence, such as 1,5, then\n    * Before Exchange   `a[i] < a[i+1]` `a[j-1] < a[j] < a[j+1]`\n    * After Exchange   &nbsp; `a[i] > a[i+1]` `a[j-1] > a[j] < a[j+1]`\n    * Different Part &nbsp;&nbsp;&nbsp;&nbsp; ` a[i] > a[i+1]` `a[j-1] > a[j]`\n3. The smaller element is in the middle of the sequence, the larger element is at the end, such as 3, 7, then\n    * Before Exchange   `a[i-1] < a[i] < a[i+1]` `a[j-1] < a[j]`\n    * After Exchange &nbsp;  `a[i-1] < a[i] > a[i+1]` `a[j-1] > a[j]`\n    * Different Part &nbsp;&nbsp;&nbsp;&nbsp; ` a[i] > a[i+1]` &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;`a[j-1] > a[j]`\n4. The smaller elements are at the top of the sequence, and the larger ones are at the end, ie 1,7,  then:\n    * Before Exchange   ` a[i] < a[i+1]` `a[j-1] < a[j]`\n    * After Exchange   ` a[i] > a[i+1]` `a[j-1] > a[j]`\n    * Different Part &nbsp;&nbsp;&nbsp; ` a[i] > a[i+1]` `a[j-1] > a[j]`\n5. adjacent elements， say 3 and 7， then\n    * Before Exchange   ` a[i] < a[i+1]` \n    * After Exchange   ` a[i] > a[i+1]` \n    * Different Part&nbsp;&nbsp;&nbsp; ` a[i] > a[i+1]` \n\nTherefore, by detecting the anomaly, the two elements exchanged can be found. The anomaly can be summarized as one case: ` a[k] > a[k+1]`. In the case of an exception, the kth point and k+1th point can both be the exchange position, depending on the number of occurrence of the anomaly. If it is the first time an exception occurs, it must be that the larger element is changed to the front, so k is the abnormal point. If it is the second time, it must be that the  smaller element is changed to the back, so k+1 is the abnormal point, and there is an adjacent case, that is, the exception only appears once, and can be assumed by the **The two positions of the secondary anomaly are all abnormal points, and if a second exception occurs, the smaller abnormal points are overlayed.**.\n\nThe Java code is as follows, it should be noted that\n- The value of the two nodes is directly exchanged in the code. It is also very simple to exchange two nodes.\n- `A solution using O(n) space is pretty straight forward.` this narrative should refer to `using an array with length n to store the binary tree after the traversal, and then find the location of the two exceptions.` This algorithm is easy to implement, and the solution in the constant space should be referred to use constant space except traversal. Or think so, to find the two exchanged points we  must traverse over all the nodes, so the consumption of traversing the tree is inevitable.\n\n# Complexity\n**Time complexity: ** Detecting anomalies requires traversing all nodes, so it is O(N)\n\n**Spatial complexity** See the analysis in the previous section. Strictly consider the consumption of the stack in recursion is O(logN)\n```\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    TreeNode pre, small, large;\n    public void recoverTree(TreeNode root) {\n        inTraverse(root);\n        int v1 = small.val;\n        small.val = large.val;\n        large.val = v1;\n    }\n    \n    void inTraverse(TreeNode root){\n        if(root == null)return;\n        inTraverse(root.left);\n        if(pre == null){// 第一个节点\n            pre  = root;\n        }\n        else{\n            if(root.val < pre.val){\n                if(large == null){\n                    large = pre;\n                    small = root;\n                }\n                else\n                    small = root;\n            }\n            pre = root;\n        }\n        inTraverse(root.right);\n    }\n    \n}\n```\n\n","source":"_posts/99-Recover-Binary-Search-Tree.md","raw":"---\ntitle: 99 Recover Binary Search Tree\ndate: 2019-11-05 00:08:35\ncategories:\n- LeetCode\ncomments: true\ntags:\n- binary tree\n---\n## Intuition & Algorithm\nAccording to the location of the two nodes being exchanged, it can be divided into five cases, assuming that the original sequence is 1，2，3，4，5，6，7，the two node locations exchanged arei, j\n\n1. The two elements of the exchange are in the middle of the sequence, without the situation on both sides, say 2,6,  then\n    * Before Exchange   `a[i-1] < a[i] < a[i+1]` `a[j-1] < a[j] < a[j+1]`\n    * After Exchange  &nbsp; `a[i-1] < a[i] > a[i+1]` `a[j-1] > a[j] < a[j+1]`\n    * Different Part &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;` a[i] > a[i+1]` `a[j-1] > a[j]`\n2. The smaller element is in the first place, the larger element is in the middle of the sequence, such as 1,5, then\n    * Before Exchange   `a[i] < a[i+1]` `a[j-1] < a[j] < a[j+1]`\n    * After Exchange   &nbsp; `a[i] > a[i+1]` `a[j-1] > a[j] < a[j+1]`\n    * Different Part &nbsp;&nbsp;&nbsp;&nbsp; ` a[i] > a[i+1]` `a[j-1] > a[j]`\n3. The smaller element is in the middle of the sequence, the larger element is at the end, such as 3, 7, then\n    * Before Exchange   `a[i-1] < a[i] < a[i+1]` `a[j-1] < a[j]`\n    * After Exchange &nbsp;  `a[i-1] < a[i] > a[i+1]` `a[j-1] > a[j]`\n    * Different Part &nbsp;&nbsp;&nbsp;&nbsp; ` a[i] > a[i+1]` &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;`a[j-1] > a[j]`\n4. The smaller elements are at the top of the sequence, and the larger ones are at the end, ie 1,7,  then:\n    * Before Exchange   ` a[i] < a[i+1]` `a[j-1] < a[j]`\n    * After Exchange   ` a[i] > a[i+1]` `a[j-1] > a[j]`\n    * Different Part &nbsp;&nbsp;&nbsp; ` a[i] > a[i+1]` `a[j-1] > a[j]`\n5. adjacent elements， say 3 and 7， then\n    * Before Exchange   ` a[i] < a[i+1]` \n    * After Exchange   ` a[i] > a[i+1]` \n    * Different Part&nbsp;&nbsp;&nbsp; ` a[i] > a[i+1]` \n\nTherefore, by detecting the anomaly, the two elements exchanged can be found. The anomaly can be summarized as one case: ` a[k] > a[k+1]`. In the case of an exception, the kth point and k+1th point can both be the exchange position, depending on the number of occurrence of the anomaly. If it is the first time an exception occurs, it must be that the larger element is changed to the front, so k is the abnormal point. If it is the second time, it must be that the  smaller element is changed to the back, so k+1 is the abnormal point, and there is an adjacent case, that is, the exception only appears once, and can be assumed by the **The two positions of the secondary anomaly are all abnormal points, and if a second exception occurs, the smaller abnormal points are overlayed.**.\n\nThe Java code is as follows, it should be noted that\n- The value of the two nodes is directly exchanged in the code. It is also very simple to exchange two nodes.\n- `A solution using O(n) space is pretty straight forward.` this narrative should refer to `using an array with length n to store the binary tree after the traversal, and then find the location of the two exceptions.` This algorithm is easy to implement, and the solution in the constant space should be referred to use constant space except traversal. Or think so, to find the two exchanged points we  must traverse over all the nodes, so the consumption of traversing the tree is inevitable.\n\n# Complexity\n**Time complexity: ** Detecting anomalies requires traversing all nodes, so it is O(N)\n\n**Spatial complexity** See the analysis in the previous section. Strictly consider the consumption of the stack in recursion is O(logN)\n```\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    TreeNode pre, small, large;\n    public void recoverTree(TreeNode root) {\n        inTraverse(root);\n        int v1 = small.val;\n        small.val = large.val;\n        large.val = v1;\n    }\n    \n    void inTraverse(TreeNode root){\n        if(root == null)return;\n        inTraverse(root.left);\n        if(pre == null){// 第一个节点\n            pre  = root;\n        }\n        else{\n            if(root.val < pre.val){\n                if(large == null){\n                    large = pre;\n                    small = root;\n                }\n                else\n                    small = root;\n            }\n            pre = root;\n        }\n        inTraverse(root.right);\n    }\n    \n}\n```\n\n","slug":"99-Recover-Binary-Search-Tree","published":1,"updated":"2020-05-03T06:14:50.678Z","layout":"post","photos":[],"link":"","_id":"cka27ixrw000uk4r3ci3u469u","content":"<h2 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h2><p>According to the location of the two nodes being exchanged, it can be divided into five cases, assuming that the original sequence is 1，2，3，4，5，6，7，the two node locations exchanged arei, j</p>\n<ol>\n<li>The two elements of the exchange are in the middle of the sequence, without the situation on both sides, say 2,6,  then<ul>\n<li>Before Exchange   <code>a[i-1] &lt; a[i] &lt; a[i+1]</code> <code>a[j-1] &lt; a[j] &lt; a[j+1]</code></li>\n<li>After Exchange  &nbsp; <code>a[i-1] &lt; a[i] &gt; a[i+1]</code> <code>a[j-1] &gt; a[j] &lt; a[j+1]</code></li>\n<li>Different Part &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>a[i] &gt; a[i+1]</code> <code>a[j-1] &gt; a[j]</code></li>\n</ul>\n</li>\n<li>The smaller element is in the first place, the larger element is in the middle of the sequence, such as 1,5, then<ul>\n<li>Before Exchange   <code>a[i] &lt; a[i+1]</code> <code>a[j-1] &lt; a[j] &lt; a[j+1]</code></li>\n<li>After Exchange   &nbsp; <code>a[i] &gt; a[i+1]</code> <code>a[j-1] &gt; a[j] &lt; a[j+1]</code></li>\n<li>Different Part &nbsp;&nbsp;&nbsp;&nbsp; <code>a[i] &gt; a[i+1]</code> <code>a[j-1] &gt; a[j]</code></li>\n</ul>\n</li>\n<li>The smaller element is in the middle of the sequence, the larger element is at the end, such as 3, 7, then<ul>\n<li>Before Exchange   <code>a[i-1] &lt; a[i] &lt; a[i+1]</code> <code>a[j-1] &lt; a[j]</code></li>\n<li>After Exchange &nbsp;  <code>a[i-1] &lt; a[i] &gt; a[i+1]</code> <code>a[j-1] &gt; a[j]</code></li>\n<li>Different Part &nbsp;&nbsp;&nbsp;&nbsp; <code>a[i] &gt; a[i+1]</code> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<code>a[j-1] &gt; a[j]</code></li>\n</ul>\n</li>\n<li>The smaller elements are at the top of the sequence, and the larger ones are at the end, ie 1,7,  then:<ul>\n<li>Before Exchange   <code>a[i] &lt; a[i+1]</code> <code>a[j-1] &lt; a[j]</code></li>\n<li>After Exchange   <code>a[i] &gt; a[i+1]</code> <code>a[j-1] &gt; a[j]</code></li>\n<li>Different Part &nbsp;&nbsp;&nbsp; <code>a[i] &gt; a[i+1]</code> <code>a[j-1] &gt; a[j]</code></li>\n</ul>\n</li>\n<li>adjacent elements， say 3 and 7， then<ul>\n<li>Before Exchange   <code>a[i] &lt; a[i+1]</code> </li>\n<li>After Exchange   <code>a[i] &gt; a[i+1]</code> </li>\n<li>Different Part&nbsp;&nbsp;&nbsp; <code>a[i] &gt; a[i+1]</code> </li>\n</ul>\n</li>\n</ol>\n<p>Therefore, by detecting the anomaly, the two elements exchanged can be found. The anomaly can be summarized as one case: <code>a[k] &gt; a[k+1]</code>. In the case of an exception, the kth point and k+1th point can both be the exchange position, depending on the number of occurrence of the anomaly. If it is the first time an exception occurs, it must be that the larger element is changed to the front, so k is the abnormal point. If it is the second time, it must be that the  smaller element is changed to the back, so k+1 is the abnormal point, and there is an adjacent case, that is, the exception only appears once, and can be assumed by the <strong>The two positions of the secondary anomaly are all abnormal points, and if a second exception occurs, the smaller abnormal points are overlayed.</strong>.</p>\n<p>The Java code is as follows, it should be noted that</p>\n<ul>\n<li>The value of the two nodes is directly exchanged in the code. It is also very simple to exchange two nodes.</li>\n<li><code>A solution using O(n) space is pretty straight forward.</code> this narrative should refer to <code>using an array with length n to store the binary tree after the traversal, and then find the location of the two exceptions.</code> This algorithm is easy to implement, and the solution in the constant space should be referred to use constant space except traversal. Or think so, to find the two exchanged points we  must traverse over all the nodes, so the consumption of traversing the tree is inevitable.</li>\n</ul>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time complexity: </strong> Detecting anomalies requires traversing all nodes, so it is O(N)</p>\n<p><strong>Spatial complexity</strong> See the analysis in the previous section. Strictly consider the consumption of the stack in recursion is O(logN)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for a binary tree node.</span><br><span class=\"line\"> * public class TreeNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     TreeNode left;</span><br><span class=\"line\"> *     TreeNode right;</span><br><span class=\"line\"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    TreeNode pre, small, large;</span><br><span class=\"line\">    public void recoverTree(TreeNode root) &#123;</span><br><span class=\"line\">        inTraverse(root);</span><br><span class=\"line\">        int v1 = small.val;</span><br><span class=\"line\">        small.val = large.val;</span><br><span class=\"line\">        large.val = v1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    void inTraverse(TreeNode root)&#123;</span><br><span class=\"line\">        if(root == null)return;</span><br><span class=\"line\">        inTraverse(root.left);</span><br><span class=\"line\">        if(pre == null)&#123;// 第一个节点</span><br><span class=\"line\">            pre  = root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else&#123;</span><br><span class=\"line\">            if(root.val &lt; pre.val)&#123;</span><br><span class=\"line\">                if(large == null)&#123;</span><br><span class=\"line\">                    large = pre;</span><br><span class=\"line\">                    small = root;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    small = root;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            pre = root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        inTraverse(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Intuition-amp-Algorithm\"><a href=\"#Intuition-amp-Algorithm\" class=\"headerlink\" title=\"Intuition &amp; Algorithm\"></a>Intuition &amp; Algorithm</h2><p>According to the location of the two nodes being exchanged, it can be divided into five cases, assuming that the original sequence is 1，2，3，4，5，6，7，the two node locations exchanged arei, j</p>\n<ol>\n<li>The two elements of the exchange are in the middle of the sequence, without the situation on both sides, say 2,6,  then<ul>\n<li>Before Exchange   <code>a[i-1] &lt; a[i] &lt; a[i+1]</code> <code>a[j-1] &lt; a[j] &lt; a[j+1]</code></li>\n<li>After Exchange  &nbsp; <code>a[i-1] &lt; a[i] &gt; a[i+1]</code> <code>a[j-1] &gt; a[j] &lt; a[j+1]</code></li>\n<li>Different Part &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>a[i] &gt; a[i+1]</code> <code>a[j-1] &gt; a[j]</code></li>\n</ul>\n</li>\n<li>The smaller element is in the first place, the larger element is in the middle of the sequence, such as 1,5, then<ul>\n<li>Before Exchange   <code>a[i] &lt; a[i+1]</code> <code>a[j-1] &lt; a[j] &lt; a[j+1]</code></li>\n<li>After Exchange   &nbsp; <code>a[i] &gt; a[i+1]</code> <code>a[j-1] &gt; a[j] &lt; a[j+1]</code></li>\n<li>Different Part &nbsp;&nbsp;&nbsp;&nbsp; <code>a[i] &gt; a[i+1]</code> <code>a[j-1] &gt; a[j]</code></li>\n</ul>\n</li>\n<li>The smaller element is in the middle of the sequence, the larger element is at the end, such as 3, 7, then<ul>\n<li>Before Exchange   <code>a[i-1] &lt; a[i] &lt; a[i+1]</code> <code>a[j-1] &lt; a[j]</code></li>\n<li>After Exchange &nbsp;  <code>a[i-1] &lt; a[i] &gt; a[i+1]</code> <code>a[j-1] &gt; a[j]</code></li>\n<li>Different Part &nbsp;&nbsp;&nbsp;&nbsp; <code>a[i] &gt; a[i+1]</code> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<code>a[j-1] &gt; a[j]</code></li>\n</ul>\n</li>\n<li>The smaller elements are at the top of the sequence, and the larger ones are at the end, ie 1,7,  then:<ul>\n<li>Before Exchange   <code>a[i] &lt; a[i+1]</code> <code>a[j-1] &lt; a[j]</code></li>\n<li>After Exchange   <code>a[i] &gt; a[i+1]</code> <code>a[j-1] &gt; a[j]</code></li>\n<li>Different Part &nbsp;&nbsp;&nbsp; <code>a[i] &gt; a[i+1]</code> <code>a[j-1] &gt; a[j]</code></li>\n</ul>\n</li>\n<li>adjacent elements， say 3 and 7， then<ul>\n<li>Before Exchange   <code>a[i] &lt; a[i+1]</code> </li>\n<li>After Exchange   <code>a[i] &gt; a[i+1]</code> </li>\n<li>Different Part&nbsp;&nbsp;&nbsp; <code>a[i] &gt; a[i+1]</code> </li>\n</ul>\n</li>\n</ol>\n<p>Therefore, by detecting the anomaly, the two elements exchanged can be found. The anomaly can be summarized as one case: <code>a[k] &gt; a[k+1]</code>. In the case of an exception, the kth point and k+1th point can both be the exchange position, depending on the number of occurrence of the anomaly. If it is the first time an exception occurs, it must be that the larger element is changed to the front, so k is the abnormal point. If it is the second time, it must be that the  smaller element is changed to the back, so k+1 is the abnormal point, and there is an adjacent case, that is, the exception only appears once, and can be assumed by the <strong>The two positions of the secondary anomaly are all abnormal points, and if a second exception occurs, the smaller abnormal points are overlayed.</strong>.</p>\n<p>The Java code is as follows, it should be noted that</p>\n<ul>\n<li>The value of the two nodes is directly exchanged in the code. It is also very simple to exchange two nodes.</li>\n<li><code>A solution using O(n) space is pretty straight forward.</code> this narrative should refer to <code>using an array with length n to store the binary tree after the traversal, and then find the location of the two exceptions.</code> This algorithm is easy to implement, and the solution in the constant space should be referred to use constant space except traversal. Or think so, to find the two exchanged points we  must traverse over all the nodes, so the consumption of traversing the tree is inevitable.</li>\n</ul>\n<h1 id=\"Complexity\"><a href=\"#Complexity\" class=\"headerlink\" title=\"Complexity\"></a>Complexity</h1><p><strong>Time complexity: </strong> Detecting anomalies requires traversing all nodes, so it is O(N)</p>\n<p><strong>Spatial complexity</strong> See the analysis in the previous section. Strictly consider the consumption of the stack in recursion is O(logN)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for a binary tree node.</span><br><span class=\"line\"> * public class TreeNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     TreeNode left;</span><br><span class=\"line\"> *     TreeNode right;</span><br><span class=\"line\"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    TreeNode pre, small, large;</span><br><span class=\"line\">    public void recoverTree(TreeNode root) &#123;</span><br><span class=\"line\">        inTraverse(root);</span><br><span class=\"line\">        int v1 = small.val;</span><br><span class=\"line\">        small.val = large.val;</span><br><span class=\"line\">        large.val = v1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    void inTraverse(TreeNode root)&#123;</span><br><span class=\"line\">        if(root == null)return;</span><br><span class=\"line\">        inTraverse(root.left);</span><br><span class=\"line\">        if(pre == null)&#123;// 第一个节点</span><br><span class=\"line\">            pre  = root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else&#123;</span><br><span class=\"line\">            if(root.val &lt; pre.val)&#123;</span><br><span class=\"line\">                if(large == null)&#123;</span><br><span class=\"line\">                    large = pre;</span><br><span class=\"line\">                    small = root;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    small = root;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            pre = root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        inTraverse(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Https","date":"2019-08-01T05:59:39.000Z","comments":1,"_content":"# How does HTTPS provide security\nThe primitive promotion of HTTPS over http is security. Messages are transferred nakedly in http which may be utilized by an eavesdropper.\nIt's pretty natural to think that we can encrypt the plain text with a key. There are two kinds of encrytion with different\ncombinations of keys.\n- Symmetric Encryption : public key\n- Asymmetric Encryption : public key + private key\n\nIn symmetric encryption, both the server and the client use public key for encryption and decryption. The client can encrypt message with public key and then send it to the server where the encrypted message is decrypted with the same public key, and vice versa.\nThings becomes differrent in asymmetric encryption, we can not decrypt the encrypted message with public key in above cases. A private key is needed for decryption. The basic steps for data transmission are:\n1. the client encrypt message with public key\n2. encrypted message is transferred to the server\n3. the server get the raw message by decryption with private key\n\nThe public key and private key pair is one to one, for example, private key is a pair of very large prime number, and public key is their product.\n\n# Vulnerability\nWe haven't metion how does the server/client side get the public/private key yet. The private key is very easy to implement, both the server and the client can appoint the private key themselves and do not transfer it to the other one by internet while the public key has to be visible to the other one. The vulnerability happens in the procedure of public key transmission. \n\nIn the symmetric encryption algorithm, if a third party intercept your public key he can decrypt any message from client or server!\n> Imaging you're using a public wifi in market, all your infomation is exposed to the wifi owner\n\nThe problem comes from the transmission of public key. It's plain text! The asymmetric encryption can solve this problem by a private key, the third party can get the public key but he cannot decrypt the message without private key. But there is a limitation for asmmetric encryption, it's one-way transmission! Only the side with private key can read the message, and another side just have public key to encrypt message.\n> Maybe we can use two pairs of public+private key for asymmetric encryption?\n\n# TLS\nTLS(Transfer Layer Security) is the underlying implementation for HTTPS. It's kernel priciple is pretty similar the above:\n- At first, The server has a pair of public+private key (Suppose they are prime numbers and their product) and \nthe client has nothing.\n- The client sends a HTTPS request to the server, and the server gives the public key to the client.\n- The client generates a key refferd as `pre-master key` which is a private key, and then transfer it to the server after\nencrypting it with the public key. \n\n> Note that pre-master key is still a private key because we transferred the encrypted key,\nif a third party get the message he will never know the pre-master key without private key from the server side.\n\n- The server decrypt the message and get the pre-master key.\n- Now both the client and the server have pre-master key, which means we can use symmetric encryption from now on. This symmetric encryption is quite different from the above, because we use a private key (pre-master key) for encryption, it's invisible from third part.\n\nThings to note:\n1. In the above procedure, the public key is known as digital certification.(You can find it on the left side of url field of your browser.)\n2. The server-side private key is top secrete, it can never be exposed to anyone else.\n3. Actually in TLS, we encrypt pre-master key with two another random number(public key) generated by the client and the server to get the final `session key`. As you can guess from the literal, `pre-master key` is a material private key for the final `session key` and the `session key` is unique for each session because we used two random number.\n\n# Summary\nSymmetric encryption with private key is the most secure way for encryption. In order to share the private key(`pre-master key`), we use asymmetric encryption. \n\n# Gossip\nPublic key and private key certification is usually published by CA institute, they are the only one who knows your secrete private key except yourself. The bank does not believe CA institute so usually they use their own certification on their own server and let CDN prividers get public key from their private server.\n\n\n\n# Referrence\n[How does HTTPS provide security?](https://stackoverflow.com/a/3968260/4332095)\n\n[TLS](https://itimetraveler.github.io/2018/10/30/HTTPS%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AF%81%E4%B9%A6/#%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93)\n","source":"_posts/Https.md","raw":"---\ntitle: Https\ndate: 2019-08-01 13:59:39\ntags:\n- https\ncategories:\n- Computer Network\ncomments: true\n---\n# How does HTTPS provide security\nThe primitive promotion of HTTPS over http is security. Messages are transferred nakedly in http which may be utilized by an eavesdropper.\nIt's pretty natural to think that we can encrypt the plain text with a key. There are two kinds of encrytion with different\ncombinations of keys.\n- Symmetric Encryption : public key\n- Asymmetric Encryption : public key + private key\n\nIn symmetric encryption, both the server and the client use public key for encryption and decryption. The client can encrypt message with public key and then send it to the server where the encrypted message is decrypted with the same public key, and vice versa.\nThings becomes differrent in asymmetric encryption, we can not decrypt the encrypted message with public key in above cases. A private key is needed for decryption. The basic steps for data transmission are:\n1. the client encrypt message with public key\n2. encrypted message is transferred to the server\n3. the server get the raw message by decryption with private key\n\nThe public key and private key pair is one to one, for example, private key is a pair of very large prime number, and public key is their product.\n\n# Vulnerability\nWe haven't metion how does the server/client side get the public/private key yet. The private key is very easy to implement, both the server and the client can appoint the private key themselves and do not transfer it to the other one by internet while the public key has to be visible to the other one. The vulnerability happens in the procedure of public key transmission. \n\nIn the symmetric encryption algorithm, if a third party intercept your public key he can decrypt any message from client or server!\n> Imaging you're using a public wifi in market, all your infomation is exposed to the wifi owner\n\nThe problem comes from the transmission of public key. It's plain text! The asymmetric encryption can solve this problem by a private key, the third party can get the public key but he cannot decrypt the message without private key. But there is a limitation for asmmetric encryption, it's one-way transmission! Only the side with private key can read the message, and another side just have public key to encrypt message.\n> Maybe we can use two pairs of public+private key for asymmetric encryption?\n\n# TLS\nTLS(Transfer Layer Security) is the underlying implementation for HTTPS. It's kernel priciple is pretty similar the above:\n- At first, The server has a pair of public+private key (Suppose they are prime numbers and their product) and \nthe client has nothing.\n- The client sends a HTTPS request to the server, and the server gives the public key to the client.\n- The client generates a key refferd as `pre-master key` which is a private key, and then transfer it to the server after\nencrypting it with the public key. \n\n> Note that pre-master key is still a private key because we transferred the encrypted key,\nif a third party get the message he will never know the pre-master key without private key from the server side.\n\n- The server decrypt the message and get the pre-master key.\n- Now both the client and the server have pre-master key, which means we can use symmetric encryption from now on. This symmetric encryption is quite different from the above, because we use a private key (pre-master key) for encryption, it's invisible from third part.\n\nThings to note:\n1. In the above procedure, the public key is known as digital certification.(You can find it on the left side of url field of your browser.)\n2. The server-side private key is top secrete, it can never be exposed to anyone else.\n3. Actually in TLS, we encrypt pre-master key with two another random number(public key) generated by the client and the server to get the final `session key`. As you can guess from the literal, `pre-master key` is a material private key for the final `session key` and the `session key` is unique for each session because we used two random number.\n\n# Summary\nSymmetric encryption with private key is the most secure way for encryption. In order to share the private key(`pre-master key`), we use asymmetric encryption. \n\n# Gossip\nPublic key and private key certification is usually published by CA institute, they are the only one who knows your secrete private key except yourself. The bank does not believe CA institute so usually they use their own certification on their own server and let CDN prividers get public key from their private server.\n\n\n\n# Referrence\n[How does HTTPS provide security?](https://stackoverflow.com/a/3968260/4332095)\n\n[TLS](https://itimetraveler.github.io/2018/10/30/HTTPS%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AF%81%E4%B9%A6/#%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93)\n","slug":"Https","published":1,"updated":"2020-05-03T06:14:50.678Z","layout":"post","photos":[],"link":"","_id":"cka27ixrx000vk4r3qrsg6029","content":"<h1 id=\"How-does-HTTPS-provide-security\"><a href=\"#How-does-HTTPS-provide-security\" class=\"headerlink\" title=\"How does HTTPS provide security\"></a>How does HTTPS provide security</h1><p>The primitive promotion of HTTPS over http is security. Messages are transferred nakedly in http which may be utilized by an eavesdropper.<br>It’s pretty natural to think that we can encrypt the plain text with a key. There are two kinds of encrytion with different<br>combinations of keys.</p>\n<ul>\n<li>Symmetric Encryption : public key</li>\n<li>Asymmetric Encryption : public key + private key</li>\n</ul>\n<p>In symmetric encryption, both the server and the client use public key for encryption and decryption. The client can encrypt message with public key and then send it to the server where the encrypted message is decrypted with the same public key, and vice versa.<br>Things becomes differrent in asymmetric encryption, we can not decrypt the encrypted message with public key in above cases. A private key is needed for decryption. The basic steps for data transmission are:</p>\n<ol>\n<li>the client encrypt message with public key</li>\n<li>encrypted message is transferred to the server</li>\n<li>the server get the raw message by decryption with private key</li>\n</ol>\n<p>The public key and private key pair is one to one, for example, private key is a pair of very large prime number, and public key is their product.</p>\n<h1 id=\"Vulnerability\"><a href=\"#Vulnerability\" class=\"headerlink\" title=\"Vulnerability\"></a>Vulnerability</h1><p>We haven’t metion how does the server/client side get the public/private key yet. The private key is very easy to implement, both the server and the client can appoint the private key themselves and do not transfer it to the other one by internet while the public key has to be visible to the other one. The vulnerability happens in the procedure of public key transmission. </p>\n<p>In the symmetric encryption algorithm, if a third party intercept your public key he can decrypt any message from client or server!</p>\n<blockquote>\n<p>Imaging you’re using a public wifi in market, all your infomation is exposed to the wifi owner</p>\n</blockquote>\n<p>The problem comes from the transmission of public key. It’s plain text! The asymmetric encryption can solve this problem by a private key, the third party can get the public key but he cannot decrypt the message without private key. But there is a limitation for asmmetric encryption, it’s one-way transmission! Only the side with private key can read the message, and another side just have public key to encrypt message.</p>\n<blockquote>\n<p>Maybe we can use two pairs of public+private key for asymmetric encryption?</p>\n</blockquote>\n<h1 id=\"TLS\"><a href=\"#TLS\" class=\"headerlink\" title=\"TLS\"></a>TLS</h1><p>TLS(Transfer Layer Security) is the underlying implementation for HTTPS. It’s kernel priciple is pretty similar the above:</p>\n<ul>\n<li>At first, The server has a pair of public+private key (Suppose they are prime numbers and their product) and<br>the client has nothing.</li>\n<li>The client sends a HTTPS request to the server, and the server gives the public key to the client.</li>\n<li>The client generates a key refferd as <code>pre-master key</code> which is a private key, and then transfer it to the server after<br>encrypting it with the public key. </li>\n</ul>\n<blockquote>\n<p>Note that pre-master key is still a private key because we transferred the encrypted key,<br>if a third party get the message he will never know the pre-master key without private key from the server side.</p>\n</blockquote>\n<ul>\n<li>The server decrypt the message and get the pre-master key.</li>\n<li>Now both the client and the server have pre-master key, which means we can use symmetric encryption from now on. This symmetric encryption is quite different from the above, because we use a private key (pre-master key) for encryption, it’s invisible from third part.</li>\n</ul>\n<p>Things to note:</p>\n<ol>\n<li>In the above procedure, the public key is known as digital certification.(You can find it on the left side of url field of your browser.)</li>\n<li>The server-side private key is top secrete, it can never be exposed to anyone else.</li>\n<li>Actually in TLS, we encrypt pre-master key with two another random number(public key) generated by the client and the server to get the final <code>session key</code>. As you can guess from the literal, <code>pre-master key</code> is a material private key for the final <code>session key</code> and the <code>session key</code> is unique for each session because we used two random number.</li>\n</ol>\n<h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><p>Symmetric encryption with private key is the most secure way for encryption. In order to share the private key(<code>pre-master key</code>), we use asymmetric encryption. </p>\n<h1 id=\"Gossip\"><a href=\"#Gossip\" class=\"headerlink\" title=\"Gossip\"></a>Gossip</h1><p>Public key and private key certification is usually published by CA institute, they are the only one who knows your secrete private key except yourself. The bank does not believe CA institute so usually they use their own certification on their own server and let CDN prividers get public key from their private server.</p>\n<h1 id=\"Referrence\"><a href=\"#Referrence\" class=\"headerlink\" title=\"Referrence\"></a>Referrence</h1><p><a href=\"https://stackoverflow.com/a/3968260/4332095\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">How does HTTPS provide security?</a></p>\n<p><a href=\"https://itimetraveler.github.io/2018/10/30/HTTPS%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AF%81%E4%B9%A6/#%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">TLS</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"How-does-HTTPS-provide-security\"><a href=\"#How-does-HTTPS-provide-security\" class=\"headerlink\" title=\"How does HTTPS provide security\"></a>How does HTTPS provide security</h1><p>The primitive promotion of HTTPS over http is security. Messages are transferred nakedly in http which may be utilized by an eavesdropper.<br>It’s pretty natural to think that we can encrypt the plain text with a key. There are two kinds of encrytion with different<br>combinations of keys.</p>\n<ul>\n<li>Symmetric Encryption : public key</li>\n<li>Asymmetric Encryption : public key + private key</li>\n</ul>\n<p>In symmetric encryption, both the server and the client use public key for encryption and decryption. The client can encrypt message with public key and then send it to the server where the encrypted message is decrypted with the same public key, and vice versa.<br>Things becomes differrent in asymmetric encryption, we can not decrypt the encrypted message with public key in above cases. A private key is needed for decryption. The basic steps for data transmission are:</p>\n<ol>\n<li>the client encrypt message with public key</li>\n<li>encrypted message is transferred to the server</li>\n<li>the server get the raw message by decryption with private key</li>\n</ol>\n<p>The public key and private key pair is one to one, for example, private key is a pair of very large prime number, and public key is their product.</p>\n<h1 id=\"Vulnerability\"><a href=\"#Vulnerability\" class=\"headerlink\" title=\"Vulnerability\"></a>Vulnerability</h1><p>We haven’t metion how does the server/client side get the public/private key yet. The private key is very easy to implement, both the server and the client can appoint the private key themselves and do not transfer it to the other one by internet while the public key has to be visible to the other one. The vulnerability happens in the procedure of public key transmission. </p>\n<p>In the symmetric encryption algorithm, if a third party intercept your public key he can decrypt any message from client or server!</p>\n<blockquote>\n<p>Imaging you’re using a public wifi in market, all your infomation is exposed to the wifi owner</p>\n</blockquote>\n<p>The problem comes from the transmission of public key. It’s plain text! The asymmetric encryption can solve this problem by a private key, the third party can get the public key but he cannot decrypt the message without private key. But there is a limitation for asmmetric encryption, it’s one-way transmission! Only the side with private key can read the message, and another side just have public key to encrypt message.</p>\n<blockquote>\n<p>Maybe we can use two pairs of public+private key for asymmetric encryption?</p>\n</blockquote>\n<h1 id=\"TLS\"><a href=\"#TLS\" class=\"headerlink\" title=\"TLS\"></a>TLS</h1><p>TLS(Transfer Layer Security) is the underlying implementation for HTTPS. It’s kernel priciple is pretty similar the above:</p>\n<ul>\n<li>At first, The server has a pair of public+private key (Suppose they are prime numbers and their product) and<br>the client has nothing.</li>\n<li>The client sends a HTTPS request to the server, and the server gives the public key to the client.</li>\n<li>The client generates a key refferd as <code>pre-master key</code> which is a private key, and then transfer it to the server after<br>encrypting it with the public key. </li>\n</ul>\n<blockquote>\n<p>Note that pre-master key is still a private key because we transferred the encrypted key,<br>if a third party get the message he will never know the pre-master key without private key from the server side.</p>\n</blockquote>\n<ul>\n<li>The server decrypt the message and get the pre-master key.</li>\n<li>Now both the client and the server have pre-master key, which means we can use symmetric encryption from now on. This symmetric encryption is quite different from the above, because we use a private key (pre-master key) for encryption, it’s invisible from third part.</li>\n</ul>\n<p>Things to note:</p>\n<ol>\n<li>In the above procedure, the public key is known as digital certification.(You can find it on the left side of url field of your browser.)</li>\n<li>The server-side private key is top secrete, it can never be exposed to anyone else.</li>\n<li>Actually in TLS, we encrypt pre-master key with two another random number(public key) generated by the client and the server to get the final <code>session key</code>. As you can guess from the literal, <code>pre-master key</code> is a material private key for the final <code>session key</code> and the <code>session key</code> is unique for each session because we used two random number.</li>\n</ol>\n<h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><p>Symmetric encryption with private key is the most secure way for encryption. In order to share the private key(<code>pre-master key</code>), we use asymmetric encryption. </p>\n<h1 id=\"Gossip\"><a href=\"#Gossip\" class=\"headerlink\" title=\"Gossip\"></a>Gossip</h1><p>Public key and private key certification is usually published by CA institute, they are the only one who knows your secrete private key except yourself. The bank does not believe CA institute so usually they use their own certification on their own server and let CDN prividers get public key from their private server.</p>\n<h1 id=\"Referrence\"><a href=\"#Referrence\" class=\"headerlink\" title=\"Referrence\"></a>Referrence</h1><p><a href=\"https://stackoverflow.com/a/3968260/4332095\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">How does HTTPS provide security?</a></p>\n<p><a href=\"https://itimetraveler.github.io/2018/10/30/HTTPS%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AF%81%E4%B9%A6/#%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">TLS</a></p>\n"},{"title":"MySQL ACID","date":"2019-09-25T08:45:58.000Z","_content":"# MySQL ACID\n![ACID](/images/MySQL_ACID.png)\n\n> 本文所有内容仅仅是对MySQL[官方文档](https://dev.mysql.com/doc/refman/8.0/en/mysql-acid.html)稍作整理，增加一些作者自己的理解。\n\n\n随着业务数据和任务需求的增长，可靠性成了MySQL数据库的重要诉求(Redis早期仅有单句的增删改查，事务是随着业务需求变得复杂才增加的)。ACID正是实现MySQL可靠性的设计原则。\n\n下文以InnoDB存储引擎为例简述了MySQL中如何体现ACID设计原则。\n\nA(原子性), C(一致性), D(持久化)事实上都基于系统崩溃或者断电等导致数据库突然不可用的情况来考虑。I(隔离性)考虑并发情况下事务应当访问到何种数据。\n\n\n- A: atomicity \n\n    原子性，一个事务(包括单句增删改查操作)要么完成，要么失败，不存在修改一半的情况。这点通过事务的提交机制和回滚机制来保证。其中undolog起到了关键性作用，它记录了每条命令相反的命令，如果事务未提交完成遇到了失败，下次数据库重启时调用undolog回滚部分完成的事务。\n\n- C: consistency.\n\n    一致性。一致性的概念与下文中持久化关联非常紧密。官方文档中说明MySQL一致性体现在双写缓存和灾难恢复机制，而二者实际上也可以体现在持久化的原则中。持久化与一致性可以理解为因果关系，因为在机器正常运行的时候做了持久化的工作，才能在宕机之后根据持久化的文件(doublewrite buffer, redolog等)对数据库表空间(实际数据存储的地方)进行修复，以达到与宕机前数据库状态的一致性。\n\n    一致性只是一个设计原则，并不是数据库的某种机制，同样持久化也只是设计原则，而具体的机制如doublewrite buffer, redolog 被宕机这个时间点分成了两部分，宕机之前体现了持久化，宕机之后用作灾难恢复机制体现了一致性。因此也可以任务一致性和持久性并不是平行的设计原则，持久化保证了一致性。\n\n    > 实际上可以认为A,I,D三者共同保证了一致性。其中，原子性保证了数据库从一个状态转移到另一个状态，可能成功，可能失败，操作的结果与我们预期是一致的，隔离性保证了多个操作的顺序不影响数据库的最终状态，也就是无论事务操作的顺序如何，最终状态都是一致的，持久性保证了在宕机这段时间前后，数据库的状态一致。\n- I: isolation.\n\n    隔离性。四种隔离级别以及底层的InnoDB锁保证了MySQL事务之间可以做到某种级别的不干扰。\n\n- D: durability.\n\n    持久性。持久化是将内存中的MySQL页刷盘到磁盘中存储起来。\n\n    如果不做持久化处理，宕机后内存中的已经修改的MySQL页都将丢失。redolog 记录了对每个页的哪些偏移位置处做了何种修改。因此每次提交操作都写入redolog可以最大程度的保证数据的完整性，即使是没有提交的事务也可以恢复，因为redolog在每次操作的时候都会刷盘(因为redolog是连续存储的，所以刷盘影响不大)。\n    \n    如果内存中的MySQL页往磁盘中写入一半的时候宕机了，则某些页可能写入错误，而重启的时候无法发现。redolog在刷盘的时候不存在此问题，因为每条redolog只占一个WORD，可以保证传输的原子性(UPS等备用电源机制可以保证即使断电也可以保证CPU指令的原子性)。doublewrite buffer解决了页部分写入的错误，具体实现也非常简单，首先将内存中数据页写入磁盘中的double write缓存，在这第一个写过程中即使宕机也不影响原始数据库的数据，然后再将doublewritebuffer内容写入到真正的表空间，在第二个写过程中即使宕机，因为doublewrite buffer是在磁盘上的且完整的，只需要重写一遍就可以了。\n\n\n\n\n","source":"_posts/MySQL-ACID.md","raw":"---\ntitle: MySQL ACID\ndate: 2019-09-25 16:45:58\ntags:\n- MySQL\n- ACID\ncategories:\n- 中文\n- Database\n---\n# MySQL ACID\n![ACID](/images/MySQL_ACID.png)\n\n> 本文所有内容仅仅是对MySQL[官方文档](https://dev.mysql.com/doc/refman/8.0/en/mysql-acid.html)稍作整理，增加一些作者自己的理解。\n\n\n随着业务数据和任务需求的增长，可靠性成了MySQL数据库的重要诉求(Redis早期仅有单句的增删改查，事务是随着业务需求变得复杂才增加的)。ACID正是实现MySQL可靠性的设计原则。\n\n下文以InnoDB存储引擎为例简述了MySQL中如何体现ACID设计原则。\n\nA(原子性), C(一致性), D(持久化)事实上都基于系统崩溃或者断电等导致数据库突然不可用的情况来考虑。I(隔离性)考虑并发情况下事务应当访问到何种数据。\n\n\n- A: atomicity \n\n    原子性，一个事务(包括单句增删改查操作)要么完成，要么失败，不存在修改一半的情况。这点通过事务的提交机制和回滚机制来保证。其中undolog起到了关键性作用，它记录了每条命令相反的命令，如果事务未提交完成遇到了失败，下次数据库重启时调用undolog回滚部分完成的事务。\n\n- C: consistency.\n\n    一致性。一致性的概念与下文中持久化关联非常紧密。官方文档中说明MySQL一致性体现在双写缓存和灾难恢复机制，而二者实际上也可以体现在持久化的原则中。持久化与一致性可以理解为因果关系，因为在机器正常运行的时候做了持久化的工作，才能在宕机之后根据持久化的文件(doublewrite buffer, redolog等)对数据库表空间(实际数据存储的地方)进行修复，以达到与宕机前数据库状态的一致性。\n\n    一致性只是一个设计原则，并不是数据库的某种机制，同样持久化也只是设计原则，而具体的机制如doublewrite buffer, redolog 被宕机这个时间点分成了两部分，宕机之前体现了持久化，宕机之后用作灾难恢复机制体现了一致性。因此也可以任务一致性和持久性并不是平行的设计原则，持久化保证了一致性。\n\n    > 实际上可以认为A,I,D三者共同保证了一致性。其中，原子性保证了数据库从一个状态转移到另一个状态，可能成功，可能失败，操作的结果与我们预期是一致的，隔离性保证了多个操作的顺序不影响数据库的最终状态，也就是无论事务操作的顺序如何，最终状态都是一致的，持久性保证了在宕机这段时间前后，数据库的状态一致。\n- I: isolation.\n\n    隔离性。四种隔离级别以及底层的InnoDB锁保证了MySQL事务之间可以做到某种级别的不干扰。\n\n- D: durability.\n\n    持久性。持久化是将内存中的MySQL页刷盘到磁盘中存储起来。\n\n    如果不做持久化处理，宕机后内存中的已经修改的MySQL页都将丢失。redolog 记录了对每个页的哪些偏移位置处做了何种修改。因此每次提交操作都写入redolog可以最大程度的保证数据的完整性，即使是没有提交的事务也可以恢复，因为redolog在每次操作的时候都会刷盘(因为redolog是连续存储的，所以刷盘影响不大)。\n    \n    如果内存中的MySQL页往磁盘中写入一半的时候宕机了，则某些页可能写入错误，而重启的时候无法发现。redolog在刷盘的时候不存在此问题，因为每条redolog只占一个WORD，可以保证传输的原子性(UPS等备用电源机制可以保证即使断电也可以保证CPU指令的原子性)。doublewrite buffer解决了页部分写入的错误，具体实现也非常简单，首先将内存中数据页写入磁盘中的double write缓存，在这第一个写过程中即使宕机也不影响原始数据库的数据，然后再将doublewritebuffer内容写入到真正的表空间，在第二个写过程中即使宕机，因为doublewrite buffer是在磁盘上的且完整的，只需要重写一遍就可以了。\n\n\n\n\n","slug":"MySQL-ACID","published":1,"updated":"2020-05-03T06:14:50.679Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixry000wk4r3xketxwji","content":"<h1 id=\"MySQL-ACID\"><a href=\"#MySQL-ACID\" class=\"headerlink\" title=\"MySQL ACID\"></a>MySQL ACID</h1><p><img src=\"/images/MySQL_ACID.png\" alt=\"ACID\"></p>\n<blockquote>\n<p>本文所有内容仅仅是对MySQL<a href=\"https://dev.mysql.com/doc/refman/8.0/en/mysql-acid.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">官方文档</a>稍作整理，增加一些作者自己的理解。</p>\n</blockquote>\n<p>随着业务数据和任务需求的增长，可靠性成了MySQL数据库的重要诉求(Redis早期仅有单句的增删改查，事务是随着业务需求变得复杂才增加的)。ACID正是实现MySQL可靠性的设计原则。</p>\n<p>下文以InnoDB存储引擎为例简述了MySQL中如何体现ACID设计原则。</p>\n<p>A(原子性), C(一致性), D(持久化)事实上都基于系统崩溃或者断电等导致数据库突然不可用的情况来考虑。I(隔离性)考虑并发情况下事务应当访问到何种数据。</p>\n<ul>\n<li><p>A: atomicity </p>\n<p>  原子性，一个事务(包括单句增删改查操作)要么完成，要么失败，不存在修改一半的情况。这点通过事务的提交机制和回滚机制来保证。其中undolog起到了关键性作用，它记录了每条命令相反的命令，如果事务未提交完成遇到了失败，下次数据库重启时调用undolog回滚部分完成的事务。</p>\n</li>\n<li><p>C: consistency.</p>\n<p>  一致性。一致性的概念与下文中持久化关联非常紧密。官方文档中说明MySQL一致性体现在双写缓存和灾难恢复机制，而二者实际上也可以体现在持久化的原则中。持久化与一致性可以理解为因果关系，因为在机器正常运行的时候做了持久化的工作，才能在宕机之后根据持久化的文件(doublewrite buffer, redolog等)对数据库表空间(实际数据存储的地方)进行修复，以达到与宕机前数据库状态的一致性。</p>\n<p>  一致性只是一个设计原则，并不是数据库的某种机制，同样持久化也只是设计原则，而具体的机制如doublewrite buffer, redolog 被宕机这个时间点分成了两部分，宕机之前体现了持久化，宕机之后用作灾难恢复机制体现了一致性。因此也可以任务一致性和持久性并不是平行的设计原则，持久化保证了一致性。</p>\n<blockquote>\n<p>实际上可以认为A,I,D三者共同保证了一致性。其中，原子性保证了数据库从一个状态转移到另一个状态，可能成功，可能失败，操作的结果与我们预期是一致的，隔离性保证了多个操作的顺序不影响数据库的最终状态，也就是无论事务操作的顺序如何，最终状态都是一致的，持久性保证了在宕机这段时间前后，数据库的状态一致。</p>\n</blockquote>\n</li>\n<li><p>I: isolation.</p>\n<p>  隔离性。四种隔离级别以及底层的InnoDB锁保证了MySQL事务之间可以做到某种级别的不干扰。</p>\n</li>\n<li><p>D: durability.</p>\n<p>  持久性。持久化是将内存中的MySQL页刷盘到磁盘中存储起来。</p>\n<p>  如果不做持久化处理，宕机后内存中的已经修改的MySQL页都将丢失。redolog 记录了对每个页的哪些偏移位置处做了何种修改。因此每次提交操作都写入redolog可以最大程度的保证数据的完整性，即使是没有提交的事务也可以恢复，因为redolog在每次操作的时候都会刷盘(因为redolog是连续存储的，所以刷盘影响不大)。</p>\n<p>  如果内存中的MySQL页往磁盘中写入一半的时候宕机了，则某些页可能写入错误，而重启的时候无法发现。redolog在刷盘的时候不存在此问题，因为每条redolog只占一个WORD，可以保证传输的原子性(UPS等备用电源机制可以保证即使断电也可以保证CPU指令的原子性)。doublewrite buffer解决了页部分写入的错误，具体实现也非常简单，首先将内存中数据页写入磁盘中的double write缓存，在这第一个写过程中即使宕机也不影响原始数据库的数据，然后再将doublewritebuffer内容写入到真正的表空间，在第二个写过程中即使宕机，因为doublewrite buffer是在磁盘上的且完整的，只需要重写一遍就可以了。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"MySQL-ACID\"><a href=\"#MySQL-ACID\" class=\"headerlink\" title=\"MySQL ACID\"></a>MySQL ACID</h1><p><img src=\"/images/MySQL_ACID.png\" alt=\"ACID\"></p>\n<blockquote>\n<p>本文所有内容仅仅是对MySQL<a href=\"https://dev.mysql.com/doc/refman/8.0/en/mysql-acid.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">官方文档</a>稍作整理，增加一些作者自己的理解。</p>\n</blockquote>\n<p>随着业务数据和任务需求的增长，可靠性成了MySQL数据库的重要诉求(Redis早期仅有单句的增删改查，事务是随着业务需求变得复杂才增加的)。ACID正是实现MySQL可靠性的设计原则。</p>\n<p>下文以InnoDB存储引擎为例简述了MySQL中如何体现ACID设计原则。</p>\n<p>A(原子性), C(一致性), D(持久化)事实上都基于系统崩溃或者断电等导致数据库突然不可用的情况来考虑。I(隔离性)考虑并发情况下事务应当访问到何种数据。</p>\n<ul>\n<li><p>A: atomicity </p>\n<p>  原子性，一个事务(包括单句增删改查操作)要么完成，要么失败，不存在修改一半的情况。这点通过事务的提交机制和回滚机制来保证。其中undolog起到了关键性作用，它记录了每条命令相反的命令，如果事务未提交完成遇到了失败，下次数据库重启时调用undolog回滚部分完成的事务。</p>\n</li>\n<li><p>C: consistency.</p>\n<p>  一致性。一致性的概念与下文中持久化关联非常紧密。官方文档中说明MySQL一致性体现在双写缓存和灾难恢复机制，而二者实际上也可以体现在持久化的原则中。持久化与一致性可以理解为因果关系，因为在机器正常运行的时候做了持久化的工作，才能在宕机之后根据持久化的文件(doublewrite buffer, redolog等)对数据库表空间(实际数据存储的地方)进行修复，以达到与宕机前数据库状态的一致性。</p>\n<p>  一致性只是一个设计原则，并不是数据库的某种机制，同样持久化也只是设计原则，而具体的机制如doublewrite buffer, redolog 被宕机这个时间点分成了两部分，宕机之前体现了持久化，宕机之后用作灾难恢复机制体现了一致性。因此也可以任务一致性和持久性并不是平行的设计原则，持久化保证了一致性。</p>\n<blockquote>\n<p>实际上可以认为A,I,D三者共同保证了一致性。其中，原子性保证了数据库从一个状态转移到另一个状态，可能成功，可能失败，操作的结果与我们预期是一致的，隔离性保证了多个操作的顺序不影响数据库的最终状态，也就是无论事务操作的顺序如何，最终状态都是一致的，持久性保证了在宕机这段时间前后，数据库的状态一致。</p>\n</blockquote>\n</li>\n<li><p>I: isolation.</p>\n<p>  隔离性。四种隔离级别以及底层的InnoDB锁保证了MySQL事务之间可以做到某种级别的不干扰。</p>\n</li>\n<li><p>D: durability.</p>\n<p>  持久性。持久化是将内存中的MySQL页刷盘到磁盘中存储起来。</p>\n<p>  如果不做持久化处理，宕机后内存中的已经修改的MySQL页都将丢失。redolog 记录了对每个页的哪些偏移位置处做了何种修改。因此每次提交操作都写入redolog可以最大程度的保证数据的完整性，即使是没有提交的事务也可以恢复，因为redolog在每次操作的时候都会刷盘(因为redolog是连续存储的，所以刷盘影响不大)。</p>\n<p>  如果内存中的MySQL页往磁盘中写入一半的时候宕机了，则某些页可能写入错误，而重启的时候无法发现。redolog在刷盘的时候不存在此问题，因为每条redolog只占一个WORD，可以保证传输的原子性(UPS等备用电源机制可以保证即使断电也可以保证CPU指令的原子性)。doublewrite buffer解决了页部分写入的错误，具体实现也非常简单，首先将内存中数据页写入磁盘中的double write缓存，在这第一个写过程中即使宕机也不影响原始数据库的数据，然后再将doublewritebuffer内容写入到真正的表空间，在第二个写过程中即使宕机，因为doublewrite buffer是在磁盘上的且完整的，只需要重写一遍就可以了。</p>\n</li>\n</ul>\n"},{"title":"《STL 源码剖析》阅读总结 - 设计模式 适配器模式","date":"2020-05-03T12:59:48.000Z","_content":"\n## 适配器模式\n\n### 意图\n通过新增的适配器类将我们设计的类转化为客户需要的类。\n### 使用场景\n程序需要使用的类与现有的类之间不同，通过Adapter类进行二者之间的转换。具体如数据库访问时的底层核心适配器，STL只允许读的iteration\n### 实现方法\n继承或依赖（包含）\n### STL 实践\nSTL中适配器模式主要在三个地方有体现：\n- 应用于容器：如 queue和stack都是对 deque的包装，二者包含了一个deque类型的成员，二者的接口都是转而调用deque的接口。\n- 应用于迭代器：如reverse_iterator, insert_iterator, istream_iterator,ostream_iterator等，后两个类的设计比较优雅\n- 应用于函子：我认为这是适配器模式最普遍和最重要的应用了，它将一个类适配成一个函数，实现方法是通过向类中添加一个`operator()`函数，这样的类被称为函子(functor)。例如，一个可以比较两个数大小的函子：\n```\ntemplate<class T>\nclass less{\npublic:\n    bool operator() (const T & a,const  T & b)\n    {\n        return a < b; // 该操作需要类型T重载了全局操作符 <\n    }\n}\n/*\n在使用时，我们调用表达式：\nless<int>()(1,3)\n即可得到一个bool值\n*/\n```\n进一步地，我们可以利用该函子的返回值作为另一个函子的输入，从而形成链式结构：\n```\nclass not{\npublic:\n    bool operator()(bool x)\n    {\n        return !x;\n    }\n}\n/*\n可以使用以下链式结构调用:\nnot()(less<int>()(1,3))\n匿名对象的写法不直观，我们将其改写为具名对象：\nless<int> less;\nnot not;\nnot(less(1,3)); // 此时类not 和less的行为与函数一般无二，另外这两个对象还可以被当作参数传递，从而替代了函数指针的功能（在不深究二者之间效率的情况下）\n*/\n```\n\n### 思考\n1. 迭代器模式是程序库设计者为兼容不同版本的库（如java1.1 Enumeration 和java 1.2 Iteration）或者同一功能的不同的增强实现(如C# SqlConnection和MySqlConnection)而提出的解决方案，如无必要不要使用该模式。\n2. functor的实现是否是其他语言如Java，C#中函数作为参数传递的方法？\n3. 函数对象的实现依赖于C++可以实现重载运算符`()`\n","source":"_posts/《STL-源码剖析》阅读总结-设计模式-适配器模式.md","raw":"---\ntitle: 《STL 源码剖析》阅读总结 - 设计模式 适配器模式\ndate: 2020-05-03 20:59:48\ntags:\n---\n\n## 适配器模式\n\n### 意图\n通过新增的适配器类将我们设计的类转化为客户需要的类。\n### 使用场景\n程序需要使用的类与现有的类之间不同，通过Adapter类进行二者之间的转换。具体如数据库访问时的底层核心适配器，STL只允许读的iteration\n### 实现方法\n继承或依赖（包含）\n### STL 实践\nSTL中适配器模式主要在三个地方有体现：\n- 应用于容器：如 queue和stack都是对 deque的包装，二者包含了一个deque类型的成员，二者的接口都是转而调用deque的接口。\n- 应用于迭代器：如reverse_iterator, insert_iterator, istream_iterator,ostream_iterator等，后两个类的设计比较优雅\n- 应用于函子：我认为这是适配器模式最普遍和最重要的应用了，它将一个类适配成一个函数，实现方法是通过向类中添加一个`operator()`函数，这样的类被称为函子(functor)。例如，一个可以比较两个数大小的函子：\n```\ntemplate<class T>\nclass less{\npublic:\n    bool operator() (const T & a,const  T & b)\n    {\n        return a < b; // 该操作需要类型T重载了全局操作符 <\n    }\n}\n/*\n在使用时，我们调用表达式：\nless<int>()(1,3)\n即可得到一个bool值\n*/\n```\n进一步地，我们可以利用该函子的返回值作为另一个函子的输入，从而形成链式结构：\n```\nclass not{\npublic:\n    bool operator()(bool x)\n    {\n        return !x;\n    }\n}\n/*\n可以使用以下链式结构调用:\nnot()(less<int>()(1,3))\n匿名对象的写法不直观，我们将其改写为具名对象：\nless<int> less;\nnot not;\nnot(less(1,3)); // 此时类not 和less的行为与函数一般无二，另外这两个对象还可以被当作参数传递，从而替代了函数指针的功能（在不深究二者之间效率的情况下）\n*/\n```\n\n### 思考\n1. 迭代器模式是程序库设计者为兼容不同版本的库（如java1.1 Enumeration 和java 1.2 Iteration）或者同一功能的不同的增强实现(如C# SqlConnection和MySqlConnection)而提出的解决方案，如无必要不要使用该模式。\n2. functor的实现是否是其他语言如Java，C#中函数作为参数传递的方法？\n3. 函数对象的实现依赖于C++可以实现重载运算符`()`\n","slug":"《STL-源码剖析》阅读总结-设计模式-适配器模式","published":1,"updated":"2020-05-08T13:53:26.136Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixrz000xk4r3m40kjv8x","content":"<h2 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h2><h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>通过新增的适配器类将我们设计的类转化为客户需要的类。</p>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>程序需要使用的类与现有的类之间不同，通过Adapter类进行二者之间的转换。具体如数据库访问时的底层核心适配器，STL只允许读的iteration</p>\n<h3 id=\"实现方法\"><a href=\"#实现方法\" class=\"headerlink\" title=\"实现方法\"></a>实现方法</h3><p>继承或依赖（包含）</p>\n<h3 id=\"STL-实践\"><a href=\"#STL-实践\" class=\"headerlink\" title=\"STL 实践\"></a>STL 实践</h3><p>STL中适配器模式主要在三个地方有体现：</p>\n<ul>\n<li>应用于容器：如 queue和stack都是对 deque的包装，二者包含了一个deque类型的成员，二者的接口都是转而调用deque的接口。</li>\n<li>应用于迭代器：如reverse_iterator, insert_iterator, istream_iterator,ostream_iterator等，后两个类的设计比较优雅</li>\n<li>应用于函子：我认为这是适配器模式最普遍和最重要的应用了，它将一个类适配成一个函数，实现方法是通过向类中添加一个<code>operator()</code>函数，这样的类被称为函子(functor)。例如，一个可以比较两个数大小的函子：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">class less&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool operator() (const T &amp; a,const  T &amp; b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return a &lt; b; // 该操作需要类型T重载了全局操作符 &lt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*</span><br><span class=\"line\">在使用时，我们调用表达式：</span><br><span class=\"line\">less&lt;int&gt;()(1,3)</span><br><span class=\"line\">即可得到一个bool值</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>进一步地，我们可以利用该函子的返回值作为另一个函子的输入，从而形成链式结构：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class not&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool operator()(bool x)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return !x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*</span><br><span class=\"line\">可以使用以下链式结构调用:</span><br><span class=\"line\">not()(less&lt;int&gt;()(1,3))</span><br><span class=\"line\">匿名对象的写法不直观，我们将其改写为具名对象：</span><br><span class=\"line\">less&lt;int&gt; less;</span><br><span class=\"line\">not not;</span><br><span class=\"line\">not(less(1,3)); // 此时类not 和less的行为与函数一般无二，另外这两个对象还可以被当作参数传递，从而替代了函数指针的功能（在不深究二者之间效率的情况下）</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h3><ol>\n<li>迭代器模式是程序库设计者为兼容不同版本的库（如java1.1 Enumeration 和java 1.2 Iteration）或者同一功能的不同的增强实现(如C# SqlConnection和MySqlConnection)而提出的解决方案，如无必要不要使用该模式。</li>\n<li>functor的实现是否是其他语言如Java，C#中函数作为参数传递的方法？</li>\n<li>函数对象的实现依赖于C++可以实现重载运算符<code>()</code></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h2><h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>通过新增的适配器类将我们设计的类转化为客户需要的类。</p>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>程序需要使用的类与现有的类之间不同，通过Adapter类进行二者之间的转换。具体如数据库访问时的底层核心适配器，STL只允许读的iteration</p>\n<h3 id=\"实现方法\"><a href=\"#实现方法\" class=\"headerlink\" title=\"实现方法\"></a>实现方法</h3><p>继承或依赖（包含）</p>\n<h3 id=\"STL-实践\"><a href=\"#STL-实践\" class=\"headerlink\" title=\"STL 实践\"></a>STL 实践</h3><p>STL中适配器模式主要在三个地方有体现：</p>\n<ul>\n<li>应用于容器：如 queue和stack都是对 deque的包装，二者包含了一个deque类型的成员，二者的接口都是转而调用deque的接口。</li>\n<li>应用于迭代器：如reverse_iterator, insert_iterator, istream_iterator,ostream_iterator等，后两个类的设计比较优雅</li>\n<li>应用于函子：我认为这是适配器模式最普遍和最重要的应用了，它将一个类适配成一个函数，实现方法是通过向类中添加一个<code>operator()</code>函数，这样的类被称为函子(functor)。例如，一个可以比较两个数大小的函子：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">class less&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool operator() (const T &amp; a,const  T &amp; b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return a &lt; b; // 该操作需要类型T重载了全局操作符 &lt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*</span><br><span class=\"line\">在使用时，我们调用表达式：</span><br><span class=\"line\">less&lt;int&gt;()(1,3)</span><br><span class=\"line\">即可得到一个bool值</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>进一步地，我们可以利用该函子的返回值作为另一个函子的输入，从而形成链式结构：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class not&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool operator()(bool x)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return !x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*</span><br><span class=\"line\">可以使用以下链式结构调用:</span><br><span class=\"line\">not()(less&lt;int&gt;()(1,3))</span><br><span class=\"line\">匿名对象的写法不直观，我们将其改写为具名对象：</span><br><span class=\"line\">less&lt;int&gt; less;</span><br><span class=\"line\">not not;</span><br><span class=\"line\">not(less(1,3)); // 此时类not 和less的行为与函数一般无二，另外这两个对象还可以被当作参数传递，从而替代了函数指针的功能（在不深究二者之间效率的情况下）</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h3><ol>\n<li>迭代器模式是程序库设计者为兼容不同版本的库（如java1.1 Enumeration 和java 1.2 Iteration）或者同一功能的不同的增强实现(如C# SqlConnection和MySqlConnection)而提出的解决方案，如无必要不要使用该模式。</li>\n<li>functor的实现是否是其他语言如Java，C#中函数作为参数传递的方法？</li>\n<li>函数对象的实现依赖于C++可以实现重载运算符<code>()</code></li>\n</ol>\n"},{"title":"《More Effective C++》阅读总结 - 缓式评估，超急评估(M17, M18)","date":"2020-05-11T06:27:57.000Z","_content":"### 缓式评估\n缓式评估(Lasy Evaluation)是指对用户虽然提出了某个运算需求，但是暂时用不到运算的结果，我们将此运算延缓到用户需要使用运算结果时。考虑以下代码：\n```\ntemplate<class T>\nclass Matrix{\npublic:\n    Matrix<T> operator + (const Matrix<T>& a, const Matrix<T>& b)\n    {\n        ...  \\\\(1)\n    }\n    ...\n}\n```\n在代码块(1)中，我们可能会直接满足用户提出的加法计算需求，计算矩阵a和b对应位置元素之和，构成新的矩阵。事实上根据经验用户很可能不会需要用到新的矩阵的每一个元素，因此之前的计算存在冗余。例如用户可能这样使用Matrix库：\n```\nMatrix<int> a(1000,1000)，b(1000,1000), c(1000,1000);\n... \\\\给a,b赋值\nc = a + b;   \\\\ (1)\ncout << c[1]; \\\\ (2)\n```\n在这种情况下，虽然用户提出了加法计算需求，即代码行(1),但是用户后续只需要计算结果的第一行即可，其他999*1000个元素的运算都是不必要的。\n\n当然用户也有可能用到计算结果的全部部分：\n```\nMatrix<int> a(1000,1000)，b(1000,1000), c(1000,1000);\n... \\\\给a,b赋值\nc = a + b;   \\\\ (1)\ncout << c; \\\\ (2)\n```\n以上案例表明了这样一个问题：用户提出的运算并不一定需要我们给出完整的结果。因此我们可以将运算延迟到需要的时候再进行，在用户提出运算需求时只是记录下来。矩阵的加法可以这样设计：\n```\ntemplate<class T>\nclass Matrix{\nprivate:\n    // (1)\n    enum Operation{\n        NONE=0,PLUS=1,MINUS,MULTIPLY,DIVIDE\n    }\n    // (2)\n    Operation op;\n    Matrix<T>* m1, *m2;\npublic:\n    Matrix<T> operator + (const Matrix<T>& a, const Matrix<T>& b)\n    {\n        // (3)\n        op = PLUS;\n        m1 = &a;\n        m2 = &b;\n        return *this;\n    }\n    ...\n}\n```\n我们通过增加一个枚举成员记录运算，并用两个指针成员记录运算成员,从而延迟了加法运算。在`[]`操作符的重载函数中，我们将进行具体的加法运算。\n\n### 超急评估\n超急评估(over-eager Evaluation)是指对用户虽然**没有**提出某个运算需求，但是我们估计将来很可能需要此运算，我们将此运算提前到用户需要使用运算结果时。仍然考虑矩阵类的设计，在科学计算中，我们有很大可能需要计算矩阵的范式，矩阵各元素之和，最值等。我们可以在调用这些统计函数时计算，也可以在对矩阵中元素赋值或者修改值的时候统计。后一种方法被称为超急评估。实现方法是使用缓存存储统计结果，如:\n```\ntemplate<class T>\nclass Matrix{\nprivate:\n    T max, min, L1;\npublic:\n    T min()\n    {\n        return min;\n    }\n    ...\n}\n```\n在函数调用时我们只返回了缓存结果，实际的计算在构造函数，赋值操作的函数中。\n\n超急评估将运算提前均摊到了类成员的修改函数中，总的效率并没有提升，但是用户的感受是：(1)虽然数据量很大，但是统计运算仍然非常快，没有随数据规模而增长 (2) 对类成员的修改没有明显变慢。由此可见，我们通过将运算均摊到了平时的每一次操作提升了用户体验。\n\n超急评估还有两个著名的应用：\n- 磁盘控制器从磁盘中读取数据是读取整个sectors，尽管可能只需要其中的少量数据。这是因为有名的 locality of reference现象，即如果某处的数据被需要，通常其邻近的数据稍后也会被需要，因此我们通过提前读取一整块数据减少了寻址时间。\n- STL中vector扩容直接扩展到原来大小的2倍，尽管我们不需要这么多空间。\n\n### 小结\n- 除了缓式评估(Lasy Evaluation)和超急评估(over-eager Evaluation)外还有即时评估(eager Evaluation)，它是指在用户提出计算需求时立刻完成，例如实现Matrix的`min()`函数时遍历所有元素找出最小值，这是我们最常用的方法。缓式评估牺牲了空间作为运算记录，缓式评估可能会得到了效率上的提升；超急评估牺牲了空间作为运算结果的缓存，超急评估提升了用户体验。这两种方法实现都比通常的即时评估复杂，究竟使用哪种方法取决于**用户的关注点**。\n- 虽然缓释评估在计算机科学中应用十分普遍，遗憾的是在日常生活中拖延几乎没有任何好处，工作量不会平白无故地消失，相反积压的工作可能会影响心情┭┮﹏┭┮. 日常生活中我们处理工作的最优解可能是分级处理机制吧，高优先级的超急评估，低优先级的懒式评估。\n\n\n","source":"_posts/《More-Effective-C-》阅读总结-缓式评估，超急评估.md","raw":"---\ntitle: 《More Effective C++》阅读总结 - 缓式评估，超急评估(M17, M18)\ndate: 2020-05-11 14:27:57\ntags:\n- STL\n- C++\ncategories:\n- C++\n---\n### 缓式评估\n缓式评估(Lasy Evaluation)是指对用户虽然提出了某个运算需求，但是暂时用不到运算的结果，我们将此运算延缓到用户需要使用运算结果时。考虑以下代码：\n```\ntemplate<class T>\nclass Matrix{\npublic:\n    Matrix<T> operator + (const Matrix<T>& a, const Matrix<T>& b)\n    {\n        ...  \\\\(1)\n    }\n    ...\n}\n```\n在代码块(1)中，我们可能会直接满足用户提出的加法计算需求，计算矩阵a和b对应位置元素之和，构成新的矩阵。事实上根据经验用户很可能不会需要用到新的矩阵的每一个元素，因此之前的计算存在冗余。例如用户可能这样使用Matrix库：\n```\nMatrix<int> a(1000,1000)，b(1000,1000), c(1000,1000);\n... \\\\给a,b赋值\nc = a + b;   \\\\ (1)\ncout << c[1]; \\\\ (2)\n```\n在这种情况下，虽然用户提出了加法计算需求，即代码行(1),但是用户后续只需要计算结果的第一行即可，其他999*1000个元素的运算都是不必要的。\n\n当然用户也有可能用到计算结果的全部部分：\n```\nMatrix<int> a(1000,1000)，b(1000,1000), c(1000,1000);\n... \\\\给a,b赋值\nc = a + b;   \\\\ (1)\ncout << c; \\\\ (2)\n```\n以上案例表明了这样一个问题：用户提出的运算并不一定需要我们给出完整的结果。因此我们可以将运算延迟到需要的时候再进行，在用户提出运算需求时只是记录下来。矩阵的加法可以这样设计：\n```\ntemplate<class T>\nclass Matrix{\nprivate:\n    // (1)\n    enum Operation{\n        NONE=0,PLUS=1,MINUS,MULTIPLY,DIVIDE\n    }\n    // (2)\n    Operation op;\n    Matrix<T>* m1, *m2;\npublic:\n    Matrix<T> operator + (const Matrix<T>& a, const Matrix<T>& b)\n    {\n        // (3)\n        op = PLUS;\n        m1 = &a;\n        m2 = &b;\n        return *this;\n    }\n    ...\n}\n```\n我们通过增加一个枚举成员记录运算，并用两个指针成员记录运算成员,从而延迟了加法运算。在`[]`操作符的重载函数中，我们将进行具体的加法运算。\n\n### 超急评估\n超急评估(over-eager Evaluation)是指对用户虽然**没有**提出某个运算需求，但是我们估计将来很可能需要此运算，我们将此运算提前到用户需要使用运算结果时。仍然考虑矩阵类的设计，在科学计算中，我们有很大可能需要计算矩阵的范式，矩阵各元素之和，最值等。我们可以在调用这些统计函数时计算，也可以在对矩阵中元素赋值或者修改值的时候统计。后一种方法被称为超急评估。实现方法是使用缓存存储统计结果，如:\n```\ntemplate<class T>\nclass Matrix{\nprivate:\n    T max, min, L1;\npublic:\n    T min()\n    {\n        return min;\n    }\n    ...\n}\n```\n在函数调用时我们只返回了缓存结果，实际的计算在构造函数，赋值操作的函数中。\n\n超急评估将运算提前均摊到了类成员的修改函数中，总的效率并没有提升，但是用户的感受是：(1)虽然数据量很大，但是统计运算仍然非常快，没有随数据规模而增长 (2) 对类成员的修改没有明显变慢。由此可见，我们通过将运算均摊到了平时的每一次操作提升了用户体验。\n\n超急评估还有两个著名的应用：\n- 磁盘控制器从磁盘中读取数据是读取整个sectors，尽管可能只需要其中的少量数据。这是因为有名的 locality of reference现象，即如果某处的数据被需要，通常其邻近的数据稍后也会被需要，因此我们通过提前读取一整块数据减少了寻址时间。\n- STL中vector扩容直接扩展到原来大小的2倍，尽管我们不需要这么多空间。\n\n### 小结\n- 除了缓式评估(Lasy Evaluation)和超急评估(over-eager Evaluation)外还有即时评估(eager Evaluation)，它是指在用户提出计算需求时立刻完成，例如实现Matrix的`min()`函数时遍历所有元素找出最小值，这是我们最常用的方法。缓式评估牺牲了空间作为运算记录，缓式评估可能会得到了效率上的提升；超急评估牺牲了空间作为运算结果的缓存，超急评估提升了用户体验。这两种方法实现都比通常的即时评估复杂，究竟使用哪种方法取决于**用户的关注点**。\n- 虽然缓释评估在计算机科学中应用十分普遍，遗憾的是在日常生活中拖延几乎没有任何好处，工作量不会平白无故地消失，相反积压的工作可能会影响心情┭┮﹏┭┮. 日常生活中我们处理工作的最优解可能是分级处理机制吧，高优先级的超急评估，低优先级的懒式评估。\n\n\n","slug":"《More-Effective-C-》阅读总结-缓式评估，超急评估","published":1,"updated":"2020-05-11T07:59:03.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixs1000yk4r3j8gd9qcr","content":"<h3 id=\"缓式评估\"><a href=\"#缓式评估\" class=\"headerlink\" title=\"缓式评估\"></a>缓式评估</h3><p>缓式评估(Lasy Evaluation)是指对用户虽然提出了某个运算需求，但是暂时用不到运算的结果，我们将此运算延缓到用户需要使用运算结果时。考虑以下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">class Matrix&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Matrix&lt;T&gt; operator + (const Matrix&lt;T&gt;&amp; a, const Matrix&lt;T&gt;&amp; b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ...  \\\\(1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在代码块(1)中，我们可能会直接满足用户提出的加法计算需求，计算矩阵a和b对应位置元素之和，构成新的矩阵。事实上根据经验用户很可能不会需要用到新的矩阵的每一个元素，因此之前的计算存在冗余。例如用户可能这样使用Matrix库：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Matrix&lt;int&gt; a(1000,1000)，b(1000,1000), c(1000,1000);</span><br><span class=\"line\">... \\\\给a,b赋值</span><br><span class=\"line\">c = a + b;   \\\\ (1)</span><br><span class=\"line\">cout &lt;&lt; c[1]; \\\\ (2)</span><br></pre></td></tr></table></figure></p>\n<p>在这种情况下，虽然用户提出了加法计算需求，即代码行(1),但是用户后续只需要计算结果的第一行即可，其他999*1000个元素的运算都是不必要的。</p>\n<p>当然用户也有可能用到计算结果的全部部分：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Matrix&lt;int&gt; a(1000,1000)，b(1000,1000), c(1000,1000);</span><br><span class=\"line\">... \\\\给a,b赋值</span><br><span class=\"line\">c = a + b;   \\\\ (1)</span><br><span class=\"line\">cout &lt;&lt; c; \\\\ (2)</span><br></pre></td></tr></table></figure></p>\n<p>以上案例表明了这样一个问题：用户提出的运算并不一定需要我们给出完整的结果。因此我们可以将运算延迟到需要的时候再进行，在用户提出运算需求时只是记录下来。矩阵的加法可以这样设计：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">class Matrix&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    // (1)</span><br><span class=\"line\">    enum Operation&#123;</span><br><span class=\"line\">        NONE=0,PLUS=1,MINUS,MULTIPLY,DIVIDE</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // (2)</span><br><span class=\"line\">    Operation op;</span><br><span class=\"line\">    Matrix&lt;T&gt;* m1, *m2;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Matrix&lt;T&gt; operator + (const Matrix&lt;T&gt;&amp; a, const Matrix&lt;T&gt;&amp; b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // (3)</span><br><span class=\"line\">        op = PLUS;</span><br><span class=\"line\">        m1 = &amp;a;</span><br><span class=\"line\">        m2 = &amp;b;</span><br><span class=\"line\">        return *this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们通过增加一个枚举成员记录运算，并用两个指针成员记录运算成员,从而延迟了加法运算。在<code>[]</code>操作符的重载函数中，我们将进行具体的加法运算。</p>\n<h3 id=\"超急评估\"><a href=\"#超急评估\" class=\"headerlink\" title=\"超急评估\"></a>超急评估</h3><p>超急评估(over-eager Evaluation)是指对用户虽然<strong>没有</strong>提出某个运算需求，但是我们估计将来很可能需要此运算，我们将此运算提前到用户需要使用运算结果时。仍然考虑矩阵类的设计，在科学计算中，我们有很大可能需要计算矩阵的范式，矩阵各元素之和，最值等。我们可以在调用这些统计函数时计算，也可以在对矩阵中元素赋值或者修改值的时候统计。后一种方法被称为超急评估。实现方法是使用缓存存储统计结果，如:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">class Matrix&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    T max, min, L1;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    T min()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return min;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在函数调用时我们只返回了缓存结果，实际的计算在构造函数，赋值操作的函数中。</p>\n<p>超急评估将运算提前均摊到了类成员的修改函数中，总的效率并没有提升，但是用户的感受是：(1)虽然数据量很大，但是统计运算仍然非常快，没有随数据规模而增长 (2) 对类成员的修改没有明显变慢。由此可见，我们通过将运算均摊到了平时的每一次操作提升了用户体验。</p>\n<p>超急评估还有两个著名的应用：</p>\n<ul>\n<li>磁盘控制器从磁盘中读取数据是读取整个sectors，尽管可能只需要其中的少量数据。这是因为有名的 locality of reference现象，即如果某处的数据被需要，通常其邻近的数据稍后也会被需要，因此我们通过提前读取一整块数据减少了寻址时间。</li>\n<li>STL中vector扩容直接扩展到原来大小的2倍，尽管我们不需要这么多空间。</li>\n</ul>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>除了缓式评估(Lasy Evaluation)和超急评估(over-eager Evaluation)外还有即时评估(eager Evaluation)，它是指在用户提出计算需求时立刻完成，例如实现Matrix的<code>min()</code>函数时遍历所有元素找出最小值，这是我们最常用的方法。缓式评估牺牲了空间作为运算记录，缓式评估可能会得到了效率上的提升；超急评估牺牲了空间作为运算结果的缓存，超急评估提升了用户体验。这两种方法实现都比通常的即时评估复杂，究竟使用哪种方法取决于<strong>用户的关注点</strong>。</li>\n<li>虽然缓释评估在计算机科学中应用十分普遍，遗憾的是在日常生活中拖延几乎没有任何好处，工作量不会平白无故地消失，相反积压的工作可能会影响心情┭┮﹏┭┮. 日常生活中我们处理工作的最优解可能是分级处理机制吧，高优先级的超急评估，低优先级的懒式评估。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"缓式评估\"><a href=\"#缓式评估\" class=\"headerlink\" title=\"缓式评估\"></a>缓式评估</h3><p>缓式评估(Lasy Evaluation)是指对用户虽然提出了某个运算需求，但是暂时用不到运算的结果，我们将此运算延缓到用户需要使用运算结果时。考虑以下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">class Matrix&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Matrix&lt;T&gt; operator + (const Matrix&lt;T&gt;&amp; a, const Matrix&lt;T&gt;&amp; b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ...  \\\\(1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在代码块(1)中，我们可能会直接满足用户提出的加法计算需求，计算矩阵a和b对应位置元素之和，构成新的矩阵。事实上根据经验用户很可能不会需要用到新的矩阵的每一个元素，因此之前的计算存在冗余。例如用户可能这样使用Matrix库：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Matrix&lt;int&gt; a(1000,1000)，b(1000,1000), c(1000,1000);</span><br><span class=\"line\">... \\\\给a,b赋值</span><br><span class=\"line\">c = a + b;   \\\\ (1)</span><br><span class=\"line\">cout &lt;&lt; c[1]; \\\\ (2)</span><br></pre></td></tr></table></figure></p>\n<p>在这种情况下，虽然用户提出了加法计算需求，即代码行(1),但是用户后续只需要计算结果的第一行即可，其他999*1000个元素的运算都是不必要的。</p>\n<p>当然用户也有可能用到计算结果的全部部分：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Matrix&lt;int&gt; a(1000,1000)，b(1000,1000), c(1000,1000);</span><br><span class=\"line\">... \\\\给a,b赋值</span><br><span class=\"line\">c = a + b;   \\\\ (1)</span><br><span class=\"line\">cout &lt;&lt; c; \\\\ (2)</span><br></pre></td></tr></table></figure></p>\n<p>以上案例表明了这样一个问题：用户提出的运算并不一定需要我们给出完整的结果。因此我们可以将运算延迟到需要的时候再进行，在用户提出运算需求时只是记录下来。矩阵的加法可以这样设计：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">class Matrix&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    // (1)</span><br><span class=\"line\">    enum Operation&#123;</span><br><span class=\"line\">        NONE=0,PLUS=1,MINUS,MULTIPLY,DIVIDE</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // (2)</span><br><span class=\"line\">    Operation op;</span><br><span class=\"line\">    Matrix&lt;T&gt;* m1, *m2;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Matrix&lt;T&gt; operator + (const Matrix&lt;T&gt;&amp; a, const Matrix&lt;T&gt;&amp; b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // (3)</span><br><span class=\"line\">        op = PLUS;</span><br><span class=\"line\">        m1 = &amp;a;</span><br><span class=\"line\">        m2 = &amp;b;</span><br><span class=\"line\">        return *this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们通过增加一个枚举成员记录运算，并用两个指针成员记录运算成员,从而延迟了加法运算。在<code>[]</code>操作符的重载函数中，我们将进行具体的加法运算。</p>\n<h3 id=\"超急评估\"><a href=\"#超急评估\" class=\"headerlink\" title=\"超急评估\"></a>超急评估</h3><p>超急评估(over-eager Evaluation)是指对用户虽然<strong>没有</strong>提出某个运算需求，但是我们估计将来很可能需要此运算，我们将此运算提前到用户需要使用运算结果时。仍然考虑矩阵类的设计，在科学计算中，我们有很大可能需要计算矩阵的范式，矩阵各元素之和，最值等。我们可以在调用这些统计函数时计算，也可以在对矩阵中元素赋值或者修改值的时候统计。后一种方法被称为超急评估。实现方法是使用缓存存储统计结果，如:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">class Matrix&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    T max, min, L1;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    T min()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return min;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在函数调用时我们只返回了缓存结果，实际的计算在构造函数，赋值操作的函数中。</p>\n<p>超急评估将运算提前均摊到了类成员的修改函数中，总的效率并没有提升，但是用户的感受是：(1)虽然数据量很大，但是统计运算仍然非常快，没有随数据规模而增长 (2) 对类成员的修改没有明显变慢。由此可见，我们通过将运算均摊到了平时的每一次操作提升了用户体验。</p>\n<p>超急评估还有两个著名的应用：</p>\n<ul>\n<li>磁盘控制器从磁盘中读取数据是读取整个sectors，尽管可能只需要其中的少量数据。这是因为有名的 locality of reference现象，即如果某处的数据被需要，通常其邻近的数据稍后也会被需要，因此我们通过提前读取一整块数据减少了寻址时间。</li>\n<li>STL中vector扩容直接扩展到原来大小的2倍，尽管我们不需要这么多空间。</li>\n</ul>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>除了缓式评估(Lasy Evaluation)和超急评估(over-eager Evaluation)外还有即时评估(eager Evaluation)，它是指在用户提出计算需求时立刻完成，例如实现Matrix的<code>min()</code>函数时遍历所有元素找出最小值，这是我们最常用的方法。缓式评估牺牲了空间作为运算记录，缓式评估可能会得到了效率上的提升；超急评估牺牲了空间作为运算结果的缓存，超急评估提升了用户体验。这两种方法实现都比通常的即时评估复杂，究竟使用哪种方法取决于<strong>用户的关注点</strong>。</li>\n<li>虽然缓释评估在计算机科学中应用十分普遍，遗憾的是在日常生活中拖延几乎没有任何好处，工作量不会平白无故地消失，相反积压的工作可能会影响心情┭┮﹏┭┮. 日常生活中我们处理工作的最优解可能是分级处理机制吧，高优先级的超急评估，低优先级的懒式评估。</li>\n</ul>\n"},{"title":"《STL 源码剖析》阅读总结 - 设计模式","date":"2020-05-03T06:31:15.000Z","_content":"## 简述\n\n\n关于什么是设计模式及其优缺点的讨论可以在知乎的一些问题上找到：[问题1](https://www.zhihu.com/question/23757237)，[问题2](https://zhuanlan.zhihu.com/p/19835717)。\n\n我的理解是，每一个设计模式都是在程序设计过程中遇到的一些问题的解决方案，这些解决方案在实践中被证明在提升开发效率，代码重用性，可读性等方面都具有一定优势。因此我们理解了每一种设计模式解决的问题后，在编码的过程中遵循设计模式一方面可以帮助我们理清逻辑漏洞，另一方面客观上也提升了代码的质量。[runoob.com](https://www.runoob.com/design-pattern/design-pattern-intro.html)上对于设计模式的使用场景的阐述也比较客观。\n\n本文总结了侯捷《STL源码剖析》一书中提及的STL库中涉及的设计模式。以下引用源码来自[libc++ 10.0.0](https://libcxx.llvm.org/)\n\n## 迭代器模式\n\n### 意图\n\n无需暴露容器内部细节即可访问元素内部元素，因此针对多种容器的同一种操作可以借由迭代器进行泛化，减少了代码量，有利于代码的维护和理解。\n\n例如，下面`includes`函数判断容器中是否包含某个子序列，这个容器可以是`vector`,`list`,`deque`等，对于不同的容器，我们只需要维护下面一份代码就可以了。\n```\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 bool\n__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n           _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1)\n    {\n        if (__first1 == __last1 || __comp(*__first2, *__first1))\n            return false;\n        if (!__comp(*__first1, *__first2))\n            ++__first2;\n    }\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\n_LIBCPP_NODISCARD_EXT inline\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n         _Compare __comp)\n{\n    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n}\n```\n\n### 优点\n\n1. 增加新的容器时不需要修改算法代码\n\n### 缺点\n\n1. 增加新的容器需要添加相应的迭代类，事实上，迭代器设计模式将维护工作从容器的使用者转移到了容器的编写者，相应地减少了使用者犯错的可能。\n\n### STL 实践\n\n首先，迭代器应该是指向容器内部元素指针的包装，我们可以通过该迭代器取出指向位置的值，也可以对迭代器进行算术运算，从而使其指向容器中的上一个元素或者下一个元素。其次，不同容器的迭代器行为是有差异的，例如数组`array`或者`vector`是一块连续内存，因此我们可以让迭代器前进或者后退任意步，操作都是常数时间复杂度；而非连续的容器如双向链表`list`不能在常数时间内跳跃任意步，每次只能前进或者后退一步；单向链表`slist`则只能前进，无法后退。因此，我们应该对每种容器设计相应的迭代器类，而不能只设计一个泛化的迭代器。其三，针对不同类型的迭代器，有时候我们可以利用模板偏特化重载算法。\n\n基于以上几点，STL规定在设计容器的`iterator`类时必须包含指向容器中元素的指针，并且定义相应的前进后退算法,例如双向链表`list`的迭代器设计为：\n```\ntemplate <class _Tp, class _VoidPtr>\nclass _LIBCPP_TEMPLATE_VIS __list_iterator\n{\n    ...\n    typedef __list_node_pointer_traits<_Tp, _VoidPtr> _NodeTraits;\n    typedef typename _NodeTraits::__link_pointer __link_pointer;\n\n    __link_pointer __ptr_;\n\npublic:\n    typedef bidirectional_iterator_tag       iterator_category;\n    \n\n    __list_iterator& operator++()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable list::iterator\");\n#endif\n        __ptr_ = __ptr_->__next_;\n        return *this;\n    }\n\n    __list_iterator& operator--()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable list::iterator\");\n#endif\n        __ptr_ = __ptr_->__prev_;\n        return *this;\n    }\n    ...\n}\n```\n源码本身比较复杂，需要关注的有三点。一是迭代器内部有一指针`__ptr_`指向`list`容器中的元素`__list_node`，二是`typedef bidirectional_iterator_tag iterator_category;`定义了`__list_iterator`的类型是双向链表，我们可以通过模板元编程利用这一内置类型判断迭代器类型，利用函数重载选择算法的不同版本。三是迭代器定义了运算`++`,`--`，还有`->`,`*`这里没有列出，总之迭代器中应该包含遍历容器中元素需要的算术运算和操作。\n\n容器`list`包含`node`对象指向结尾元素，且可以通过`begin`或者`end`方法获得迭代器：\n```\ntemplate <class T, class Alloc = allocator<T> >\nclass list\n{\n    typedef __list_iterator<value_type, __void_pointer>             iterator;\npublic:\n    __node_base __end_;\n    iterator begin() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return iterator(__end_.__next_, this);\n#else\n        return iterator(__end_.__next_);\n#endif\n}\n```\n\n### 小结\n\n迭代器模式的实现一共有两步：\n\n1. 创建容器专属的迭代器类，包含指针指向容器中元素类型以及指针的算术运算和解引用等操作\n2. 创建容器类，包含函数返回指向容器开始或者结束元素的迭代器\n\n迭代器模式是为容器的使用者提供遍历，当需要遍历容器进行操作时，我们首先利用`begin()`方法获得迭代器，如`list.begin()`,然后利用迭代器的`++`和`--`的方法遍历容器，利用`*`或者`->`取指向的元素值。具体例子如文章开始`includes()`函数所示。迭代器也可以看作对指针的包装，如果不使用迭代器我们就需要了解容器的设计细节才能正确使用指针，在容器的设计复杂的情况下(如`deque`)，用户很容易犯错，因此迭代器相当于替用户编写了常用的容器操作。\n\n### 思考\n  - 迭代器模式是通过增加间接性对程序进行抽象，从而使得代码的使用者可以在较高的层次上(具体来说就是`iterator`这一接口)对多种类型的容器设计一份或几份（但是少于容器种类）代码，从而减轻了维护代码的负担。\n  - 迭代器模式使用范围应该是仅仅限于可以进行迭代的容器，它更通用思想在于上面提到的提取多个类之间的共性，将其作为接口，所有类都实现该接口，从而这些类的使用者无需考虑具体类的细节，利用接口即可实现对这些类的操作，减少了代码量。\n  - 设计模式在程序设计初期有用，并且只有我们对需要设计的对象有足够的了解才能知道如何使用设计模式。\n\n\n\n","source":"_posts/《STL-源码剖析》阅读总结-设计模式-迭代器模式.md","raw":"---\ntitle: 《STL 源码剖析》阅读总结 - 设计模式\ndate: 2020-05-03 14:31:15\ntags:\n- STL\n- C++\ncategories:\n- C++\n---\n## 简述\n\n\n关于什么是设计模式及其优缺点的讨论可以在知乎的一些问题上找到：[问题1](https://www.zhihu.com/question/23757237)，[问题2](https://zhuanlan.zhihu.com/p/19835717)。\n\n我的理解是，每一个设计模式都是在程序设计过程中遇到的一些问题的解决方案，这些解决方案在实践中被证明在提升开发效率，代码重用性，可读性等方面都具有一定优势。因此我们理解了每一种设计模式解决的问题后，在编码的过程中遵循设计模式一方面可以帮助我们理清逻辑漏洞，另一方面客观上也提升了代码的质量。[runoob.com](https://www.runoob.com/design-pattern/design-pattern-intro.html)上对于设计模式的使用场景的阐述也比较客观。\n\n本文总结了侯捷《STL源码剖析》一书中提及的STL库中涉及的设计模式。以下引用源码来自[libc++ 10.0.0](https://libcxx.llvm.org/)\n\n## 迭代器模式\n\n### 意图\n\n无需暴露容器内部细节即可访问元素内部元素，因此针对多种容器的同一种操作可以借由迭代器进行泛化，减少了代码量，有利于代码的维护和理解。\n\n例如，下面`includes`函数判断容器中是否包含某个子序列，这个容器可以是`vector`,`list`,`deque`等，对于不同的容器，我们只需要维护下面一份代码就可以了。\n```\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX17 bool\n__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n           _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1)\n    {\n        if (__first1 == __last1 || __comp(*__first2, *__first1))\n            return false;\n        if (!__comp(*__first1, *__first2))\n            ++__first2;\n    }\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\n_LIBCPP_NODISCARD_EXT inline\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n         _Compare __comp)\n{\n    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n}\n```\n\n### 优点\n\n1. 增加新的容器时不需要修改算法代码\n\n### 缺点\n\n1. 增加新的容器需要添加相应的迭代类，事实上，迭代器设计模式将维护工作从容器的使用者转移到了容器的编写者，相应地减少了使用者犯错的可能。\n\n### STL 实践\n\n首先，迭代器应该是指向容器内部元素指针的包装，我们可以通过该迭代器取出指向位置的值，也可以对迭代器进行算术运算，从而使其指向容器中的上一个元素或者下一个元素。其次，不同容器的迭代器行为是有差异的，例如数组`array`或者`vector`是一块连续内存，因此我们可以让迭代器前进或者后退任意步，操作都是常数时间复杂度；而非连续的容器如双向链表`list`不能在常数时间内跳跃任意步，每次只能前进或者后退一步；单向链表`slist`则只能前进，无法后退。因此，我们应该对每种容器设计相应的迭代器类，而不能只设计一个泛化的迭代器。其三，针对不同类型的迭代器，有时候我们可以利用模板偏特化重载算法。\n\n基于以上几点，STL规定在设计容器的`iterator`类时必须包含指向容器中元素的指针，并且定义相应的前进后退算法,例如双向链表`list`的迭代器设计为：\n```\ntemplate <class _Tp, class _VoidPtr>\nclass _LIBCPP_TEMPLATE_VIS __list_iterator\n{\n    ...\n    typedef __list_node_pointer_traits<_Tp, _VoidPtr> _NodeTraits;\n    typedef typename _NodeTraits::__link_pointer __link_pointer;\n\n    __link_pointer __ptr_;\n\npublic:\n    typedef bidirectional_iterator_tag       iterator_category;\n    \n\n    __list_iterator& operator++()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable list::iterator\");\n#endif\n        __ptr_ = __ptr_->__next_;\n        return *this;\n    }\n\n    __list_iterator& operator--()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable list::iterator\");\n#endif\n        __ptr_ = __ptr_->__prev_;\n        return *this;\n    }\n    ...\n}\n```\n源码本身比较复杂，需要关注的有三点。一是迭代器内部有一指针`__ptr_`指向`list`容器中的元素`__list_node`，二是`typedef bidirectional_iterator_tag iterator_category;`定义了`__list_iterator`的类型是双向链表，我们可以通过模板元编程利用这一内置类型判断迭代器类型，利用函数重载选择算法的不同版本。三是迭代器定义了运算`++`,`--`，还有`->`,`*`这里没有列出，总之迭代器中应该包含遍历容器中元素需要的算术运算和操作。\n\n容器`list`包含`node`对象指向结尾元素，且可以通过`begin`或者`end`方法获得迭代器：\n```\ntemplate <class T, class Alloc = allocator<T> >\nclass list\n{\n    typedef __list_iterator<value_type, __void_pointer>             iterator;\npublic:\n    __node_base __end_;\n    iterator begin() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return iterator(__end_.__next_, this);\n#else\n        return iterator(__end_.__next_);\n#endif\n}\n```\n\n### 小结\n\n迭代器模式的实现一共有两步：\n\n1. 创建容器专属的迭代器类，包含指针指向容器中元素类型以及指针的算术运算和解引用等操作\n2. 创建容器类，包含函数返回指向容器开始或者结束元素的迭代器\n\n迭代器模式是为容器的使用者提供遍历，当需要遍历容器进行操作时，我们首先利用`begin()`方法获得迭代器，如`list.begin()`,然后利用迭代器的`++`和`--`的方法遍历容器，利用`*`或者`->`取指向的元素值。具体例子如文章开始`includes()`函数所示。迭代器也可以看作对指针的包装，如果不使用迭代器我们就需要了解容器的设计细节才能正确使用指针，在容器的设计复杂的情况下(如`deque`)，用户很容易犯错，因此迭代器相当于替用户编写了常用的容器操作。\n\n### 思考\n  - 迭代器模式是通过增加间接性对程序进行抽象，从而使得代码的使用者可以在较高的层次上(具体来说就是`iterator`这一接口)对多种类型的容器设计一份或几份（但是少于容器种类）代码，从而减轻了维护代码的负担。\n  - 迭代器模式使用范围应该是仅仅限于可以进行迭代的容器，它更通用思想在于上面提到的提取多个类之间的共性，将其作为接口，所有类都实现该接口，从而这些类的使用者无需考虑具体类的细节，利用接口即可实现对这些类的操作，减少了代码量。\n  - 设计模式在程序设计初期有用，并且只有我们对需要设计的对象有足够的了解才能知道如何使用设计模式。\n\n\n\n","slug":"《STL-源码剖析》阅读总结-设计模式-迭代器模式","published":1,"updated":"2020-05-08T12:55:36.956Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixs1000zk4r3w72zwi0y","content":"<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h2><p>关于什么是设计模式及其优缺点的讨论可以在知乎的一些问题上找到：<a href=\"https://www.zhihu.com/question/23757237\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">问题1</a>，<a href=\"https://zhuanlan.zhihu.com/p/19835717\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">问题2</a>。</p>\n<p>我的理解是，每一个设计模式都是在程序设计过程中遇到的一些问题的解决方案，这些解决方案在实践中被证明在提升开发效率，代码重用性，可读性等方面都具有一定优势。因此我们理解了每一种设计模式解决的问题后，在编码的过程中遵循设计模式一方面可以帮助我们理清逻辑漏洞，另一方面客观上也提升了代码的质量。<a href=\"https://www.runoob.com/design-pattern/design-pattern-intro.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">runoob.com</a>上对于设计模式的使用场景的阐述也比较客观。</p>\n<p>本文总结了侯捷《STL源码剖析》一书中提及的STL库中涉及的设计模式。以下引用源码来自<a href=\"https://libcxx.llvm.org/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">libc++ 10.0.0</a></p>\n<h2 id=\"迭代器模式\"><a href=\"#迭代器模式\" class=\"headerlink\" title=\"迭代器模式\"></a>迭代器模式</h2><h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>无需暴露容器内部细节即可访问元素内部元素，因此针对多种容器的同一种操作可以借由迭代器进行泛化，减少了代码量，有利于代码的维护和理解。</p>\n<p>例如，下面<code>includes</code>函数判断容器中是否包含某个子序列，这个容器可以是<code>vector</code>,<code>list</code>,<code>deque</code>等，对于不同的容器，我们只需要维护下面一份代码就可以了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class _Compare, class _InputIterator1, class _InputIterator2&gt;</span><br><span class=\"line\">_LIBCPP_CONSTEXPR_AFTER_CXX17 bool</span><br><span class=\"line\">__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,</span><br><span class=\"line\">           _Compare __comp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (; __first2 != __last2; ++__first1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (__first1 == __last1 || __comp(*__first2, *__first1))</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        if (!__comp(*__first1, *__first2))</span><br><span class=\"line\">            ++__first2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;class _InputIterator1, class _InputIterator2, class _Compare&gt;</span><br><span class=\"line\">_LIBCPP_NODISCARD_EXT inline</span><br><span class=\"line\">_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17</span><br><span class=\"line\">bool</span><br><span class=\"line\">includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,</span><br><span class=\"line\">         _Compare __comp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    typedef typename __comp_ref_type&lt;_Compare&gt;::type _Comp_ref;</span><br><span class=\"line\">    return __includes&lt;_Comp_ref&gt;(__first1, __last1, __first2, __last2, __comp);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ol>\n<li>增加新的容器时不需要修改算法代码</li>\n</ol>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ol>\n<li>增加新的容器需要添加相应的迭代类，事实上，迭代器设计模式将维护工作从容器的使用者转移到了容器的编写者，相应地减少了使用者犯错的可能。</li>\n</ol>\n<h3 id=\"STL-实践\"><a href=\"#STL-实践\" class=\"headerlink\" title=\"STL 实践\"></a>STL 实践</h3><p>首先，迭代器应该是指向容器内部元素指针的包装，我们可以通过该迭代器取出指向位置的值，也可以对迭代器进行算术运算，从而使其指向容器中的上一个元素或者下一个元素。其次，不同容器的迭代器行为是有差异的，例如数组<code>array</code>或者<code>vector</code>是一块连续内存，因此我们可以让迭代器前进或者后退任意步，操作都是常数时间复杂度；而非连续的容器如双向链表<code>list</code>不能在常数时间内跳跃任意步，每次只能前进或者后退一步；单向链表<code>slist</code>则只能前进，无法后退。因此，我们应该对每种容器设计相应的迭代器类，而不能只设计一个泛化的迭代器。其三，针对不同类型的迭代器，有时候我们可以利用模板偏特化重载算法。</p>\n<p>基于以上几点，STL规定在设计容器的<code>iterator</code>类时必须包含指向容器中元素的指针，并且定义相应的前进后退算法,例如双向链表<code>list</code>的迭代器设计为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class _Tp, class _VoidPtr&gt;</span><br><span class=\"line\">class _LIBCPP_TEMPLATE_VIS __list_iterator</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    typedef __list_node_pointer_traits&lt;_Tp, _VoidPtr&gt; _NodeTraits;</span><br><span class=\"line\">    typedef typename _NodeTraits::__link_pointer __link_pointer;</span><br><span class=\"line\"></span><br><span class=\"line\">    __link_pointer __ptr_;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    typedef bidirectional_iterator_tag       iterator_category;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    __list_iterator&amp; operator++()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">#if _LIBCPP_DEBUG_LEVEL &gt;= 2</span><br><span class=\"line\">        _LIBCPP_ASSERT(__get_const_db()-&gt;__dereferenceable(this),</span><br><span class=\"line\">                       &quot;Attempted to increment non-incrementable list::iterator&quot;);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">        __ptr_ = __ptr_-&gt;__next_;</span><br><span class=\"line\">        return *this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    __list_iterator&amp; operator--()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">#if _LIBCPP_DEBUG_LEVEL &gt;= 2</span><br><span class=\"line\">        _LIBCPP_ASSERT(__get_const_db()-&gt;__decrementable(this),</span><br><span class=\"line\">                       &quot;Attempted to decrement non-decrementable list::iterator&quot;);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">        __ptr_ = __ptr_-&gt;__prev_;</span><br><span class=\"line\">        return *this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>源码本身比较复杂，需要关注的有三点。一是迭代器内部有一指针<code>__ptr_</code>指向<code>list</code>容器中的元素<code>__list_node</code>，二是<code>typedef bidirectional_iterator_tag iterator_category;</code>定义了<code>__list_iterator</code>的类型是双向链表，我们可以通过模板元编程利用这一内置类型判断迭代器类型，利用函数重载选择算法的不同版本。三是迭代器定义了运算<code>++</code>,<code>--</code>，还有<code>-&gt;</code>,<code>*</code>这里没有列出，总之迭代器中应该包含遍历容器中元素需要的算术运算和操作。</p>\n<p>容器<code>list</code>包含<code>node</code>对象指向结尾元素，且可以通过<code>begin</code>或者<code>end</code>方法获得迭代器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class T, class Alloc = allocator&lt;T&gt; &gt;</span><br><span class=\"line\">class list</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    typedef __list_iterator&lt;value_type, __void_pointer&gt;             iterator;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    __node_base __end_;</span><br><span class=\"line\">    iterator begin() _NOEXCEPT</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">#if _LIBCPP_DEBUG_LEVEL &gt;= 2</span><br><span class=\"line\">        return iterator(__end_.__next_, this);</span><br><span class=\"line\">#else</span><br><span class=\"line\">        return iterator(__end_.__next_);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>迭代器模式的实现一共有两步：</p>\n<ol>\n<li>创建容器专属的迭代器类，包含指针指向容器中元素类型以及指针的算术运算和解引用等操作</li>\n<li>创建容器类，包含函数返回指向容器开始或者结束元素的迭代器</li>\n</ol>\n<p>迭代器模式是为容器的使用者提供遍历，当需要遍历容器进行操作时，我们首先利用<code>begin()</code>方法获得迭代器，如<code>list.begin()</code>,然后利用迭代器的<code>++</code>和<code>--</code>的方法遍历容器，利用<code>*</code>或者<code>-&gt;</code>取指向的元素值。具体例子如文章开始<code>includes()</code>函数所示。迭代器也可以看作对指针的包装，如果不使用迭代器我们就需要了解容器的设计细节才能正确使用指针，在容器的设计复杂的情况下(如<code>deque</code>)，用户很容易犯错，因此迭代器相当于替用户编写了常用的容器操作。</p>\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h3><ul>\n<li>迭代器模式是通过增加间接性对程序进行抽象，从而使得代码的使用者可以在较高的层次上(具体来说就是<code>iterator</code>这一接口)对多种类型的容器设计一份或几份（但是少于容器种类）代码，从而减轻了维护代码的负担。</li>\n<li>迭代器模式使用范围应该是仅仅限于可以进行迭代的容器，它更通用思想在于上面提到的提取多个类之间的共性，将其作为接口，所有类都实现该接口，从而这些类的使用者无需考虑具体类的细节，利用接口即可实现对这些类的操作，减少了代码量。</li>\n<li>设计模式在程序设计初期有用，并且只有我们对需要设计的对象有足够的了解才能知道如何使用设计模式。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h2><p>关于什么是设计模式及其优缺点的讨论可以在知乎的一些问题上找到：<a href=\"https://www.zhihu.com/question/23757237\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">问题1</a>，<a href=\"https://zhuanlan.zhihu.com/p/19835717\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">问题2</a>。</p>\n<p>我的理解是，每一个设计模式都是在程序设计过程中遇到的一些问题的解决方案，这些解决方案在实践中被证明在提升开发效率，代码重用性，可读性等方面都具有一定优势。因此我们理解了每一种设计模式解决的问题后，在编码的过程中遵循设计模式一方面可以帮助我们理清逻辑漏洞，另一方面客观上也提升了代码的质量。<a href=\"https://www.runoob.com/design-pattern/design-pattern-intro.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">runoob.com</a>上对于设计模式的使用场景的阐述也比较客观。</p>\n<p>本文总结了侯捷《STL源码剖析》一书中提及的STL库中涉及的设计模式。以下引用源码来自<a href=\"https://libcxx.llvm.org/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">libc++ 10.0.0</a></p>\n<h2 id=\"迭代器模式\"><a href=\"#迭代器模式\" class=\"headerlink\" title=\"迭代器模式\"></a>迭代器模式</h2><h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>无需暴露容器内部细节即可访问元素内部元素，因此针对多种容器的同一种操作可以借由迭代器进行泛化，减少了代码量，有利于代码的维护和理解。</p>\n<p>例如，下面<code>includes</code>函数判断容器中是否包含某个子序列，这个容器可以是<code>vector</code>,<code>list</code>,<code>deque</code>等，对于不同的容器，我们只需要维护下面一份代码就可以了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class _Compare, class _InputIterator1, class _InputIterator2&gt;</span><br><span class=\"line\">_LIBCPP_CONSTEXPR_AFTER_CXX17 bool</span><br><span class=\"line\">__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,</span><br><span class=\"line\">           _Compare __comp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (; __first2 != __last2; ++__first1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (__first1 == __last1 || __comp(*__first2, *__first1))</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        if (!__comp(*__first1, *__first2))</span><br><span class=\"line\">            ++__first2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;class _InputIterator1, class _InputIterator2, class _Compare&gt;</span><br><span class=\"line\">_LIBCPP_NODISCARD_EXT inline</span><br><span class=\"line\">_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17</span><br><span class=\"line\">bool</span><br><span class=\"line\">includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,</span><br><span class=\"line\">         _Compare __comp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    typedef typename __comp_ref_type&lt;_Compare&gt;::type _Comp_ref;</span><br><span class=\"line\">    return __includes&lt;_Comp_ref&gt;(__first1, __last1, __first2, __last2, __comp);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ol>\n<li>增加新的容器时不需要修改算法代码</li>\n</ol>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ol>\n<li>增加新的容器需要添加相应的迭代类，事实上，迭代器设计模式将维护工作从容器的使用者转移到了容器的编写者，相应地减少了使用者犯错的可能。</li>\n</ol>\n<h3 id=\"STL-实践\"><a href=\"#STL-实践\" class=\"headerlink\" title=\"STL 实践\"></a>STL 实践</h3><p>首先，迭代器应该是指向容器内部元素指针的包装，我们可以通过该迭代器取出指向位置的值，也可以对迭代器进行算术运算，从而使其指向容器中的上一个元素或者下一个元素。其次，不同容器的迭代器行为是有差异的，例如数组<code>array</code>或者<code>vector</code>是一块连续内存，因此我们可以让迭代器前进或者后退任意步，操作都是常数时间复杂度；而非连续的容器如双向链表<code>list</code>不能在常数时间内跳跃任意步，每次只能前进或者后退一步；单向链表<code>slist</code>则只能前进，无法后退。因此，我们应该对每种容器设计相应的迭代器类，而不能只设计一个泛化的迭代器。其三，针对不同类型的迭代器，有时候我们可以利用模板偏特化重载算法。</p>\n<p>基于以上几点，STL规定在设计容器的<code>iterator</code>类时必须包含指向容器中元素的指针，并且定义相应的前进后退算法,例如双向链表<code>list</code>的迭代器设计为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class _Tp, class _VoidPtr&gt;</span><br><span class=\"line\">class _LIBCPP_TEMPLATE_VIS __list_iterator</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    typedef __list_node_pointer_traits&lt;_Tp, _VoidPtr&gt; _NodeTraits;</span><br><span class=\"line\">    typedef typename _NodeTraits::__link_pointer __link_pointer;</span><br><span class=\"line\"></span><br><span class=\"line\">    __link_pointer __ptr_;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    typedef bidirectional_iterator_tag       iterator_category;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    __list_iterator&amp; operator++()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">#if _LIBCPP_DEBUG_LEVEL &gt;= 2</span><br><span class=\"line\">        _LIBCPP_ASSERT(__get_const_db()-&gt;__dereferenceable(this),</span><br><span class=\"line\">                       &quot;Attempted to increment non-incrementable list::iterator&quot;);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">        __ptr_ = __ptr_-&gt;__next_;</span><br><span class=\"line\">        return *this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    __list_iterator&amp; operator--()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">#if _LIBCPP_DEBUG_LEVEL &gt;= 2</span><br><span class=\"line\">        _LIBCPP_ASSERT(__get_const_db()-&gt;__decrementable(this),</span><br><span class=\"line\">                       &quot;Attempted to decrement non-decrementable list::iterator&quot;);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">        __ptr_ = __ptr_-&gt;__prev_;</span><br><span class=\"line\">        return *this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>源码本身比较复杂，需要关注的有三点。一是迭代器内部有一指针<code>__ptr_</code>指向<code>list</code>容器中的元素<code>__list_node</code>，二是<code>typedef bidirectional_iterator_tag iterator_category;</code>定义了<code>__list_iterator</code>的类型是双向链表，我们可以通过模板元编程利用这一内置类型判断迭代器类型，利用函数重载选择算法的不同版本。三是迭代器定义了运算<code>++</code>,<code>--</code>，还有<code>-&gt;</code>,<code>*</code>这里没有列出，总之迭代器中应该包含遍历容器中元素需要的算术运算和操作。</p>\n<p>容器<code>list</code>包含<code>node</code>对象指向结尾元素，且可以通过<code>begin</code>或者<code>end</code>方法获得迭代器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class T, class Alloc = allocator&lt;T&gt; &gt;</span><br><span class=\"line\">class list</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    typedef __list_iterator&lt;value_type, __void_pointer&gt;             iterator;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    __node_base __end_;</span><br><span class=\"line\">    iterator begin() _NOEXCEPT</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">#if _LIBCPP_DEBUG_LEVEL &gt;= 2</span><br><span class=\"line\">        return iterator(__end_.__next_, this);</span><br><span class=\"line\">#else</span><br><span class=\"line\">        return iterator(__end_.__next_);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>迭代器模式的实现一共有两步：</p>\n<ol>\n<li>创建容器专属的迭代器类，包含指针指向容器中元素类型以及指针的算术运算和解引用等操作</li>\n<li>创建容器类，包含函数返回指向容器开始或者结束元素的迭代器</li>\n</ol>\n<p>迭代器模式是为容器的使用者提供遍历，当需要遍历容器进行操作时，我们首先利用<code>begin()</code>方法获得迭代器，如<code>list.begin()</code>,然后利用迭代器的<code>++</code>和<code>--</code>的方法遍历容器，利用<code>*</code>或者<code>-&gt;</code>取指向的元素值。具体例子如文章开始<code>includes()</code>函数所示。迭代器也可以看作对指针的包装，如果不使用迭代器我们就需要了解容器的设计细节才能正确使用指针，在容器的设计复杂的情况下(如<code>deque</code>)，用户很容易犯错，因此迭代器相当于替用户编写了常用的容器操作。</p>\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h3><ul>\n<li>迭代器模式是通过增加间接性对程序进行抽象，从而使得代码的使用者可以在较高的层次上(具体来说就是<code>iterator</code>这一接口)对多种类型的容器设计一份或几份（但是少于容器种类）代码，从而减轻了维护代码的负担。</li>\n<li>迭代器模式使用范围应该是仅仅限于可以进行迭代的容器，它更通用思想在于上面提到的提取多个类之间的共性，将其作为接口，所有类都实现该接口，从而这些类的使用者无需考虑具体类的细节，利用接口即可实现对这些类的操作，减少了代码量。</li>\n<li>设计模式在程序设计初期有用，并且只有我们对需要设计的对象有足够的了解才能知道如何使用设计模式。</li>\n</ul>\n"},{"title":"ReentrantLock","date":"2019-09-11T05:30:58.000Z","_content":"# Data Structure \n![basic structure](/images/reentrantlock1.png)\nAs shown in above picture, `ReentrantLock` has only one property: `sync` of type `Sync`, which extends from `AbstracQueueSynchronizer`, `AQS` in brief. `AQS` is a synchronzier for many classes in J.U.C, allowing programmers implementing their own Lock without dealing with the detail of maintainning a synchronizing queue.\n\n# AbstractQueueSynchronizer\n`AQS` maintains a `FIFO` queue ,  a `int` and a `Thread` type properties inside. The `state` is set to be `0` when no one owns the synchronizer. Every thread try to get the ownership of synchronizer by an atomic instruction `CAS` provided by CPU. Threads will try to set  `state` to `1` by `unsafe.compareAndSwapInt(this, stateOffset, 0, 1);`, the first and second parameters together make the address of `state`, the third parameter `0` indicates the old value of `state`, and the last indicates the value we'd like to set. If `state` is not `0`, this function won't set it to `1` and returns false, otherwise it returns ture. This operation is atomic so only one thread can set `state` successfully, and it will set the ownership of the synchronizer by `exclusiveOwnerThread = Thread.currentThread();`.\n\nBy far, we have make clear how a thread get the ownership of the synchronizer sucessfully, but what will the most threads that fails in the competition do? They just wrap themseleves up as a `Node` and append to the waiting queue in the synchronizer, and then they will choose to spin themselves or sleep.\n\n`spin` is actually a infinite loop with an operation in it. Here is an example:\n\n```\nfor(;;)\nif(compareAndSetState(0,1))break;\n```\n\nThe thread tries to set state again and again if they fails. It works well if the competition of threads is not too fierce. Nevertheless, think about one thread holds the synchronizer for a long time, and during that time, other threads have to spin again and again, it's a waste of CPU resource! So only the thread next to head node in the waiting queue will do so. All others threads will invoke `LockSupport.park()` to sleep themselves until the thread before it wake them up by `LockSupport.unpark(thread)`(in the queue, they are predecessor node and sucessor node).\n\n# ReentrantLock\n`AQS` has done most jobs for `ReentranLock`:\n- the mutex: `state`\n- how to get the mutex: `CAS`\n- what will a thread do after fails to get the mutex: wrap it up as `Node` , push it into the waiting queue, and then choose to spin or sleep.\n- what will the thread do after get the mutex: wrap it up as a `Node`, set itself as the head node of waiting queue. When it finishes its task, it will set the `state` to `0` and wake the successor `Node` up in the waiting queue. \n\n`ReentrantLock` means a thread can get the synchronizer many times. The crutial part is it overrided the method for acquire `state` in `AQS`. After fails to set `state` from 0 to 1, the current thread will check if `exclusiveOwnerThread == Thread.currentThread()`. If so, increament `state` by 1, and decrease it after one thread finished its task and try to release the synchronizer.","source":"_posts/ReentrantLock.md","raw":"---\ntitle: ReentrantLock\ndate: 2019-09-11 13:30:58\ntags:\n- ReentrantLock\n- J.U.C\n- Concurrency\ncategories:\n- Concurrency\n---\n# Data Structure \n![basic structure](/images/reentrantlock1.png)\nAs shown in above picture, `ReentrantLock` has only one property: `sync` of type `Sync`, which extends from `AbstracQueueSynchronizer`, `AQS` in brief. `AQS` is a synchronzier for many classes in J.U.C, allowing programmers implementing their own Lock without dealing with the detail of maintainning a synchronizing queue.\n\n# AbstractQueueSynchronizer\n`AQS` maintains a `FIFO` queue ,  a `int` and a `Thread` type properties inside. The `state` is set to be `0` when no one owns the synchronizer. Every thread try to get the ownership of synchronizer by an atomic instruction `CAS` provided by CPU. Threads will try to set  `state` to `1` by `unsafe.compareAndSwapInt(this, stateOffset, 0, 1);`, the first and second parameters together make the address of `state`, the third parameter `0` indicates the old value of `state`, and the last indicates the value we'd like to set. If `state` is not `0`, this function won't set it to `1` and returns false, otherwise it returns ture. This operation is atomic so only one thread can set `state` successfully, and it will set the ownership of the synchronizer by `exclusiveOwnerThread = Thread.currentThread();`.\n\nBy far, we have make clear how a thread get the ownership of the synchronizer sucessfully, but what will the most threads that fails in the competition do? They just wrap themseleves up as a `Node` and append to the waiting queue in the synchronizer, and then they will choose to spin themselves or sleep.\n\n`spin` is actually a infinite loop with an operation in it. Here is an example:\n\n```\nfor(;;)\nif(compareAndSetState(0,1))break;\n```\n\nThe thread tries to set state again and again if they fails. It works well if the competition of threads is not too fierce. Nevertheless, think about one thread holds the synchronizer for a long time, and during that time, other threads have to spin again and again, it's a waste of CPU resource! So only the thread next to head node in the waiting queue will do so. All others threads will invoke `LockSupport.park()` to sleep themselves until the thread before it wake them up by `LockSupport.unpark(thread)`(in the queue, they are predecessor node and sucessor node).\n\n# ReentrantLock\n`AQS` has done most jobs for `ReentranLock`:\n- the mutex: `state`\n- how to get the mutex: `CAS`\n- what will a thread do after fails to get the mutex: wrap it up as `Node` , push it into the waiting queue, and then choose to spin or sleep.\n- what will the thread do after get the mutex: wrap it up as a `Node`, set itself as the head node of waiting queue. When it finishes its task, it will set the `state` to `0` and wake the successor `Node` up in the waiting queue. \n\n`ReentrantLock` means a thread can get the synchronizer many times. The crutial part is it overrided the method for acquire `state` in `AQS`. After fails to set `state` from 0 to 1, the current thread will check if `exclusiveOwnerThread == Thread.currentThread()`. If so, increament `state` by 1, and decrease it after one thread finished its task and try to release the synchronizer.","slug":"ReentrantLock","published":1,"updated":"2020-05-03T06:14:50.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka27ixs20010k4r3byi0eroe","content":"<h1 id=\"Data-Structure\"><a href=\"#Data-Structure\" class=\"headerlink\" title=\"Data Structure\"></a>Data Structure</h1><p><img src=\"/images/reentrantlock1.png\" alt=\"basic structure\"><br>As shown in above picture, <code>ReentrantLock</code> has only one property: <code>sync</code> of type <code>Sync</code>, which extends from <code>AbstracQueueSynchronizer</code>, <code>AQS</code> in brief. <code>AQS</code> is a synchronzier for many classes in J.U.C, allowing programmers implementing their own Lock without dealing with the detail of maintainning a synchronizing queue.</p>\n<h1 id=\"AbstractQueueSynchronizer\"><a href=\"#AbstractQueueSynchronizer\" class=\"headerlink\" title=\"AbstractQueueSynchronizer\"></a>AbstractQueueSynchronizer</h1><p><code>AQS</code> maintains a <code>FIFO</code> queue ,  a <code>int</code> and a <code>Thread</code> type properties inside. The <code>state</code> is set to be <code>0</code> when no one owns the synchronizer. Every thread try to get the ownership of synchronizer by an atomic instruction <code>CAS</code> provided by CPU. Threads will try to set  <code>state</code> to <code>1</code> by <code>unsafe.compareAndSwapInt(this, stateOffset, 0, 1);</code>, the first and second parameters together make the address of <code>state</code>, the third parameter <code>0</code> indicates the old value of <code>state</code>, and the last indicates the value we’d like to set. If <code>state</code> is not <code>0</code>, this function won’t set it to <code>1</code> and returns false, otherwise it returns ture. This operation is atomic so only one thread can set <code>state</code> successfully, and it will set the ownership of the synchronizer by <code>exclusiveOwnerThread = Thread.currentThread();</code>.</p>\n<p>By far, we have make clear how a thread get the ownership of the synchronizer sucessfully, but what will the most threads that fails in the competition do? They just wrap themseleves up as a <code>Node</code> and append to the waiting queue in the synchronizer, and then they will choose to spin themselves or sleep.</p>\n<p><code>spin</code> is actually a infinite loop with an operation in it. Here is an example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(;;)</span><br><span class=\"line\">if(compareAndSetState(0,1))break;</span><br></pre></td></tr></table></figure>\n<p>The thread tries to set state again and again if they fails. It works well if the competition of threads is not too fierce. Nevertheless, think about one thread holds the synchronizer for a long time, and during that time, other threads have to spin again and again, it’s a waste of CPU resource! So only the thread next to head node in the waiting queue will do so. All others threads will invoke <code>LockSupport.park()</code> to sleep themselves until the thread before it wake them up by <code>LockSupport.unpark(thread)</code>(in the queue, they are predecessor node and sucessor node).</p>\n<h1 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h1><p><code>AQS</code> has done most jobs for <code>ReentranLock</code>:</p>\n<ul>\n<li>the mutex: <code>state</code></li>\n<li>how to get the mutex: <code>CAS</code></li>\n<li>what will a thread do after fails to get the mutex: wrap it up as <code>Node</code> , push it into the waiting queue, and then choose to spin or sleep.</li>\n<li>what will the thread do after get the mutex: wrap it up as a <code>Node</code>, set itself as the head node of waiting queue. When it finishes its task, it will set the <code>state</code> to <code>0</code> and wake the successor <code>Node</code> up in the waiting queue. </li>\n</ul>\n<p><code>ReentrantLock</code> means a thread can get the synchronizer many times. The crutial part is it overrided the method for acquire <code>state</code> in <code>AQS</code>. After fails to set <code>state</code> from 0 to 1, the current thread will check if <code>exclusiveOwnerThread == Thread.currentThread()</code>. If so, increament <code>state</code> by 1, and decrease it after one thread finished its task and try to release the synchronizer.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Data-Structure\"><a href=\"#Data-Structure\" class=\"headerlink\" title=\"Data Structure\"></a>Data Structure</h1><p><img src=\"/images/reentrantlock1.png\" alt=\"basic structure\"><br>As shown in above picture, <code>ReentrantLock</code> has only one property: <code>sync</code> of type <code>Sync</code>, which extends from <code>AbstracQueueSynchronizer</code>, <code>AQS</code> in brief. <code>AQS</code> is a synchronzier for many classes in J.U.C, allowing programmers implementing their own Lock without dealing with the detail of maintainning a synchronizing queue.</p>\n<h1 id=\"AbstractQueueSynchronizer\"><a href=\"#AbstractQueueSynchronizer\" class=\"headerlink\" title=\"AbstractQueueSynchronizer\"></a>AbstractQueueSynchronizer</h1><p><code>AQS</code> maintains a <code>FIFO</code> queue ,  a <code>int</code> and a <code>Thread</code> type properties inside. The <code>state</code> is set to be <code>0</code> when no one owns the synchronizer. Every thread try to get the ownership of synchronizer by an atomic instruction <code>CAS</code> provided by CPU. Threads will try to set  <code>state</code> to <code>1</code> by <code>unsafe.compareAndSwapInt(this, stateOffset, 0, 1);</code>, the first and second parameters together make the address of <code>state</code>, the third parameter <code>0</code> indicates the old value of <code>state</code>, and the last indicates the value we’d like to set. If <code>state</code> is not <code>0</code>, this function won’t set it to <code>1</code> and returns false, otherwise it returns ture. This operation is atomic so only one thread can set <code>state</code> successfully, and it will set the ownership of the synchronizer by <code>exclusiveOwnerThread = Thread.currentThread();</code>.</p>\n<p>By far, we have make clear how a thread get the ownership of the synchronizer sucessfully, but what will the most threads that fails in the competition do? They just wrap themseleves up as a <code>Node</code> and append to the waiting queue in the synchronizer, and then they will choose to spin themselves or sleep.</p>\n<p><code>spin</code> is actually a infinite loop with an operation in it. Here is an example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(;;)</span><br><span class=\"line\">if(compareAndSetState(0,1))break;</span><br></pre></td></tr></table></figure>\n<p>The thread tries to set state again and again if they fails. It works well if the competition of threads is not too fierce. Nevertheless, think about one thread holds the synchronizer for a long time, and during that time, other threads have to spin again and again, it’s a waste of CPU resource! So only the thread next to head node in the waiting queue will do so. All others threads will invoke <code>LockSupport.park()</code> to sleep themselves until the thread before it wake them up by <code>LockSupport.unpark(thread)</code>(in the queue, they are predecessor node and sucessor node).</p>\n<h1 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h1><p><code>AQS</code> has done most jobs for <code>ReentranLock</code>:</p>\n<ul>\n<li>the mutex: <code>state</code></li>\n<li>how to get the mutex: <code>CAS</code></li>\n<li>what will a thread do after fails to get the mutex: wrap it up as <code>Node</code> , push it into the waiting queue, and then choose to spin or sleep.</li>\n<li>what will the thread do after get the mutex: wrap it up as a <code>Node</code>, set itself as the head node of waiting queue. When it finishes its task, it will set the <code>state</code> to <code>0</code> and wake the successor <code>Node</code> up in the waiting queue. </li>\n</ul>\n<p><code>ReentrantLock</code> means a thread can get the synchronizer many times. The crutial part is it overrided the method for acquire <code>state</code> in <code>AQS</code>. After fails to set <code>state</code> from 0 to 1, the current thread will check if <code>exclusiveOwnerThread == Thread.currentThread()</code>. If so, increament <code>state</code> by 1, and decrease it after one thread finished its task and try to release the synchronizer.</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cka27ixqd0002k4r3bodb3133","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0d0034k4r37ntdshpz"},{"post_id":"cka27ixqq0004k4r38vhkon4w","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0g0036k4r31vu27gtw"},{"post_id":"cka27ixqt0006k4r363v5rwqh","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0h0038k4r3af1ha61y"},{"post_id":"cka27ixqv0008k4r3yixpktnt","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0j003bk4r3hv3sv02o"},{"post_id":"cka27ixqx000ak4r30ji6auvs","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0k003dk4r3pzguymqs"},{"post_id":"cka27ixr5000bk4r3luqhgqsd","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0l003fk4r3g5015zav"},{"post_id":"cka27ixr6000ck4r35g9x89k6","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0l003hk4r3cnx7nebl"},{"post_id":"cka27ixr8000dk4r30vn85ehv","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0m003jk4r3rntgd38v"},{"post_id":"cka27ixra000ek4r3wy95cqvf","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0n003lk4r33tqj7ke1"},{"post_id":"cka27ixrc000fk4r3jnnhkyzj","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0o003nk4r3f8pw8j3h"},{"post_id":"cka27ixrd000gk4r321lhatpo","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0o003pk4r3ez4rzs04"},{"post_id":"cka27ixre000hk4r3hmfezy6k","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0p003rk4r3blszczm5"},{"post_id":"cka27ixrf000ik4r31yyvbksg","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0q003tk4r3i8yyhyf0"},{"post_id":"cka27ixrg000jk4r3tteao7kv","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0r003vk4r3c4sqgmnv"},{"post_id":"cka27ixrh000kk4r3qdcbv3ah","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0r003xk4r3fum7db51"},{"post_id":"cka27ixrj000lk4r3wzhnwb4j","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0s003zk4r3s0pto8ax"},{"post_id":"cka27ixrj000mk4r34rdsftja","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0t0041k4r3h720ktza"},{"post_id":"cka27ixrk000nk4r33by9h7t5","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0u0043k4r36mdvtzev"},{"post_id":"cka27ixrm000ok4r3eqsohxu0","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0u0045k4r388i5ogtw"},{"post_id":"cka27ixrn000pk4r3db3f0ktt","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0v0047k4r34u6upxcr"},{"post_id":"cka27ixrq000qk4r31b3znfng","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0v0049k4r3ctwip5ub"},{"post_id":"cka27ixrv000tk4r38g29ulyl","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0w004bk4r39hjb5cdz"},{"post_id":"cka27ixrw000uk4r3ci3u469u","category_id":"cka27ixuq0011k4r36qajfq08","_id":"cka27iy0x004dk4r381b1t3gb"},{"post_id":"cka27ixrx000vk4r3qrsg6029","category_id":"cka27ixww002ck4r3o87bqxdu","_id":"cka27iy0y004fk4r30udmyue1"},{"post_id":"cka27ixs1000yk4r3j8gd9qcr","category_id":"cka27ixx4002hk4r3c1yfren1","_id":"cka27iy0z004hk4r3bzugeq09"},{"post_id":"cka27ixs1000zk4r3w72zwi0y","category_id":"cka27ixx4002hk4r3c1yfren1","_id":"cka27iy10004jk4r3im2y812c"},{"post_id":"cka27ixs20010k4r3byi0eroe","category_id":"cka27ixxa002lk4r3b0vgndaw","_id":"cka27iy11004lk4r3h2m5lwbc"},{"post_id":"cka27ixrs000rk4r3ud7hjoh0","category_id":"cka27ixwo0026k4r3gufmjozv","_id":"cka27iy2b0053k4r3bkcrahdx"},{"post_id":"cka27ixrs000rk4r3ud7hjoh0","category_id":"cka27iy0c0033k4r34nv29d27","_id":"cka27iy2c0054k4r31koqrmck"},{"post_id":"cka27ixry000wk4r3xketxwji","category_id":"cka27ixwo0026k4r3gufmjozv","_id":"cka27iy2c0055k4r34iptl5pb"},{"post_id":"cka27ixry000wk4r3xketxwji","category_id":"cka27iy0h0039k4r3wp1nx3hd","_id":"cka27iy2d0056k4r3iy1q1dzc"}],"PostTag":[{"post_id":"cka27ixqd0002k4r3bodb3133","tag_id":"cka27ixv50012k4r3f5yef1co","_id":"cka27iy0b0032k4r3wic0onyr"},{"post_id":"cka27ixqq0004k4r38vhkon4w","tag_id":"cka27ixva0014k4r3x66k4ipi","_id":"cka27iy0f0035k4r3sxil2xr7"},{"post_id":"cka27ixqq0004k4r38vhkon4w","tag_id":"cka27ixve0016k4r36jj2gke0","_id":"cka27iy0h0037k4r3hmpcqeng"},{"post_id":"cka27ixqt0006k4r363v5rwqh","tag_id":"cka27ixvg0018k4r35wow208f","_id":"cka27iy0i003ak4r3muvzk5sr"},{"post_id":"cka27ixqt0006k4r363v5rwqh","tag_id":"cka27ixvi001ak4r314xma1fr","_id":"cka27iy0j003ck4r3fac0bkun"},{"post_id":"cka27ixqv0008k4r3yixpktnt","tag_id":"cka27ixvg0018k4r35wow208f","_id":"cka27iy0k003ek4r351fcp94w"},{"post_id":"cka27ixqv0008k4r3yixpktnt","tag_id":"cka27ixvm001ek4r3do8lg8po","_id":"cka27iy0l003gk4r3ym379i2g"},{"post_id":"cka27ixqv0008k4r3yixpktnt","tag_id":"cka27ixvi001ak4r314xma1fr","_id":"cka27iy0m003ik4r31im84yuj"},{"post_id":"cka27ixqx000ak4r30ji6auvs","tag_id":"cka27ixvg0018k4r35wow208f","_id":"cka27iy0n003kk4r36lyxevfp"},{"post_id":"cka27ixr5000bk4r3luqhgqsd","tag_id":"cka27ixvv001kk4r3ti7rqosl","_id":"cka27iy0n003mk4r3x8spxu4d"},{"post_id":"cka27ixr6000ck4r35g9x89k6","tag_id":"cka27ixvg0018k4r35wow208f","_id":"cka27iy0o003ok4r3jy5ck7cc"},{"post_id":"cka27ixr6000ck4r35g9x89k6","tag_id":"cka27ixvi001ak4r314xma1fr","_id":"cka27iy0p003qk4r3umd7ut18"},{"post_id":"cka27ixr8000dk4r30vn85ehv","tag_id":"cka27ixw1001qk4r3c7e734t8","_id":"cka27iy0q003sk4r38fwgqvfp"},{"post_id":"cka27ixra000ek4r3wy95cqvf","tag_id":"cka27ixvg0018k4r35wow208f","_id":"cka27iy0q003uk4r3say3e50g"},{"post_id":"cka27ixrc000fk4r3jnnhkyzj","tag_id":"cka27ixvv001kk4r3ti7rqosl","_id":"cka27iy0r003wk4r3kj50duru"},{"post_id":"cka27ixrd000gk4r321lhatpo","tag_id":"cka27ixvg0018k4r35wow208f","_id":"cka27iy0s003yk4r3n2b93bom"},{"post_id":"cka27ixre000hk4r3hmfezy6k","tag_id":"cka27ixw1001qk4r3c7e734t8","_id":"cka27iy0t0040k4r3dq0cf3sa"},{"post_id":"cka27ixre000hk4r3hmfezy6k","tag_id":"cka27ixvv001kk4r3ti7rqosl","_id":"cka27iy0t0042k4r31vhhnfo3"},{"post_id":"cka27ixrf000ik4r31yyvbksg","tag_id":"cka27ixwi0022k4r3tkw2v1zg","_id":"cka27iy0u0044k4r3p3oshvbx"},{"post_id":"cka27ixrf000ik4r31yyvbksg","tag_id":"cka27ixvv001kk4r3ti7rqosl","_id":"cka27iy0v0046k4r3a0w7cndf"},{"post_id":"cka27ixrg000jk4r3tteao7kv","tag_id":"cka27ixvg0018k4r35wow208f","_id":"cka27iy0v0048k4r37s4znzbd"},{"post_id":"cka27ixrh000kk4r3qdcbv3ah","tag_id":"cka27ixw1001qk4r3c7e734t8","_id":"cka27iy0w004ak4r3ti9kc94o"},{"post_id":"cka27ixrj000lk4r3wzhnwb4j","tag_id":"cka27ixwt002ak4r33xkx8ul3","_id":"cka27iy0x004ck4r3s86p7obb"},{"post_id":"cka27ixrj000mk4r34rdsftja","tag_id":"cka27ixwi0022k4r3tkw2v1zg","_id":"cka27iy0x004ek4r328sn4h5b"},{"post_id":"cka27ixrj000mk4r34rdsftja","tag_id":"cka27ixvv001kk4r3ti7rqosl","_id":"cka27iy0z004gk4r3e6i1fnho"},{"post_id":"cka27ixrj000mk4r34rdsftja","tag_id":"cka27ixx3002gk4r3nue007jl","_id":"cka27iy10004ik4r3ck6byzsb"},{"post_id":"cka27ixrk000nk4r33by9h7t5","tag_id":"cka27ixvv001kk4r3ti7rqosl","_id":"cka27iy11004kk4r3zhcynj40"},{"post_id":"cka27ixrm000ok4r3eqsohxu0","tag_id":"cka27ixvg0018k4r35wow208f","_id":"cka27iy12004mk4r3j2z5uk69"},{"post_id":"cka27ixrn000pk4r3db3f0ktt","tag_id":"cka27ixvg0018k4r35wow208f","_id":"cka27iy13004nk4r3e5h25imb"},{"post_id":"cka27ixrq000qk4r31b3znfng","tag_id":"cka27ixvg0018k4r35wow208f","_id":"cka27iy14004ok4r3t1nk3bns"},{"post_id":"cka27ixrs000rk4r3ud7hjoh0","tag_id":"cka27ixxe002ok4r3dwen8zvo","_id":"cka27iy14004pk4r3buw6xyoh"},{"post_id":"cka27ixrs000rk4r3ud7hjoh0","tag_id":"cka27ixxe002pk4r3sqjgtlxr","_id":"cka27iy15004qk4r3uj3ezyxa"},{"post_id":"cka27ixrv000tk4r38g29ulyl","tag_id":"cka27ixvv001kk4r3ti7rqosl","_id":"cka27iy15004rk4r3nwqai9ye"},{"post_id":"cka27ixrw000uk4r3ci3u469u","tag_id":"cka27ixv50012k4r3f5yef1co","_id":"cka27iy15004sk4r35be0oazm"},{"post_id":"cka27ixrx000vk4r3qrsg6029","tag_id":"cka27ixxj002sk4r38mr5fhck","_id":"cka27iy16004tk4r31rugd168"},{"post_id":"cka27ixry000wk4r3xketxwji","tag_id":"cka27ixxk002tk4r3cxemqkhj","_id":"cka27iy16004uk4r3ygiw6wcu"},{"post_id":"cka27ixry000wk4r3xketxwji","tag_id":"cka27ixxm002uk4r348m9vxc6","_id":"cka27iy17004vk4r3es8kqwjt"},{"post_id":"cka27ixs1000yk4r3j8gd9qcr","tag_id":"cka27ixxm002vk4r3wl35hzgo","_id":"cka27iy17004wk4r32skkrtdm"},{"post_id":"cka27ixs1000yk4r3j8gd9qcr","tag_id":"cka27ixxo002wk4r3vbi75vt4","_id":"cka27iy17004xk4r343m3a5yf"},{"post_id":"cka27ixs1000zk4r3w72zwi0y","tag_id":"cka27ixxm002vk4r3wl35hzgo","_id":"cka27iy18004yk4r3a7i2m4dq"},{"post_id":"cka27ixs1000zk4r3w72zwi0y","tag_id":"cka27ixxo002wk4r3vbi75vt4","_id":"cka27iy18004zk4r3x86gfz1a"},{"post_id":"cka27ixs20010k4r3byi0eroe","tag_id":"cka27ixxr002zk4r3u0m899cp","_id":"cka27iy190050k4r31yozgu86"},{"post_id":"cka27ixs20010k4r3byi0eroe","tag_id":"cka27ixxs0030k4r35mhaffc0","_id":"cka27iy190051k4r382llbatg"},{"post_id":"cka27ixs20010k4r3byi0eroe","tag_id":"cka27ixxs0031k4r3geqa7xox","_id":"cka27iy1a0052k4r3jmzc5ok3"}],"Tag":[{"name":"binary tree","_id":"cka27ixv50012k4r3f5yef1co"},{"name":"Kanade's Algorithm","_id":"cka27ixva0014k4r3x66k4ipi"},{"name":"Subarray","_id":"cka27ixve0016k4r36jj2gke0"},{"name":"list","_id":"cka27ixvg0018k4r35wow208f"},{"name":"pointer","_id":"cka27ixvi001ak4r314xma1fr"},{"name":"recursion","_id":"cka27ixvm001ek4r3do8lg8po"},{"name":"dynamic programming","_id":"cka27ixvv001kk4r3ti7rqosl"},{"name":"dfs","_id":"cka27ixw1001qk4r3c7e734t8"},{"name":"backtracking","_id":"cka27ixwi0022k4r3tkw2v1zg"},{"name":"HashMap","_id":"cka27ixwt002ak4r33xkx8ul3"},{"name":"review","_id":"cka27ixx3002gk4r3nue007jl"},{"name":"Java","_id":"cka27ixxe002ok4r3dwen8zvo"},{"name":"Java基础","_id":"cka27ixxe002pk4r3sqjgtlxr"},{"name":"https","_id":"cka27ixxj002sk4r38mr5fhck"},{"name":"MySQL","_id":"cka27ixxk002tk4r3cxemqkhj"},{"name":"ACID","_id":"cka27ixxm002uk4r348m9vxc6"},{"name":"STL","_id":"cka27ixxm002vk4r3wl35hzgo"},{"name":"C++","_id":"cka27ixxo002wk4r3vbi75vt4"},{"name":"ReentrantLock","_id":"cka27ixxr002zk4r3u0m899cp"},{"name":"J.U.C","_id":"cka27ixxs0030k4r35mhaffc0"},{"name":"Concurrency","_id":"cka27ixxs0031k4r3geqa7xox"}]}}